<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>Spring Data JDBC-开发手册 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Spring Data JDBC">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Data JDBC-开发手册">
<meta property="og:url" content="http://yoursite.com/2020/08/21/Spring-Data-JDBC-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Spring Data JDBC">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/710c8a9cd7d04fe699138501ab8de7d2-blog-03.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/9fb16fb3af654266bb3d3e0be211615e-blog-04.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/94388ef2eaaa4f9a8586bb72af8e53a1-blog-05.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/fd0edb9248614dc39ea0c42844442904-blog-06.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/652e806707e5436294cbd05becd52904-blog-07.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/2368f004b5cc480ba1c477a9e396f2ba-blog-08.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/cce573ac08374c548fed98abfc259358-blog-09.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/53817dd7328b4b86b946647232afbd42-blog-12.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/eb0065a2dcd84e0aaae6a6083bd02926-blog-10.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/57abb12afe4e4174876128165a36cba6-blog-11.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/80b1faeecf964d6c901bbb1f1613916a-blog-13.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/9a59c9c068eb49ec9e1fe520808566ce-blog-14.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/2580af7d82554d31b9d02bc254ca4b56-blog-15.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/aaa500ddc926434d92d5ea944f855f34-blog-16.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/38fdb797f65b4e97ba475cfbc6bd5924-blog-17.jpg">
<meta property="og:image" content="c:/Users/Cheri_Du/Desktop/blog-18.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/b1897c2d27464695b6f59c2cea82ae12-blog-19.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/48ef52501bf042e5a44f90c74bd1df8d-blog-20.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/36d1f8d68bda42f49b7aa0f359450b92-blog-21.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/27d66dc299a44a7bbd7e78f7f8af2471-blog-22.jpg">
<meta property="og:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/efa52b2beabb481f9cb069e1471615e7-blog-23.jpg">
<meta property="og:image" content="c:/Users/Cheri_Du/Desktop/blog-24.jpg">
<meta property="og:image" content="c:/Users/Cheri_Du/Desktop/blog-25.jpg">
<meta property="og:image" content="c:/Users/Cheri_Du/Desktop/blog-26.jpg">
<meta property="og:image" content="c:/Users/Cheri_Du/Desktop/blog-27.jpg">
<meta property="og:image" content="c:/Users/Cheri_Du/Desktop/blog-28.jpg">
<meta property="og:image" content="c:/Users/Cheri_Du/Desktop/blog-29.jpg">
<meta property="og:image" content="c:/Users/Cheri_Du/Desktop/blog-30.jpg">
<meta property="article:published_time" content="2020-08-21T15:24:50.000Z">
<meta property="article:modified_time" content="2020-08-21T15:25:45.089Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/710c8a9cd7d04fe699138501ab8de7d2-blog-03.jpg">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

<meta name="generator" content="Hexo 5.0.2"></head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1597946283259&amp;di=8dba7d878d1df6917d8d58ad2e8e04e3&amp;imgtype=0&amp;src=http%3A%2F%2Fimg4.a0bi.com%2Fupload%2Fttq%2F20180202%2F1517540247116.jpeg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>
		
		<nav class="header-smart-menu" style="margin:0;">
			<h2>杜康</h2>
			<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
		</nav>
		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
		        
			</div>
			<div style="position:absolute;bottom:300px left:120px;width:80%">
				<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1373280814&auto=1&height=66"></iframe>
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1597946283259&amp;di=8dba7d878d1df6917d8d58ad2e8e04e3&amp;imgtype=0&amp;src=http%3A%2F%2Fimg4.a0bi.com%2Fupload%2Fttq%2F20180202%2F1517540247116.jpeg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author"></h1>
			</hgroup>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-Spring-Data-JDBC-开发手册" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring Data JDBC-开发手册
    </h1>
  

        
        <a href="/2020/08/21/Spring-Data-JDBC-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/" class="archive-article-date">
  	<time datetime="2020-08-21T15:24:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-08-21</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring-Data-JDBC"><a href="#Spring-Data-JDBC" class="headerlink" title="Spring Data JDBC"></a>Spring Data JDBC</h1><a id="more"></a>

<p> <code>2.0.3</code> <strong>Neumann-SR3</strong></p>
<blockquote>
<p>Spring Data JDBC, part of the larger Spring Data family, makes it easy to implement JDBC based repositories. This module deals with enhanced support for JDBC based data access layers. It makes it easier to build Spring powered applications that use data access technologies.</p>
<p>Spring Data JDBC aims at being conceptually easy. In order to achieve this it does NOT offer caching, lazy loading, write behind or many other features of JPA. This makes Spring Data JDBC a simple, limited, opinionated ORM.</p>
</blockquote>
<p>Spring Data JDBC是Spring Data系列的较大的一部分，可轻松实现基于JDBC的存储库。该模块增强了对基于JDBC的数据访问层的处理支持。它使得使用数据访问技术的Spring驱动的应用程序的构建更加容易。</p>
<p>Spring Data JDBC旨在从概念上简化。为了实现此目的，它不提供JPA的缓存，延迟加载，回写或其他许多功能。这使得Spring Data JDBC成为自认为是简单，有限的ORM。</p>
<blockquote>
<h2 id="The-Aggregate-Root"><a href="#The-Aggregate-Root" class="headerlink" title="The Aggregate Root"></a>The Aggregate Root</h2><p>Spring Data repositories are inspired by the repository as described in the book Domain Driven Design by Eric Evans. One consequence of this is that you should have a repository per Aggregate Root. Aggregate Root is another concept from the same book and describes an entity which controls the lifecycle of other entities which together are an Aggregate. An Aggregate is a subset of your model which is consistent between method calls to your Aggregate Root.</p>
<p>Spring Data JDBC tries its best to encourage modeling your domain along these ideas.</p>
</blockquote>
<h2 id="总根"><a href="#总根" class="headerlink" title="总根"></a>总根</h2><p>如Eric Evans的《域驱动设计》一书中所述，Spring Data存储库的灵感来自该存储库。这样的结果之一是，您应该为每个聚合根拥有一个存储库。聚合根是同一本书中的另一个概念，它描述了一个实体，该实体控制其他实体的生命周期，这些实体合在一起就是一个聚合。聚合是模型的子集，在对聚合根之间的方法调用是一致的。</p>
<p>Spring Data JDBC尽力鼓励按照这些想法对您的域进行建模。</p>
<blockquote>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul>
<li>CRUD operations for simple aggregates with customizable <code>NamingStrategy</code>.</li>
<li>Support for <code>@Query</code> annotations.</li>
<li>Support for MyBatis queries.</li>
<li>Events.</li>
<li>JavaConfig based repository configuration by introducing <code>@EnableJdbcRepositories</code>.</li>
</ul>
</blockquote>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li>CRUD操作用于可自定义的简单聚合<code>NamingStrategy</code>。</li>
<li>支持<code>@Query</code>注释。</li>
<li>支持MyBatis查询。</li>
<li>Events事件。</li>
<li>通过<code>@EnableJdbcRepositories</code>引入基于JavaConfig的存储库配置。</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>查看<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/"> Reference Doc.</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api">API Doc.</a></p>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/710c8a9cd7d04fe699138501ab8de7d2-blog-03.jpg" alt="blog-03"></p>
<p>先看看 Reference Doc.](<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/">https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/</a>) 了解使用</p>
<blockquote>
<p> <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api">API Doc.</a> 我们常用来当字典一样 需要的时候查阅Api使用细节。</p>
</blockquote>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/9fb16fb3af654266bb3d3e0be211615e-blog-04.jpg" alt="blog-04"></p>
<p><code>内容还是挺多的。我们还是以常用的来学习。</code></p>
<h1 id="Spring-Data-JDBC-Reference-Documentation"><a href="#Spring-Data-JDBC-Reference-Documentation" class="headerlink" title="Spring Data JDBC - Reference Documentation"></a>Spring Data JDBC - Reference Documentation</h1><p>作者：Jens Schauder, Jay Bryant, Mark Paluch, Bastian Wilhelm</p>
<p>版本信息：Version 2.0.3.RELEASE,2020-08-12</p>
<blockquote>
<p> Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p>
<p>本文档的副本可以供您自己使用，也可以分发给其他人，但前提是您不对此类副本收取任何费用，并且还应确保每个副本均包含本版权声明，无论是印刷版本还是电子版本。</p>
</blockquote>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>The Spring Data JDBC project applies core Spring concepts to the development of solutions that use JDBC databases aligned with <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#jdbc.domain-driven-design">Domain-driven design principles</a>. We provide a “template” as a high-level abstraction for storing and querying aggregates.</p>
<p>This document is the reference guide for Spring Data JDBC Support. It explains the concepts and semantics and syntax..</p>
<p>This section provides some basic introduction. The rest of the document refers only to Spring Data JDBC features and assumes the user is familiar with SQL and Spring concepts.</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Data JDBC项目将Spring的核心概念应用于解决方案的开发，该解决方案使用与<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#jdbc.domain-driven-design">域驱动的设计原则</a>保持一致的JDBC数据库。我们提供“模板”作为用于存储和查询聚合的高级抽象。</p>
<p>本文档是Spring Data JDBC支持的参考指南。它解释了概念，语义和语法。</p>
<p>本节提供一些基本介绍。本文档的其余部分仅涉及Spring Data JDBC功能，并假定用户熟悉SQL和Spring概念。</p>
<h2 id="1-Learning-Spring"><a href="#1-Learning-Spring" class="headerlink" title="1. Learning Spring"></a>1. Learning Spring</h2><blockquote>
<p>Spring Data uses Spring framework’s <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html">core</a> functionality, including:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans">IoC</a> container</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#validation">type conversion system</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#expressions">expression language</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/integration.html#jmx">JMX integration</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/data-access.html#dao-exceptions">DAO exception hierarchy</a>.</li>
</ul>
<p>While you need not know the Spring APIs, understanding the concepts behind them is important. At a minimum, the idea behind Inversion of Control (IoC) should be familiar, and you should be familiar with whatever IoC container you choose to use.</p>
<p>The core functionality of the JDBC Aggregate support can be used directly, with no need to invoke the IoC services of the Spring Container. This is much like <code>JdbcTemplate</code>, which can be used “‘standalone’” without any other services of the Spring container. To leverage all the features of Spring Data JDBC, such as the repository support, you need to configure some parts of the library to use Spring.</p>
<p>To learn more about Spring, you can refer to the comprehensive documentation that explains the Spring Framework in detail. There are a lot of articles, blog entries, and books on the subject. See the Spring framework <a target="_blank" rel="noopener" href="https://spring.io/docs">home page</a> for more information.</p>
</blockquote>
<p>Spring Data使用Spring框架的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html">核心</a>功能，包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans">IoC</a>容器</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#validation">类型转换系统</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#expressions">表达语言</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/integration.html#jmx">JMX整合</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/data-access.html#dao-exceptions">DAO异常层次结构</a>。</li>
</ul>
<p>虽然您不需要了解Spring API，但了解它们背后的概念很重要。至少应该熟悉控制反转（IoC）的概念，并且您应该熟悉选择使用的任何IoC容器。</p>
<p>JDBC Aggregate支持的核心功能可以直接使用，而无需调用Spring容器的IoC服务。这很像<code>JdbcTemplate</code>，可以在没有Spring容器的任何其他服务的情况下“独立”使用。为了利用Spring Data JDBC的所有功能，例如存储库支持，您需要配置库的某些部分以使用Spring。</p>
<p>要了解有关Spring的更多信息，可以参考全面解释Spring框架的文档。关于该主题有很多文章，博客条目和书籍。有关更多信息，请参见Spring框架<a target="_blank" rel="noopener" href="https://spring.io/docs">主页</a>。</p>
<h2 id="2-Requirements"><a href="#2-Requirements" class="headerlink" title="2. Requirements"></a>2. Requirements</h2><blockquote>
<p>The Spring Data JDBC binaries require JDK level 8.0 and above and <a target="_blank" rel="noopener" href="https://spring.io/docs">Spring Framework</a> 5.2.8.RELEASE and above.</p>
<p>In terms of databases, Spring Data JDBC requires a <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#jdbc.dialects">dialect</a> to abstract common SQL functionality over vendor-specific flavours. Spring Data JDBC includes direct support for the following databases:</p>
<ul>
<li>DB2</li>
<li>H2</li>
<li>HSQLDB</li>
<li>MariaDB</li>
<li>Microsoft SQL Server</li>
<li>MySQL</li>
<li>Postgres</li>
</ul>
<p>If you use a different database then your application won’t startup. The <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#jdbc.dialects">dialect</a> section contains further detail on how to proceed in such case.</p>
</blockquote>
<p>Spring Data JDBC二进制文件需要JDK 8.0或更高版本以及<a target="_blank" rel="noopener" href="https://spring.io/docs">Spring Framework</a> 5.2.8.RELEASE或更高版本。</p>
<p>在数据库方面，Spring Data JDBC需要一种<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#jdbc.dialects">方言</a>来抽象特定于供应商特定风格的通用SQL功能。Spring Data JDBC包括对以下数据库的直接支持：</p>
<ul>
<li>DB2</li>
<li>H2</li>
<li>HSQLDB</li>
<li>MariaDB</li>
<li>Microsoft SQL Server</li>
<li>MySQL</li>
<li>Postgres</li>
</ul>
<p>如果您使用其他数据库，则您的应用程序将无法启动。该<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#jdbc.dialects">方言</a>部分包含有关如何在这种情况下进行进一步的细节。</p>
<h2 id="3-Additional-Help-Resources"><a href="#3-Additional-Help-Resources" class="headerlink" title="3. Additional Help Resources"></a>3. Additional Help Resources</h2><blockquote>
<p>Learning a new framework is not always straightforward. In this section, we try to provide what we think is an easy-to-follow guide for starting with the Spring Data JDBC module. However, if you encounter issues or you need advice, feel free to use one of the following links:</p>
<ul>
<li><p>Community Forum</p>
<p>Spring Data on <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/tagged/spring-data">Stack Overflow</a> is a tag for all Spring Data (not just Document) users to share information and help each other. Note that registration is needed only for posting.</p>
</li>
<li><p>Professional Support</p>
<p>Professional, from-the-source support, with guaranteed response time, is available from <a target="_blank" rel="noopener" href="https://pivotal.io/">Pivotal Sofware, Inc.</a>, the company behind Spring Data and Spring.</p>
</li>
</ul>
</blockquote>
<p>学习新框架并不总是那么简单。在本节中，我们尝试提供我们认为是从Spring Data JDBC模块开始易于理解的指南。但是，如果遇到问题或需要建议，请随时使用以下链接之一：</p>
<ul>
<li><p>社区论坛</p>
<p>Spring Data on <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/tagged/spring-data">Stack Overflow</a>是所有Spring Data（不仅仅是Document）用户共享信息和互相帮助的标签。请注意，注册仅用于发布。</p>
</li>
<li><p>专业支持</p>
<p>Spring Data和Spring背后的公司<a target="_blank" rel="noopener" href="https://pivotal.io/">Pivotal Sofware，Inc.</a>可提供专业的，<a target="_blank" rel="noopener" href="https://pivotal.io/">根源性</a>支持的，可确保响应时间的服务。</p>
</li>
</ul>
<h2 id="4-Following-Development"><a href="#4-Following-Development" class="headerlink" title="4. Following Development"></a>4. Following Development</h2><p><code>后续发展</code></p>
<blockquote>
<p>For information on the Spring Data JDBC source code repository, nightly builds, and snapshot artifacts, see the Spring Data JDBC <a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-jdbc/">homepage</a>. You can help make Spring Data best serve the needs of the Spring community by interacting with developers through the Community on <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/tagged/spring-data">Stack Overflow</a>. If you encounter a bug or want to suggest an improvement, please create a ticket on the Spring Data issue <a target="_blank" rel="noopener" href="https://jira.spring.io/browse/DATAJDBC">tracker</a>. To stay up to date with the latest news and announcements in the Spring eco system, subscribe to the Spring Community <a target="_blank" rel="noopener" href="https://spring.io/">Portal</a>. You can also follow the Spring <a target="_blank" rel="noopener" href="https://spring.io/blog">blog</a> or the project team on Twitter (<a target="_blank" rel="noopener" href="https://twitter.com/SpringData">SpringData</a>).</p>
</blockquote>
<p>有关Spring Data JDBC源代码存储库，每夜构建和快照工件的信息，请参阅Spring Data JDBC <a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-jdbc/">主页</a>。通过<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/tagged/spring-data">Stack Overflow</a>社区与开发人员进行交互，可以帮助使Spring Data最好地满足Spring社区的需求。如果您遇到错误或要提出改进建议，请在Spring Data问题<a target="_blank" rel="noopener" href="https://jira.spring.io/browse/DATAJDBC">跟踪器</a>上创建故障单。要了解Spring生态系统中的最新新闻和公告，请订阅Spring Community <a target="_blank" rel="noopener" href="https://spring.io/">Portal</a>。您还可以在Twitter（<a target="_blank" rel="noopener" href="https://twitter.com/SpringData">SpringData</a>）上关注Spring <a target="_blank" rel="noopener" href="https://spring.io/blog">博客</a>或项目团队。</p>
<h2 id="5-Project-Metadata"><a href="#5-Project-Metadata" class="headerlink" title="5. Project Metadata"></a>5. Project Metadata</h2><p><code>项目元数据</code></p>
<blockquote>
<ul>
<li>Release repository: <a target="_blank" rel="noopener" href="https://repo.spring.io/libs-release">https://repo.spring.io/libs-release</a></li>
<li>Milestone repository: <a target="_blank" rel="noopener" href="https://repo.spring.io/libs-milestone">https://repo.spring.io/libs-milestone</a></li>
<li>Snapshot repository: <a target="_blank" rel="noopener" href="https://repo.spring.io/libs-snapshot">https://repo.spring.io/libs-snapshot</a></li>
</ul>
</blockquote>
<ul>
<li>发布存储库：<a target="_blank" rel="noopener" href="https://repo.spring.io/libs-release">https</a> : <a target="_blank" rel="noopener" href="https://repo.spring.io/libs-release">//repo.spring.io/libs-release</a></li>
<li>里程碑存储库：<a target="_blank" rel="noopener" href="https://repo.spring.io/libs-milestone">https</a> : <a target="_blank" rel="noopener" href="https://repo.spring.io/libs-milestone">//repo.spring.io/libs-milestone</a></li>
<li>快照存储库：<a target="_blank" rel="noopener" href="https://repo.spring.io/libs-snapshot">https</a> : <a target="_blank" rel="noopener" href="https://repo.spring.io/libs-snapshot">//repo.spring.io/libs-snapshot</a></li>
</ul>
<h2 id="6-New-amp-Noteworthy"><a href="#6-New-amp-Noteworthy" class="headerlink" title="6. New &amp; Noteworthy"></a>6. New &amp; Noteworthy</h2><p><code>新的和值得注意的</code></p>
<blockquote>
<p>This section covers the significant changes for each version.</p>
</blockquote>
<p>本节涵盖每个版本的重大更改。</p>
<h3 id="6-1-What’s-New-in-Spring-Data-JDBC-2-0"><a href="#6-1-What’s-New-in-Spring-Data-JDBC-2-0" class="headerlink" title="6.1. What’s New in Spring Data JDBC 2.0"></a>6.1. What’s New in Spring Data JDBC 2.0</h3><p><code>Spring Data JDBC 2.0的新功能</code></p>
<blockquote>
<ul>
<li>Optimistic Locking support.</li>
<li>Support for <code>PagingAndSortingRepository</code>.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#jdbc.query-methods">Query Derivation</a>.</li>
<li>Full Support for H2.</li>
<li>All SQL identifiers know get quoted by default.</li>
<li>Missing columns no longer cause exceptions.</li>
</ul>
</blockquote>
<ul>
<li>乐观锁支持。</li>
<li>支持<code>PagingAndSortingRepository</code>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#jdbc.query-methods">查询推导</a>。</li>
<li>完全支持H2。</li>
<li>默认情况下，所有已知的SQL标识符都会被引用。</li>
<li>缺少列不再导致异常</li>
</ul>
<h3 id="6-2-What’s-New-in-Spring-Data-JDBC-1-1"><a href="#6-2-What’s-New-in-Spring-Data-JDBC-1-1" class="headerlink" title="6.2. What’s New in Spring Data JDBC 1.1"></a>6.2. What’s New in Spring Data JDBC 1.1</h3><p><code>Spring Data JDBC 1.1的新增功能</code></p>
<blockquote>
<ul>
<li><code>@Embedded</code> entities support.</li>
<li>Store <code>byte[]</code> as <code>BINARY</code>.</li>
<li>Dedicated <code>insert</code> method in the <code>JdbcAggregateTemplate</code>.</li>
<li>Read only property support.</li>
</ul>
</blockquote>
<ul>
<li><code>@Embedded</code> 实体的支持。</li>
<li>储存<code>byte[]</code>为<code>BINARY</code>。</li>
<li><code>JdbcAggregateTemplate</code>中的专用<code>insert</code>方法。</li>
<li>只读属性支持。</li>
</ul>
<h3 id="6-3-What’s-New-in-Spring-Data-JDBC-1-0"><a href="#6-3-What’s-New-in-Spring-Data-JDBC-1-0" class="headerlink" title="6.3. What’s New in Spring Data JDBC 1.0"></a>6.3. What’s New in Spring Data JDBC 1.0</h3><p><code>Spring Data JDBC 1.0的新增功能</code></p>
<blockquote>
<ul>
<li>Basic support for <code>CrudRepository</code>.</li>
<li><code>@Query</code> support.</li>
<li>MyBatis support.</li>
<li>Id generation.</li>
<li>Event support.</li>
<li>Auditing.</li>
<li><code>CustomConversions</code>.</li>
</ul>
</blockquote>
<ul>
<li><code>CrudRepository</code>的基本支持。</li>
<li><code>@Query</code> 支持。</li>
<li>MyBatis支持。</li>
<li>ID生成。</li>
<li>Event 支持。</li>
<li>审核。</li>
<li><code>CustomConversions</code>。</li>
</ul>
<h2 id="7-Dependencies"><a href="#7-Dependencies" class="headerlink" title="7. Dependencies"></a>7. Dependencies</h2><blockquote>
<p>Due to the different inception dates of individual Spring Data modules, most of them carry different major and minor version numbers. The easiest way to find compatible ones is to rely on the Spring Data Release Train BOM that we ship with the compatible versions defined. In a Maven project, you would declare this dependency in the <code>&lt;dependencyManagement /&gt;</code> section of your POM, as follows:</p>
</blockquote>
<p>由于各个Spring Data模块的起始日期不同，因此大多数模块带有不同的主要和次要版本号。查找兼容版本的最简单方法是依赖于我们附带定义的兼容版本的Spring Data Release Train BOM。在Maven项目中，您将在<code>&lt;dependencyManagement /&gt;</code>POM 的部分中声明此依赖关系，如下所示：</p>
<p>Example 1. Using the Spring Data release train BOM</p>
<p>例子1.使用Spring Data Release系列BOM</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-releasetrain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>Neumann-SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The current release train version is <code>Neumann-SR3</code>. The train names ascend alphabetically and the currently available trains are listed <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-commons/wiki/Release-planning">here</a>. The version name follows the following pattern: <code>$&#123;name&#125;-$&#123;release&#125;</code>, where release can be one of the following:</p>
<ul>
<li><code>BUILD-SNAPSHOT</code>: Current snapshots</li>
<li><code>M1</code>, <code>M2</code>, and so on: Milestones</li>
<li><code>RC1</code>, <code>RC2</code>, and so on: Release candidates</li>
<li><code>RELEASE</code>: GA release</li>
<li><code>SR1</code>, <code>SR2</code>, and so on: Service releases</li>
</ul>
<p>A working example of using the BOMs can be found in our <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples/tree/master/bom">Spring Data examples repository</a>. With that in place, you can declare the Spring Data modules you would like to use without a version in the <code>&lt;dependencies /&gt;</code> block, as follows:</p>
</blockquote>
<p>当前的发行版是<code>Neumann-SR3</code>。版本名称按字母顺序升序，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-commons/wiki/Release-planning">此处</a>列出了当前可用的版本。版本名称遵循以下模式：<code>$&#123;name&#125;-$&#123;release&#125;</code>，其中release可以是以下之一：</p>
<ul>
<li><code>BUILD-SNAPSHOT</code>：当前快照</li>
<li><code>M1</code>，<code>M2</code>等等：里程碑</li>
<li><code>RC1</code>，<code>RC2</code>等等：发布候选</li>
<li><code>RELEASE</code>：GA版本</li>
<li><code>SR1</code>，<code>SR2</code>等等：服务版本</li>
</ul>
<p>在我们的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples/tree/master/bom">Spring Data示例库中</a>可以找到使用BOM的工程示例。有了它，您可以声明要使用的Spring Data模块，而无需在<code>&lt;dependencies /&gt;</code>块中使用版本，如下所示：</p>
<p>Example 2. Declaring a dependency to a Spring Data module</p>
<p><strong>例子2.声明对Spring Data模块的依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-1-Dependency-Management-with-Spring-Boot"><a href="#7-1-Dependency-Management-with-Spring-Boot" class="headerlink" title="7.1. Dependency Management with Spring Boot"></a>7.1. Dependency Management with Spring Boot</h3><p><code>使用Spring Boot进行依赖管理</code></p>
<blockquote>
<p>Spring Boot selects a recent version of Spring Data modules for you. If you still want to upgrade to a newer version, configure the property <code>spring-data-releasetrain.version</code> to the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#dependencies.train-names">train name and iteration</a> you would like to use.</p>
</blockquote>
<p>Spring Boot为您选择了Spring Data模块的最新版本。如果仍要升级到较新的版本，请将该属性配置为<code>spring-data-releasetrain.version</code>要使用的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#dependencies.train-names">版本名称和迭代号</a>。</p>
<h3 id="7-2-Spring-Framework"><a href="#7-2-Spring-Framework" class="headerlink" title="7.2. Spring Framework"></a>7.2. Spring Framework</h3><p><code>spring框架</code></p>
<blockquote>
<p>The current version of Spring Data modules require Spring Framework in version 5.2.8.RELEASE or better. The modules might also work with an older bugfix version of that minor version. However, using the most recent version within that generation is highly recommended.</p>
</blockquote>
<p>当前版本的Spring Data模块要求使用5.2.8.RELEASE或更高版本的Spring Framework。这些模块也可以与该次要版本的较旧错误修正版本一起使用。但是，强烈建议使用该版本中的最新版本。</p>
<h2 id="8-Working-with-Spring-Data-Repositories"><a href="#8-Working-with-Spring-Data-Repositories" class="headerlink" title="8. Working with Spring Data Repositories"></a>8. Working with Spring Data Repositories</h2><p><code>使用Spring Data Repository</code></p>
<blockquote>
<p>The goal of the Spring Data repository abstraction is to significantly reduce the amount of boilerplate code required to implement data access layers for various persistence stores.</p>
<table>
<thead>
<tr>
<th></th>
<th><em>Spring Data repository documentation and your module</em>This chapter explains the core concepts and interfaces of Spring Data repositories. The information in this chapter is pulled from the Spring Data Commons module. It uses the configuration and code samples for the Java Persistence API (JPA) module. You should adapt the XML namespace declaration and the types to be extended to the equivalents of the particular module that you use. “<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.namespace-reference">Namespace reference</a>” covers XML configuration, which is supported across all Spring Data modules supporting the repository API. “<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repository-query-keywords">Repository query keywords</a>” covers the query method keywords supported by the repository abstraction in general. For detailed information on the specific features of your module, see the chapter on that module of this document.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<p>Spring数据存储库抽象的目标是显著减少实现各种持久性存储的数据访问层所需的样板代码量。</p>
<table>
<thead>
<tr>
<th></th>
<th><em>Spring Data Repository文档和您的模块</em>本章介绍了Spring Data存储库的核心概念和接口。本章中的信息来自Spring Data Commons模块。它使用Java Persistence API（JPA）模块的配置和代码示例。您应该使XML名称空间声明和类型适应于所使用的特定模块的等效项。“ <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.namespace-reference">命名空间参考</a> ”涵盖XML配置，所有支持存储库API的Spring Data模块均支持该配置。“ <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repository-query-keywords">存储库查询关键字</a> ”通常涵盖存储库抽象支持的查询方法关键字。有关模块的特定功能的详细信息，请参阅本文档中有关该模块的章节。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="8-1-Core-concepts"><a href="#8-1-Core-concepts" class="headerlink" title="8.1. Core concepts"></a>8.1. Core concepts</h3><p><code>核心概念</code></p>
<blockquote>
<p>The central interface in the Spring Data repository abstraction is <code>Repository</code>. It takes the domain class to manage as well as the ID type of the domain class as type arguments. This interface acts primarily as a marker interface to capture the types to work with and to help you to discover interfaces that extend this one. The <code>CrudRepository</code> provides sophisticated CRUD functionality for the entity class that is being managed.</p>
</blockquote>
<p>Spring Data存储库抽象中的中心接口是<code>Repository</code>。它需要域类以及域类的ID类型作为类型参数来进行管理。该接口主要用作<code>标记接口</code>，以捕获要使用的类型并帮助您发现扩展该接口的接口。该<code>CrudRepository</code>规定对于正在管理的实体类<code>复杂的CRUD功能</code>。</p>
<p>Example 3. <code>CrudRepository</code> interface</p>
<p>例子3. <code>CrudRepository</code>界面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;      </span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(ID primaryKey)</span></span>; </span><br><span class="line"></span><br><span class="line">  <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;               </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;                        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(T entity)</span></span>;               </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">existsById</span><span class="params">(ID primaryKey)</span></span>;   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// … more functionality omitted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/94388ef2eaaa4f9a8586bb72af8e53a1-blog-05.jpg" alt="blog-05"></p>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/fd0edb9248614dc39ea0c42844442904-blog-06.jpg" alt="blog-06"></p>
<ol>
<li>保存给定的实体。</li>
<li>返回由给定ID标识的实体。</li>
<li>返回所有实体。</li>
<li>返回实体数。</li>
<li>删除给定的实体。</li>
<li>指示是否存在具有给定ID的实体。</li>
</ol>
<blockquote>
<p> We also provide persistence technology-specific abstractions, such as <code>JpaRepository</code> or <code>MongoRepository</code>. Those interfaces extend <code>CrudRepository</code> and expose the capabilities of the underlying persistence technology in addition to the rather generic persistence technology-agnostic interfaces such as <code>CrudRepository</code>.</p>
<p> 我们还提供了特定于持久性技术的抽象，例如<code>JpaRepository</code>或<code>MongoRepository</code>。这些接口除了扩展了<code>CrudRepository</code>与持久性技术无关的通用接口之外，还扩展并公开了基础持久性技术的功能（例如）<code>CrudRepository</code>。</p>
</blockquote>
<blockquote>
<p>On top of the <code>CrudRepository</code>, there is a <code>PagingAndSortingRepository</code> abstraction that adds additional methods to ease paginated access to entities:</p>
<p>在之<code>CrudRepository</code>上，有一个<code>PagingAndSortingRepository</code>抽象，它添加了其他方法来简化对实体的分页访问：</p>
</blockquote>
<p><strong>Example 4.</strong> <code>PagingAndSortingRepository</code> <strong>interface</strong></p>
<p>例子4. <code>PagingAndSortingRepository</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Page&lt;T&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>To access the second page of <code>User</code> by a page size of 20, you could do something like the following:</p>
<p>要访问第二页（<code>User</code>页面大小为20），您可以执行以下操作：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PagingAndSortingRepository&lt;User, Long&gt; repository = <span class="comment">// … get access to a bean</span></span><br><span class="line">Page&lt;User&gt; users = repository.findAll(PageRequest.of(<span class="number">1</span>, <span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>In addition to query methods, query derivation for both count and delete queries is available. The following list shows the interface definition for a derived count query:</p>
<p>除了查询方法之外，还可以使用计数和删除查询的查询派生类。以下列表显示派生类计数查询的接口定义：</p>
</blockquote>
<p><strong>Example 5. Derived Count Query</strong></p>
<p><code>例子5.派生类计数查询</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">countByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The following list shows the interface definition for a derived delete query:</p>
<p>以下列表显示了派生类的删除查询的接口定义：</p>
</blockquote>
<p><strong>Example 6. Derived Delete Query</strong></p>
<p><code>例子6.派生的删除查询</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">deleteByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">removeByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-Query-methods"><a href="#8-2-Query-methods" class="headerlink" title="8.2. Query methods"></a>8.2. Query methods</h3><blockquote>
<p>Standard CRUD functionality repositories usually have queries on the underlying datastore. With Spring Data, declaring those queries becomes a four-step process:</p>
<ol>
<li>Declare an interface extending Repository or one of its subinterfaces and type it to the domain class and ID type that it should handle, as shown in the following example:</li>
</ol>
</blockquote>
<p>标准CRUD功能存储库通常在基础数据存储上进行查询。使用Spring Data，声明这些查询将分为四个步骤：</p>
<ol>
<li><blockquote>
<p>Declare an interface extending Repository or one of its subinterfaces and type it to the domain class and ID type that it should handle, as shown in the following example:</p>
<p>声明扩展存储库的接口或其子接口之一，然后将其键入到它应处理的域类和ID类型，如以下示例所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p>Declare query methods on the interface.</p>
<p>在接口上声明查询方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Set up Spring to create proxy instances for those interfaces, either with <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.create-instances.java-config">JavaConfig</a> or with <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.create-instances">XML configuration</a>.</p>
<ol>
<li><p>To use Java configuration, create a class similar to the following:</p>
<p>设置Spring以使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.create-instances.java-config">JavaConfig</a>或<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.create-instances">XML configuration</a>为这些接口创建代理实例。</p>
<p>a、要使用Java配置，请创建类似于以下内容的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>b、To use XML configuration, define a bean similar to the following:</p>
<p>要使用XML配置，请定义类似于以下内容的bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:jpa</span>=<span class="string">&quot;http://www.springframework.org/schema/data/jpa&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">     https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/data/jpa</span></span></span><br><span class="line"><span class="tag"><span class="string">     https://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">jpa:repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repositories&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>The JPA namespace is used in this example. If you use the repository abstraction for any other store, you need to change this to the appropriate namespace declaration of your store module. In other words, you should exchange <code>jpa</code> in favor of, for example, <code>mongodb</code>.</p>
<p>+ Also, note that the JavaConfig variant does not configure a package explicitly, because the package of the annotated class is used by default. To customize the package to scan, use one of the <code>basePackage…</code> attributes of the data-store-specific repository’s <code>@Enable$&#123;store&#125;Repositories</code>-annotation.</p>
<p>在此示例中使用了JPA命名空间。如果将存储库抽象用于任何其他存储，则需要将其更改为存储模块的适当名称空间声明。换句话说，您应该交换合适的<code>jpa</code>，例如<code>mongodb</code>。</p>
<p>+另外，请注意，JavaConfig变量不会显式配置程序包，因为默认情况下使用带注释的类的程序包。要自定义要扫描的程序包，请使用<code>basePackage…</code>的属性之一<code>@Enable$&#123;store&#125;Repositories</code>-annotation指定数据存储库 。</p>
</li>
<li><p>Inject the repository instance and use it, as shown in the following example:</p>
<p>注入存储库实例并使用它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PersonRepository repository;</span><br><span class="line"></span><br><span class="line">  SomeClient(PersonRepository repository) &#123;</span><br><span class="line">    <span class="keyword">this</span>.repository = repository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Person&gt; persons = repository.findByLastname(<span class="string">&quot;Matthews&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>The sections that follow explain each step in detail:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.definition">Defining Repository Interfaces</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.query-methods.details">Defining Query Methods</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.create-instances">Creating Repository Instances</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.custom-implementations">Custom Implementations for Spring Data Repositories</a></li>
</ul>
<p>以下各节详细说明了每个步骤：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.definition">定义存储库接口</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.query-methods.details">定义查询方法</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.create-instances">创建存储库实例</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.custom-implementations">Spring数据存储库的定制实现</a></li>
</ul>
<h3 id="8-3-Defining-Repository-Interfaces"><a href="#8-3-Defining-Repository-Interfaces" class="headerlink" title="8.3. Defining Repository Interfaces"></a>8.3. Defining Repository Interfaces</h3><p><code>定义存储库接口</code></p>
<blockquote>
<p>First, define a domain class-specific repository interface. The interface must extend <code>Repository</code> and be typed to the domain class and an ID type. If you want to expose CRUD methods for that domain type, extend <code>CrudRepository</code> instead of <code>Repository</code>.</p>
</blockquote>
<p>首先，定义特定于域类的存储库接口。接口必须扩展，<code>Repository</code>并键入域类和ID类型。如果要公开该域类型的CRUD方法，请扩展<code>CrudRepository</code>而不是<code>Repository</code>。</p>
<h4 id="8-3-1-Fine-tuning-Repository-Definition"><a href="#8-3-1-Fine-tuning-Repository-Definition" class="headerlink" title="8.3.1. Fine-tuning Repository Definition"></a>8.3.1. Fine-tuning Repository Definition</h4><p><code>微调存储库定义</code></p>
<blockquote>
<p>Typically, your repository interface extends <code>Repository</code>, <code>CrudRepository</code>, or <code>PagingAndSortingRepository</code>. Alternatively, if you do not want to extend Spring Data interfaces, you can also annotate your repository interface with <code>@RepositoryDefinition</code>. Extending <code>CrudRepository</code> exposes a complete set of methods to manipulate your entities. If you prefer to be selective about the methods being exposed, copy the methods you want to expose from <code>CrudRepository</code> into your domain repository.</p>
<p>通常情况下，你的存储库接口扩展<code>Repository</code>，<code>CrudRepository</code>或<code>PagingAndSortingRepository</code>这些。另外，如果您不想扩展Spring Data接口，也可以使用注释您的存储库接口<code>@RepositoryDefinition</code>。通过扩展<code>CrudRepository</code>来提供一套完整的方法来操纵您的实体。如果您希望对公开的方法保持选择性，请将要公开的方法复制<code>CrudRepository</code>到域存储库中。</p>
</blockquote>
<blockquote>
<table>
<thead>
<tr>
<th></th>
<th>Doing so lets you define your own abstractions on top of the provided Spring Data Repositories functionality.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>这样做可以让您在提供的Spring Data Repositories功能之上定义自己的抽象。</td>
</tr>
</tbody></table>
</blockquote>
<p>The following example shows how to selectively expose CRUD methods (<code>findById</code> and <code>save</code>, in this case):</p>
<p>下面的示例给出了如何以选择性地露出CRUD方法（<code>findById</code>和<code>save</code>，在这种情况下）：</p>
<p>Example 7. Selectively exposing CRUD methods</p>
<p><strong>例子7.有选择地公开CRUD方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(ID id)</span></span>;</span><br><span class="line"></span><br><span class="line">  &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>In the prior example, you defined a common base interface for all your domain repositories and exposed <code>findById(…)</code> as well as <code>save(…)</code>.These methods are routed into the base repository implementation of the store of your choice provided by Spring Data (for example, if you use JPA, the implementation is <code>SimpleJpaRepository</code>), because they match the method signatures in <code>CrudRepository</code>. So the <code>UserRepository</code> can now save users, find individual users by ID, and trigger a query to find <code>Users</code> by email address.</p>
<p>在前面的示例中，您为所有域存储库定义了一个通用的基本接口，并公开<code>findById(…)</code>了以及<code>save(…)</code>这些接口。这些方法被路由到Spring Data提供的所选存储的基本存储库实现中（例如，如果您使用JPA，实现是<code>SimpleJpaRepository</code>），因为它们与其中的方法签名相匹配<code>CrudRepository</code>。因此，他们<code>UserRepository</code>现在可以保存用户，按ID查找单个用户，并触发查询以<code>Users</code>按电子邮件地址查找。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>The intermediate repository interface is annotated with <code>@NoRepositoryBean</code>. Make sure you add that annotation to all repository interfaces for which Spring Data should not create instances at runtime.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>存储库接口中间用注释<code>@NoRepositoryBean</code>。确保将注释添加到所有存储库接口，Spring Data不应在运行时为其创建实例。</td>
</tr>
</tbody></table>
<h4 id="8-3-2-Using-Repositories-with-Multiple-Spring-Data-Modules"><a href="#8-3-2-Using-Repositories-with-Multiple-Spring-Data-Modules" class="headerlink" title="8.3.2. Using Repositories with Multiple Spring Data Modules"></a>8.3.2. Using Repositories with Multiple Spring Data Modules</h4><p><code>将存储库与多个Spring数据模块一起使用</code></p>
<blockquote>
<p>Using a unique Spring Data module in your application makes things simple, because all repository interfaces in the defined scope are bound to the Spring Data module. Sometimes, applications require using more than one Spring Data module. In such cases, a repository definition must distinguish between persistence technologies. When it detects multiple repository factories on the class path, Spring Data enters strict repository configuration mode. Strict configuration uses details on the repository or the domain class to decide about Spring Data module binding for a repository definition:</p>
<ol>
<li>If the repository definition <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.multiple-modules.types">extends the module-specific repository</a>, then it is a valid candidate for the particular Spring Data module.</li>
<li>If the domain class is <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.multiple-modules.annotations">annotated with the module-specific type annotation</a>, then it is a valid candidate for the particular Spring Data module. Spring Data modules accept either third-party annotations (such as JPA’s <code>@Entity</code>) or provide their own annotations (such as <code>@Document</code> for Spring Data MongoDB and Spring Data Elasticsearch).</li>
</ol>
<p>The following example shows a repository that uses module-specific interfaces (JPA in this case):</p>
</blockquote>
<p>在您的应用程序中使用唯一的Spring Data模块使事情变得简单，因为已定义范围中的所有存储库接口均已绑定到Spring Data模块。有时，应用程序需要使用多个Spring Data模块。在这种情况下，存储库定义必须区分持久性技术。当它在类路径上检测到多个存储库工厂时，Spring Data进入严格的存储库配置模式。严格的配置使用存储库或域类上的详细信息来决定有关存储库定义的Spring Data模块绑定：</p>
<ol>
<li>如果存储库定义<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.multiple-modules.types">扩展了特定于模块的存储库</a>，则它是特定Spring Data模块的有效候选者。</li>
<li>如果该域类<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.multiple-modules.annotations">使用模块特定类型注释进行注释</a>，则它是特定Spring Data模块的有效候选者。Spring Data模块可以接受第三方注释（例如JPA的注释<code>@Entity</code>），也可以提供自己的注释（例如<code>@Document</code>Spring Data MongoDB和Spring Data Elasticsearch 的注释）。</li>
</ol>
<p>以下示例显示了使用模块特定接口（在这种情况下为JPA）的存储库：</p>
<p>Example 8. Repository definitions using module-specific interfaces</p>
<p><strong>例子8.使用模块特定接口的存储库定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>MyRepository</code> and <code>UserRepository</code> extend <code>JpaRepository</code> in their type hierarchy. They are valid candidates for the Spring Data JPA module.</p>
<p><code>MyRepository</code>和<code>UserRepository</code>扩展<code>JpaRepository</code>其类型层次结构。它们是Spring Data JPA模块的有效候选者。</p>
</blockquote>
<p>The following example shows a repository that uses generic interfaces:</p>
<p>以下示例显示了使用通用接口的存储库：</p>
<p><strong>Example 9. Repository definitions using generic interfaces</strong></p>
<p>示例9.使用通用接口的存储库定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AmbiguousRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AmbiguousUserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>AmbiguousRepository</code> and <code>AmbiguousUserRepository</code> extend only <code>Repository</code> and <code>CrudRepository</code> in their type hierarchy. While this is perfectly fine when using a unique Spring Data module, multiple modules cannot distinguish to which particular Spring Data these repositories should be bound.</p>
</blockquote>
<p><code>AmbiguousRepository</code>和<code>AmbiguousUserRepository</code>仅延伸<code>Repository</code>，并<code>CrudRepository</code>在他们的类型层次。尽管在使用唯一的Spring Data模块时这很好，但是多个模块无法区分这些存储库应绑定到哪个特定的Spring Data。</p>
<p>The following example shows a repository that uses domain classes with annotations:</p>
<p>以下示例显示了使用带注释的域类的存储库：</p>
<p><strong>Example 10. Repository definitions using domain classes with annotations</strong></p>
<p><strong>例子10.使用带有注释的域类的存储库定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>PersonRepository</code> references <code>Person</code>, which is annotated with the JPA <code>@Entity</code> annotation, so this repository clearly belongs to Spring Data JPA. <code>UserRepository</code> references <code>User</code>, which is annotated with Spring Data MongoDB’s <code>@Document</code> annotation.</p>
</blockquote>
<p><code>PersonRepository</code>引用 <code>Person</code>，它使用JPA <code>@Entity</code>注释进行了注释，因此该存储库显然属于Spring Data JPA。<code>UserRepository</code>引用<code>User</code>，使用Spring Data MongoDB的<code>@Document</code>注释进行注释。</p>
<p>The following bad example shows a repository that uses domain classes with mixed annotations:</p>
<p>以下不良示例显示了使用带有混合批注的域类的存储库：</p>
<p><strong>Example 11. Repository definitions using domain classes with mixed annotations</strong></p>
<p><strong>例子11.使用带有混合注释的域类的存储库定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JpaPersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MongoDBPersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This example shows a domain class using both JPA and Spring Data MongoDB annotations. It defines two repositories, <code>JpaPersonRepository</code> and <code>MongoDBPersonRepository</code>. One is intended for JPA and the other for MongoDB usage. Spring Data is no longer able to tell the repositories apart, which leads to undefined behavior.</p>
</blockquote>
<p>此示例显示了同时使用JPA和Spring Data MongoDB批注的域类。它定义了两个存储库<code>JpaPersonRepository</code>和<code>MongoDBPersonRepository</code>。一个用于JPA，另一个用于MongoDB。Spring Data不再能够区分存储库，这导致不确定的行为。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.multiple-modules.types">Repository type details</a> and <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.multiple-modules.annotations">distinguishing domain class annotations</a> are used for strict repository configuration to identify repository candidates for a particular Spring Data module. Using multiple persistence technology-specific annotations on the same domain type is possible and enables reuse of domain types across multiple persistence technologies. However, Spring Data can then no longer determine a unique module with which to bind the repository.</p>
<p>The last way to distinguish repositories is by scoping repository base packages. Base packages define the starting points for scanning for repository interface definitions, which implies having repository definitions located in the appropriate packages. By default, annotation-driven configuration uses the package of the configuration class. The <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.create-instances.spring">base package in XML-based configuration</a> is mandatory.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.multiple-modules.types">存储库类型详细信息</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.multiple-modules.annotations">可区分的域类批注</a>用于严格的存储库配置，以标识特定Spring Data模块的存储库候选对象。在同一个域类型上使用多个特定于持久性技术的注释是可能的，并且可以跨多种持久性技术重用域类型。但是，Spring Data无法再确定用于绑定存储库的唯一模块。</p>
<p>区分存储库的最后一种方法是确定存储库基础包的范围。基本软件包定义了扫描存储库接口定义的起点，这意味着将存储库定义放在适当的软件包中。默认情况下，注释驱动的配置使用配置类的包。<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.create-instances.spring">基于XML的配置中</a>的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.create-instances.spring">基本软件包</a>是必需的。</p>
<p>The following example shows annotation-driven configuration of base packages:</p>
<p>以下示例显示了基础包的注释驱动配置：</p>
<p><strong>Example 12. Annotation-driven configuration of base packages</strong></p>
<p>例子12.基础包的注释驱动配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &quot;com.acme.repositories.jpa&quot;)</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories(basePackages = &quot;com.acme.repositories.mongo&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-Defining-Query-Methods"><a href="#8-4-Defining-Query-Methods" class="headerlink" title="8.4. Defining Query Methods"></a>8.4. Defining Query Methods</h3><p><code>定义查询方法</code></p>
<blockquote>
<p>The repository proxy has two ways to derive a store-specific query from the method name:</p>
<ul>
<li>By deriving the query from the method name directly.</li>
<li>By using a manually defined query.</li>
</ul>
<p>Available options depend on the actual store. However, there must be a strategy that decides what actual query is created. The next section describes the available options.</p>
</blockquote>
<p>存储库代理有两种从方法名称派生特定于存储库的查询的方式：</p>
<ul>
<li>通过直接从方法名称派生查询。</li>
<li>通过使用手动定义的查询。</li>
</ul>
<p>可用选项取决于实际存储库。但是，必须有一个策略来决定要创建的实际查询。下一节将介绍可用的选项。</p>
<h4 id="8-4-1-Query-Lookup-Strategies"><a href="#8-4-1-Query-Lookup-Strategies" class="headerlink" title="8.4.1. Query Lookup Strategies"></a>8.4.1. Query Lookup Strategies</h4><p><code>查询的查询策略</code></p>
<blockquote>
<p>The following strategies are available for the repository infrastructure to resolve the query. With XML configuration, you can configure the strategy at the namespace through the <code>query-lookup-strategy</code> attribute. For Java configuration, you can use the <code>queryLookupStrategy</code> attribute of the <code>Enable$&#123;store&#125;Repositories</code> annotation. Some strategies may not be supported for particular datastores.</p>
<ul>
<li><code>CREATE</code> attempts to construct a store-specific query from the query method name. The general approach is to remove a given set of well known prefixes from the method name and parse the rest of the method. You can read more about query construction in “<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.query-methods.query-creation">Query Creation</a>”.</li>
<li><code>USE_DECLARED_QUERY</code> tries to find a declared query and throws an exception if cannot find one. The query can be defined by an annotation somewhere or declared by other means. Consult the documentation of the specific store to find available options for that store. If the repository infrastructure does not find a declared query for the method at bootstrap time, it fails.</li>
<li><code>CREATE_IF_NOT_FOUND</code> (default) combines <code>CREATE</code> and <code>USE_DECLARED_QUERY</code>. It looks up a declared query first, and, if no declared query is found, it creates a custom method name-based query. This is the default lookup strategy and, thus, is used if you do not configure anything explicitly. It allows quick query definition by method names but also custom-tuning of these queries by introducing declared queries as needed.</li>
</ul>
</blockquote>
<p>以下策略可用于存储库基础结构来解决查询。使用XML配置，您可以通过<code>query-lookup-strategy</code>属性在名称空间中配置策略。对于Java配置，可以使用注释的<code>queryLookupStrategy</code>属性<code>Enable$&#123;store&#125;Repositories</code>。某些数据存储可能不支持某些策略。</p>
<ul>
<li><code>CREATE</code>尝试从查询方法名称构造特定于存储库的查询。通用方法是从方法名称中删除一组给定的众所周知的前缀，然后解析该方法的其余部分。您可以在“ <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.query-methods.query-creation">查询创建</a> ”中阅读有关查询构造的更多信息。</li>
<li><code>USE_DECLARED_QUERY</code>尝试查找已声明的查询，如果找不到则抛出异常。该查询可以通过某处的注释定义，也可以通过其他方式声明。请查阅特定存储库的文档以找到该存储库的可用选项。如果存储库基础结构在引导时找不到该方法的声明查询，则它将失败。</li>
<li><code>CREATE_IF_NOT_FOUND</code>（默认）组合<code>CREATE</code>和<code>USE_DECLARED_QUERY</code>。它首先查找一个声明的查询，如果找不到声明的查询，它将创建一个基于名称的自定义方法查询。这是默认的查找策略，因此，如果未显式配置任何内容，则使用该策略。它允许通过方法名称快速定义查询，还可以通过根据需要引入已声明的查询来自定义调整这些查询。</li>
</ul>
<h4 id="8-4-2-Query-Creation"><a href="#8-4-2-Query-Creation" class="headerlink" title="8.4.2. Query Creation"></a>8.4.2. Query Creation</h4><p><code>查询创建</code></p>
<blockquote>
<p>The query builder mechanism built into Spring Data repository infrastructure is useful for building constraining queries over entities of the repository. The mechanism strips the prefixes <code>find…By</code>, <code>read…By</code>, <code>query…By</code>, <code>count…By</code>, and <code>get…By</code> from the method and starts parsing the rest of it. The introducing clause can contain further expressions, such as a <code>Distinct</code> to set a distinct flag on the query to be created. However, the first <code>By</code> acts as delimiter to indicate the start of the actual criteria. At a very basic level, you can define conditions on entity properties and concatenate them with <code>And</code> and <code>Or</code>. The following example shows how to create a number of queries:</p>
</blockquote>
<p>内置在Spring Data存储库基础结构中的查询构建器机制对于在存储库实体上构建约束查询很有用。该机制条前缀<code>find…By</code>，<code>read…By</code>，<code>query…By</code>，<code>count…By</code>，和<code>get…By</code>从所述方法和开始解析它的其余部分。Introduction子句可以包含其他表达式，例如a，<code>Distinct</code>以在要创建的查询上设置不同的标志。但是，第一个<code>By</code>充当分隔符以指示实际标准的开始。在最基本的级别上，您可以定义实体属性的条件，并将其进行与<code>And</code>和连接<code>Or</code>。以下示例显示了如何创建多个查询：</p>
<p><strong>Example 13. Query creation from method names</strong></p>
<p>例子13.从方法名查询创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByEmailAddressAndLastname</span><span class="params">(EmailAddress emailAddress, String lastname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enables the distinct flag for the query</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findDistinctPeopleByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findPeopleDistinctByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enabling ignoring case for an individual property</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameIgnoreCase</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">  <span class="comment">// Enabling ignoring case for all suitable properties</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameAndFirstnameAllIgnoreCase</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enabling static ORDER BY for a query</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameOrderByFirstnameAsc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameOrderByFirstnameDesc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The actual result of parsing the method depends on the persistence store for which you create the query. However, there are some general things to notice:</p>
<ul>
<li>The expressions are usually property traversals combined with operators that can be concatenated. You can combine property expressions with <code>AND</code> and <code>OR</code>. You also get support for operators such as <code>Between</code>, <code>LessThan</code>, <code>GreaterThan</code>, and <code>Like</code> for the property expressions. The supported operators can vary by datastore, so consult the appropriate part of your reference documentation.</li>
<li>The method parser supports setting an <code>IgnoreCase</code> flag for individual properties (for example, <code>findByLastnameIgnoreCase(…)</code>) or for all properties of a type that supports ignoring case (usually <code>String</code> instances — for example, <code>findByLastnameAndFirstnameAllIgnoreCase(…)</code>). Whether ignoring cases is supported may vary by store, so consult the relevant sections in the reference documentation for the store-specific query method.</li>
<li>You can apply static ordering by appending an <code>OrderBy</code> clause to the query method that references a property and by providing a sorting direction (<code>Asc</code> or <code>Desc</code>). To create a query method that supports dynamic sorting, see “<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.special-parameters">Special parameter handling</a>”.</li>
</ul>
</blockquote>
<p>解析该方法的实际结果取决于您为其创建查询的持久性存储。但是，需要注意一些一般事项：</p>
<ul>
<li>表达式通常是属性遍历，并带有可串联的运算符。您可以使用<code>AND</code>和组合属性表达式<code>OR</code>。您还可以得到这样的操作来支撑<code>Between</code>，<code>LessThan</code>，<code>GreaterThan</code>，和<code>Like</code>该属性的表达式。支持的运算符可能因数据存储而异，因此请参考<code>参考文档</code>的相应部分。</li>
<li>方法解析器支持<code>IgnoreCase</code>为单个属性（例如<code>findByLastnameIgnoreCase(…)</code>）或支持忽略大小写的类型的所有属性（通常是<code>String</code>实例，例如<code>findByLastnameAndFirstnameAllIgnoreCase(…)</code>）设置标志。是否支持忽略大小写可能因存储库而异，因此请参考<code>参考文档</code>中有关存储库特定查询方法的相关部分。</li>
<li>您可以通过将<code>OrderBy</code>子句附加到引用属性的查询方法并提供排序方向（<code>Asc</code>或<code>Desc</code>）来应用静态排序。要创建支持动态排序的查询方法，请参阅“ <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.special-parameters">特殊参数处理</a> ”。</li>
</ul>
<h4 id="8-4-3。Property-Expressions"><a href="#8-4-3。Property-Expressions" class="headerlink" title="8.4.3。Property Expressions"></a>8.4.3。Property Expressions</h4><p><code>属性表达式</code></p>
<blockquote>
<p>Property expressions can refer only to a direct property of the managed entity, as shown in the preceding example. At query creation time, you already make sure that the parsed property is a property of the managed domain class. However, you can also define constraints by traversing nested properties. Consider the following method signature:</p>
<p>如上例所示，属性表达式只能引用被管实体的直接属性。在查询创建时，您已经确保已解析的属性是托管域类的属性。但是，您也可以通过遍历嵌套属性来定义约束。考虑以下方法签名：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddressZipCode</span><span class="params">(ZipCode zipCode)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Assume a <code>Person</code> has an <code>Address</code> with a <code>ZipCode</code>. In that case, the method creates the property traversal <code>x.address.zipCode</code>. The resolution algorithm starts by interpreting the entire part (<code>AddressZipCode</code>) as the property and checks the domain class for a property with that name (uncapitalized). If the algorithm succeeds, it uses that property. If not, the algorithm splits up the source at the camel case parts from the right side into a head and a tail and tries to find the corresponding property — in our example, <code>AddressZip</code> and <code>Code</code>. If the algorithm finds a property with that head, it takes the tail and continues building the tree down from there, splitting the tail up in the way just described. If the first split does not match, the algorithm moves the split point to the left (<code>Address</code>, <code>ZipCode</code>) and continues.</p>
</blockquote>
<blockquote>
<p>Although this should work for most cases, it is possible for the algorithm to select the wrong property. Suppose the <code>Person</code> class has an <code>addressZip</code> property as well. The algorithm would match in the first split round already, choose the wrong property, and fail (as the type of <code>addressZip</code> probably has no <code>code</code> property).</p>
<p>To resolve this ambiguity you can use <code>_</code> inside your method name to manually define traversal points. So our method name would be as follows:</p>
<p>假设<code>Person</code>的<code>Address</code>带有<code>ZipCode</code>。在这种情况下，该方法将创建属性遍历<code>x.address.zipCode</code>。解析算法首先将整个部分（<code>AddressZipCode</code>）解释为属性，然后检查域类中具有该名称的属性（未大写）。如果算法成功，它将使用该属性。如果不是，该算法将骆驼部分的源从右侧分为头和尾，并尝试找到相应的属性-在我们的示例中为<code>AddressZip</code>和<code>Code</code>。如果该算法找到了具有该头部的属性，则将其取为尾部并继续从那里开始构建树，以刚才描述的方式将尾部向上拆分。如果第一个分割不匹配，则算法会将分割点移到左侧（<code>Address</code>，<code>ZipCode</code>）并继续。</p>
<p>尽管这在大多数情况下应该可行，但算法可能会选择错误的属性。假设<code>Person</code>该类也具有一个<code>addressZip</code>属性。该算法将在第一轮拆分中已经匹配，选择错误的属性，然后失败（因为类型<code>addressZip</code>可能没有<code>code</code>属性）。</p>
<p>要解决这种歧义，您可以使用<code>_</code>在方法名称内部使用手动定义遍历点。因此，我们的方法名称如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddress_ZipCode</span><span class="params">(ZipCode zipCode)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Because we treat the underscore character as a reserved character, we strongly advise following standard Java naming conventions (that is, not using underscores in property names but using camel case instead).</p>
<p>因为我们将下划线字符视为保留字符，所以我们强烈建议您遵循以下标准Java命名约定（即，在属性名称中不使用下划线，而使用驼峰大小写）。</p>
</blockquote>
<h4 id="8-4-4-Special-parameter-handling"><a href="#8-4-4-Special-parameter-handling" class="headerlink" title="8.4.4. Special parameter handling"></a>8.4.4. Special parameter handling</h4><p>​    <code>特殊参数处理</code></p>
<blockquote>
<p>To handle parameters in your query, define method parameters as already seen in the preceding examples. Besides that, the infrastructure recognizes certain specific types like <code>Pageable</code> and <code>Sort</code>, to apply pagination and sorting to your queries dynamically. The following example demonstrates these features:</p>
<p>Example 14. Using <code>Pageable</code>, <code>Slice</code>, and <code>Sort</code> in query methods</p>
</blockquote>
<p>要处理查询中的参数，请定义方法参数，如前面的示例所示。除此之外，基础架构还可以识别某些特定类型（例如<code>Pageable</code>和<code>Sort</code>，以便将分页和排序动态应用于您的查询。下面的示例演示了这些功能：</p>
<p>例14. 在查询方法中使用<code>Pageable</code>，<code>Slice</code>和<code>Sort</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> APIs taking <code>Sort</code> and <code>Pageable</code> expect non-<code>null</code> values to be handed into methods. If you don’t want to apply any sorting or pagination use <code>Sort.unsorted()</code> and <code>Pageable.unpaged()</code>.</p>
</blockquote>
<p> 接受<code>Sort</code>和<code>Pageable</code>期望将非<code>null</code>值传递给方法的API 。如果您不想应用任何排序或分页，请使用<code>Sort.unsorted()</code>和<code>Pageable.unpaged()</code>。</p>
<blockquote>
<p>The first method lets you pass an <code>org.springframework.data.domain.Pageable</code> instance to the query method to dynamically add paging to your statically defined query. A <code>Page</code> knows about the total number of elements and pages available. It does so by the infrastructure triggering a count query to calculate the overall number. As this might be expensive (depending on the store used), you can instead return a <code>Slice</code>. A <code>Slice</code> only knows about whether a next <code>Slice</code> is available, which might be sufficient when walking through a larger result set.</p>
<p>Sorting options are handled through the <code>Pageable</code> instance, too. If you only need sorting, add an <code>org.springframework.data.domain.Sort</code> parameter to your method. As you can see, returning a <code>List</code> is also possible. In this case, the additional metadata required to build the actual <code>Page</code> instance is not created (which, in turn, means that the additional count query that would have been necessary is not issued). Rather, it restricts the query to look up only the given range of entities.</p>
</blockquote>
<p>第一种方法使您可以将<code>org.springframework.data.domain.Pageable</code>实例传递给查询方法，以向静态定义的查询中动态添加分页。A <code>Page</code>知道可用元素和页面的总数。它是通过基础结构触发计数查询来计算总数来实现的。由于这可能会代价高（取决于使用的存储库），因此您可以改为返回<code>Slice</code>。一个<code>Slice</code>只知道下一个<code>Slice</code>是否可用的，当遍历更大的结果集时可能就足够了。</p>
<p>排序选项也通过<code>Pageable</code>实例处理。如果只需要排序，请<code>org.springframework.data.domain.Sort</code>向您的方法中添加一个参数。如您所见，返回a <code>List</code>也是可能的。在这种情况下，<code>Page</code>不会创建构建实际实例所需的其他元数据（这反过来，这意味着不会发出本来必要的其他计数查询）。而是，它将查询限制为仅查找给定范围的实体。</p>
<blockquote>
<p> To find out how many pages you get for an entire query, you have to trigger an additional count query. By default, this query is derived from the query you actually trigger.</p>
</blockquote>
<p> 要查明整个查询可获得多少页，您必须触发另一个计数查询。默认情况下，此查询源自您实际触发的查询。</p>
<h5 id="Paging-and-Sorting"><a href="#Paging-and-Sorting" class="headerlink" title="Paging and Sorting"></a>Paging and Sorting</h5><p>​    <code>分页和排序</code></p>
<p>Simple sorting expressions can be defined by using property names. Expressions can be concatenated to collect multiple criterias into one expression.</p>
<p>可以使用属性名称定义简单的排序表达式。可以将表达式连接起来，以将多个条件收集到一个表达式中。</p>
<p>Example 15. Defining sort expressions</p>
<p><strong>例子15.定义排序表达式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sort sort = Sort.by(<span class="string">&quot;firstname&quot;</span>).ascending()</span><br><span class="line">  .and(Sort.by(<span class="string">&quot;lastname&quot;</span>).descending());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>For a more type-safe way of defining sort expressions, start with the type to define the sort expression for and use method references to define the properties to sort on.</p>
</blockquote>
<p>对于定义排序表达式的类型安全性更高的方法，请从该类型开始为定义排序表达式，然后使用方法引用来定义要进行排序的属性。</p>
<p>Example 16. Defining sort expressions using the type-safe API</p>
<p><strong>例子16.使用类型安全的API定义排序表达式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TypedSort&lt;Person&gt; person = Sort.sort(Person.class);</span><br><span class="line"></span><br><span class="line">Sort sort = person.by(Person::getFirstname).ascending()</span><br><span class="line">  .and(person.by(Person::getLastname).descending());</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th><code>TypedSort.by(…)</code> makes use of runtime proxies by typically using CGlib which may interfere with native image compilation when using tools like Graal VM Native.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>TypedSort.by(…)</code> 通常使用CGlib来利用运行时代理，当使用Graal VM Native等工具时，CGlib可能会干扰本机映像的编译。</td>
</tr>
</tbody></table>
<p>If your store implementation supports Querydsl, you can also use the metamodel types generated to define sort expressions:</p>
<p>如果您的存储库实现支持Querydsl，则还可以使用生成的元模型类型来定义排序表达式：</p>
<p>Example 17. Defining sort expressions using the Querydsl API</p>
<p><strong>例子17.使用Querydsl API定义排序表达式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSort sort = QSort.by(QPerson.firstname.asc())</span><br><span class="line">  .and(QSort.by(QPerson.lastname.desc()));</span><br></pre></td></tr></table></figure>

<h4 id="8-4-5-Limiting-Query-Results"><a href="#8-4-5-Limiting-Query-Results" class="headerlink" title="8.4.5. Limiting Query Results"></a>8.4.5. Limiting Query Results</h4><p><code>限制查询结果</code></p>
<blockquote>
<p>The results of query methods can be limited by using the <code>first</code> or <code>top</code> keywords, which can be used interchangeably. An optional numeric value can be appended to <code>top</code> or <code>first</code> to specify the maximum result size to be returned. If the number is left out, a result size of 1 is assumed. The following example shows how to limit the query size:</p>
<p>可以通过使用<code>first</code>or <code>top</code>关键字来限制查询方法的结果，这些关键字可以互换使用。可以将可选的数值附加到<code>top</code>或<code>first</code>指定要返回的最大结果大小。如果省略该数字，则假定结果大小为1。以下示例显示如何限制查询大小：</p>
</blockquote>
<p>Example 18. Limiting the result size of a query with <code>Top</code> and <code>First</code></p>
<p>例子18.用<code>Top</code>和限制查询的结果大小<code>First</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User <span class="title">findFirstByOrderByLastnameAsc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">User <span class="title">findTopByOrderByAgeDesc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">queryFirst10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findTop3ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findFirst10ByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findTop10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The limiting expressions also support the <code>Distinct</code> keyword. Also, for the queries limiting the result set to one instance, wrapping the result into with the <code>Optional</code> keyword is supported.</p>
<p>If pagination or slicing is applied to a limiting query pagination (and the calculation of the number of pages available), it is applied within the limited result.</p>
</blockquote>
<p>限制表达式也支持<code>Distinct</code>关键字。此外，对于将结果集限制为一个实例的查询，<code>Optional</code>支持使用关键字将结果包装到其中。</p>
<p>如果将分页或切片应用于限制查询分页（以及对可用页面数的计算），则会在限制结果内应用分页或切片。</p>
<table>
<thead>
<tr>
<th></th>
<th>Limiting the results in combination with dynamic sorting by using a <code>Sort</code> parameter lets you express query methods for the ‘K’ smallest as well as for the ‘K’ biggest elements.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>通过使用<code>Sort</code>参数来限制结果与动态排序的组合，可以使您针对最小的“ K”元素和最大的“ K”元素表达查询方法。</td>
</tr>
</tbody></table>
<h4 id="8-4-6-Repository-Methods-Returning-Collections-or-Iterables"><a href="#8-4-6-Repository-Methods-Returning-Collections-or-Iterables" class="headerlink" title="8.4.6. Repository Methods Returning Collections or Iterables"></a>8.4.6. Repository Methods Returning Collections or Iterables</h4><p><code>存储库方法返回集合或可迭代对象</code></p>
<blockquote>
<p>Query methods that return multiple results can use standard Java <code>Iterable</code>, <code>List</code>, <code>Set</code>. Beyond that we support returning Spring Data’s <code>Streamable</code>, a custom extension of <code>Iterable</code>, as well as collection types provided by <a target="_blank" rel="noopener" href="https://www.vavr.io/">Vavr</a>.</p>
<p>查询方法，返回多个结果可以使用标准的Java <code>Iterable</code>，<code>List</code>，<code>Set</code>。除此之外，我们还支持返回Spring Data的<code>Streamable</code>自定义扩展<code>Iterable</code>，以及<a target="_blank" rel="noopener" href="https://www.vavr.io/">Vavr</a>提供的集合类型。</p>
</blockquote>
<h5 id="Using-Streamable-as-Query-Method-Return-Type"><a href="#Using-Streamable-as-Query-Method-Return-Type" class="headerlink" title="Using Streamable as Query Method Return Type"></a>Using Streamable as Query Method Return Type</h5><h5 id="使用Streamable作为查询方法返回类型"><a href="#使用Streamable作为查询方法返回类型" class="headerlink" title="使用Streamable作为查询方法返回类型"></a>使用Streamable作为查询方法返回类型</h5><blockquote>
<p><code>Streamable</code> can be used as alternative to <code>Iterable</code> or any collection type. It provides convenience methods to access a non-parallel <code>Stream</code> (missing from <code>Iterable</code>), the ability to directly <code>….filter(…)</code> and <code>….map(…)</code> over the elements and concatenate the <code>Streamable</code> to others:</p>
<p><code>Streamable</code>可以用作替代<code>Iterable</code>或任何集合类型。它提供了便捷的方法来访问非并行项<code>Stream</code>（缺少<code>Iterable</code>），直接<code>….filter(…)</code>和<code>….map(…)</code>覆盖元素并将其串联<code>Streamable</code>到其他元素的能力：</p>
</blockquote>
<p>Example 19. Using Streamable to combine query method results</p>
<p><strong>例子19.使用Streamable合并查询方法结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Streamable&lt;Person&gt; <span class="title">findByFirstnameContaining</span><span class="params">(String firstname)</span></span>;</span><br><span class="line">  <span class="function">Streamable&lt;Person&gt; <span class="title">findByLastnameContaining</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Streamable&lt;Person&gt; result = repository.findByFirstnameContaining(<span class="string">&quot;av&quot;</span>)</span><br><span class="line">  .and(repository.findByLastnameContaining(<span class="string">&quot;ea&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Returning-Custom-Streamable-Wrapper-Types"><a href="#Returning-Custom-Streamable-Wrapper-Types" class="headerlink" title="Returning Custom Streamable Wrapper Types"></a>Returning Custom Streamable Wrapper Types</h5><h5 id="返回自定义流式包装器类型"><a href="#返回自定义流式包装器类型" class="headerlink" title="返回自定义流式包装器类型"></a>返回自定义流式包装器类型</h5><blockquote>
<p>Providing dedicated wrapper types for collections is a commonly used pattern to provide API on a query execution result that returns multiple elements. Usually these types are used by invoking a repository method returning a collection-like type and creating an instance of the wrapper type manually. That additional step can be avoided as Spring Data allows to use these wrapper types as query method return types if they meet the following criterias:</p>
<ol>
<li>The type implements <code>Streamable</code>.</li>
<li>The type exposes either a constructor or a static factory method named <code>of(…)</code> or <code>valueOf(…)</code> taking <code>Streamable</code> as argument.</li>
</ol>
</blockquote>
<p>为集合提供专用的包装器类型是一种常用的模式，用于在返回多个元素的查询执行结果上提供API。通常，这些类型是通过调用存储库方法来返回类似集合的类型并手动创建包装类型的实例来使用的。如果Spring Data允许这些包装器类型满足以下条件，则可以避免使用这些包装器类型作为查询方法返回类型：</p>
<ol>
<li>类型实现<code>Streamable</code>。</li>
<li>该类型公开任何构造函数或静态工厂方法命名<code>of(…)</code>或<code>valueOf(…)</code>以<code>Streamable</code>作为参数。</li>
</ol>
<p>A sample use case looks as follows:</p>
<p>示例用例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123; </span><br><span class="line">  <span class="function">MonetaryAmount <span class="title">getPrice</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgConstructor(staticName = &quot;of&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Products</span> <span class="keyword">implements</span> <span class="title">Streamable</span>&lt;<span class="title">Product</span>&gt; </span>&#123; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Streamable&lt;Product&gt; streamable;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MonetaryAmount <span class="title">getTotal</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> streamable.stream() <span class="comment">//</span></span><br><span class="line">      .map(Priced::getPrice)</span><br><span class="line">      .reduce(Money.of(<span class="number">0</span>), MonetaryAmount::add);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProductRepository</span> <span class="keyword">implements</span> <span class="title">Repository</span>&lt;<span class="title">Product</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Products <span class="title">findAllByDescriptionContaining</span><span class="params">(String text)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>1</th>
<th>A <code>Product</code> entity that exposes API to access the product’s price.</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>A wrapper type for a <code>Streamable&lt;Product&gt;</code> that can be constructed via <code>Products.of(…)</code> (factory method created via the Lombok annotation).</td>
</tr>
<tr>
<td>3</td>
<td>The wrapper type exposes additional API calculating new values on the <code>Streamable&lt;Product&gt;</code>.</td>
</tr>
<tr>
<td>4</td>
<td>That wrapper type can be used as query method return type directly. No need to return <code>Stremable&lt;Product&gt;</code> and manually wrap it in the repository client.</td>
</tr>
</tbody></table>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/652e806707e5436294cbd05becd52904-blog-07.jpg" alt="blog-07"></p>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/2368f004b5cc480ba1c477a9e396f2ba-blog-08.jpg" alt="blog-08"></p>
<table>
<thead>
<tr>
<th>1</th>
<th>一个<code>Product</code>暴露的API来访问产品的价格实体。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><code>Streamable&lt;Product&gt;</code>可以通过构建的包装类型<code>Products.of(…)</code>（通过Lombok批注创建的工厂方法）。</td>
</tr>
<tr>
<td>3</td>
<td>包装器类型会公开其他API，以计算<code>Streamable&lt;Product&gt;</code>上的新值。</td>
</tr>
<tr>
<td>4</td>
<td>该包装器类型可以直接用作查询方法返回类型。无需返回<code>Stremable&lt;Product&gt;</code>并将其手动包装在存储库客户端中。</td>
</tr>
</tbody></table>
<h5 id="Support-for-Vavr-Collections"><a href="#Support-for-Vavr-Collections" class="headerlink" title="Support for Vavr Collections"></a>Support for Vavr Collections</h5><h5 id="支持Vavr"><a href="#支持Vavr" class="headerlink" title="支持Vavr"></a>支持Vavr</h5><p><a target="_blank" rel="noopener" href="https://www.vavr.io/">Vavr</a> is a library to embrace functional programming concepts in Java. It ships with a custom set of collection types that can be used as query method return types.</p>
<p><a target="_blank" rel="noopener" href="https://www.vavr.io/">Vavr</a>是一个包含Java中的函数式编程概念的库。它附带了一组自定义的集和类型，可用作查询方法返回类型。</p>
<table>
<thead>
<tr>
<th align="left">Vavr collection type</th>
<th align="left">Used Vavr implementation type</th>
<th align="left">Valid Java source types</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>io.vavr.collection.Seq</code></td>
<td align="left"><code>io.vavr.collection.List</code></td>
<td align="left"><code>java.util.Iterable</code></td>
</tr>
<tr>
<td align="left"><code>io.vavr.collection.Set</code></td>
<td align="left"><code>io.vavr.collection.LinkedHashSet</code></td>
<td align="left"><code>java.util.Iterable</code></td>
</tr>
<tr>
<td align="left"><code>io.vavr.collection.Map</code></td>
<td align="left"><code>io.vavr.collection.LinkedHashMap</code></td>
<td align="left"><code>java.util.Map</code></td>
</tr>
</tbody></table>
<p>The types in the first column (or subtypes thereof) can be used as quer method return types and will get the types in the second column used as implementation type depending on the Java type of the actual query result (thrid column). Alternatively, <code>Traversable</code> (Vavr the <code>Iterable</code> equivalent) can be declared and we derive the implementation class from the actual return value, i.e. a <code>java.util.List</code> will be turned into a Vavr <code>List</code>/<code>Seq</code>, a <code>java.util.Set</code> becomes a Vavr <code>LinkedHashSet</code>/<code>Set</code> etc.</p>
<p>第一列中的类型（或其子类型）可以用作查询方法返回类型，并将根据实际查询结果的Java类型（第三列）获取第二列中的类型作为实现类型。另外，<code>Traversable</code>（Vavr的<code>Iterable</code>等价物）可以声明，我们得出从实际的返回值的实现类，即<code>java.util.List</code>会变成一个Vavr <code>List</code>/ <code>Seq</code>，一个<code>java.util.Set</code>变成了Vavr <code>LinkedHashSet</code>/ <code>Set</code>等</p>
<h4 id="8-4-7-Null-Handling-of-Repository-Methods"><a href="#8-4-7-Null-Handling-of-Repository-Methods" class="headerlink" title="8.4.7. Null Handling of Repository Methods"></a>8.4.7. Null Handling of Repository Methods</h4><p><code>存储库方法的空处理</code></p>
<blockquote>
<p>As of Spring Data 2.0, repository CRUD methods that return an individual aggregate instance use Java 8’s <code>Optional</code> to indicate the potential absence of a value. Besides that, Spring Data supports returning the following wrapper types on query methods:</p>
<ul>
<li><code>com.google.common.base.Optional</code></li>
<li><code>scala.Option</code></li>
<li><code>io.vavr.control.Option</code></li>
</ul>
<p>Alternatively, query methods can choose not to use a wrapper type at all. The absence of a query result is then indicated by returning <code>null</code>. Repository methods returning collections, collection alternatives, wrappers, and streams are guaranteed never to return <code>null</code> but rather the corresponding empty representation. See “<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repository-query-return-types">Repository query return types</a>” for details.</p>
</blockquote>
<p>从Spring Data 2.0开始，返回单个聚合实例的存储库CRUD方法使用Java 8 <code>Optional</code>表示可能没有值。除此之外，Spring Data支持在查询方法上返回以下包装器类型：</p>
<ul>
<li><code>com.google.common.base.Optional</code></li>
<li><code>scala.Option</code></li>
<li><code>io.vavr.control.Option</code></li>
</ul>
<p>另外，查询方法可以选择根本不使用包装器类型。然后，通过返回表示查询结果不存在<code>null</code>。保证返回集合，集合替代项，包装器和流的存储库方法从不返回<code>null</code>，而是相应的空表示。有关详细信息，请参见“ <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repository-query-return-types">存储库查询返回类型</a> ”。</p>
<h5 id="Nullability-Annotations"><a href="#Nullability-Annotations" class="headerlink" title="Nullability Annotations"></a>Nullability Annotations</h5><h5 id="可空性注释"><a href="#可空性注释" class="headerlink" title="可空性注释"></a>可空性注释</h5><blockquote>
<p>You can express nullability constraints for repository methods by using <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#null-safety">Spring Framework’s nullability annotations</a>. They provide a tooling-friendly approach and opt-in <code>null</code> checks during runtime, as follows:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/lang/NonNullApi.html"><code>@NonNullApi</code></a>: Used on the package level to declare that the default behavior for parameters and return values is to not accept or produce <code>null</code> values.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/lang/NonNull.html"><code>@NonNull</code></a>: Used on a parameter or return value that must not be <code>null</code> (not needed on a parameter and return value where <code>@NonNullApi</code> applies).</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/lang/Nullable.html"><code>@Nullable</code></a>: Used on a parameter or return value that can be <code>null</code>.</li>
</ul>
<p>Spring annotations are meta-annotated with <a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a> annotations (a dormant but widely spread JSR). JSR 305 meta-annotations let tooling vendors such as <a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html">IDEA</a>, <a target="_blank" rel="noopener" href="https://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm">Eclipse</a>, and <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">Kotlin</a> provide null-safety support in a generic way, without having to hard-code support for Spring annotations. To enable runtime checking of nullability constraints for query methods, you need to activate non-nullability on the package level by using Spring’s <code>@NonNullApi</code> in <code>package-info.java</code>, as shown in the following example:</p>
<p>您可以使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#null-safety">Spring Framework的nullability批注</a>来表达存储库方法的nullability约束。它们提供了一种工具友好的方法，并且<code>null</code>在运行时提供了选择加入检查，如下所示：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/lang/NonNullApi.html"><code>@NonNullApi</code></a>：在包级别用于声明参数和返回值的默认行为是不接受或产生<code>null</code>值。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/lang/NonNull.html"><code>@NonNull</code></a>：用于不得包含的参数或返回值<code>null</code> （适用时，不需要参数和返回值<code>@NonNullApi</code>）。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/lang/Nullable.html"><code>@Nullable</code></a>：用于可以为的参数或返回值<code>null</code>。</li>
</ul>
<p>Spring注释使用<a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>注释（更新少但分布广泛的JSR）进行元注释。JSR 305元注释使工具供应商（例如<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html">IDEA</a>，<a target="_blank" rel="noopener" href="https://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm">Eclipse</a>和<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">Kotlin）</a>以通用方式提供了空安全支持，而无需对Spring注释进行硬编码支持。为了对查询方法的可空性约束进行运行时检查，您需要在<code>package-info.java</code>使用Spring的<code>@NonNullApi</code>进行包级别激活非空性，如以下示例所示：</p>
</blockquote>
<p>Example 20. Declaring Non-nullability in <code>package-info.java</code></p>
<p>例子20.声明非空性 <code>package-info.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.lang.NonNullApi</span><br><span class="line"><span class="keyword">package</span> com.acme;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Once non-null defaulting is in place, repository query method invocations get validated at runtime for nullability constraints. If a query execution result violates the defined constraint, an exception is thrown. This happens when the method would return <code>null</code> but is declared as non-nullable (the default with the annotation defined on the package the repository resides in). If you want to opt-in to nullable results again, selectively use <code>@Nullable</code> on individual methods. Using the result wrapper types mentioned at the start of this section continues to work as expected: An empty result is translated into the value that represents absence.</p>
<p>The following example shows a number of the techniques just described:</p>
</blockquote>
<p>一旦设置了非null的默认值，就可以在运行时验证存储库查询方法的调用是否具有可空性约束。如果查询执行结果违反了定义的约束，则会引发异常。当方法返回<code>null</code>但被声明为不可为空时（在存储库所在的包中定义了注释的默认值），将发生这种情况。如果您想再次选择接受可为空的结果，请选择性地<code>@Nullable</code>在各个方法上使用。使用本节开头提到的结果包装器类型可以按预期继续工作：将空结果转换为表示缺省的值。</p>
<p>以下示例显示了刚才描述的许多技术：</p>
<p>Example 21. Using different nullability constraints</p>
<p><strong>例子21.使用不同的可空性约束</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.acme;                                                       </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">User <span class="title">getByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>;                    </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(<span class="meta">@Nullable</span> EmailAddress emailAdress)</span></span>;          </span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;User&gt; <span class="title">findOptionalByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>The repository resides in a package (or sub-package) for which we have defined non-null behavior.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Throws an <code>EmptyResultDataAccessException</code> when the query executed does not produce a result. Throws an <code>IllegalArgumentException</code> when the <code>emailAddress</code> handed to the method is <code>null</code>.</td>
</tr>
<tr>
<td></td>
<td>Returns <code>null</code> when the query executed does not produce a result. Also accepts <code>null</code> as the value for <code>emailAddress</code>.</td>
</tr>
<tr>
<td></td>
<td>Returns <code>Optional.empty()</code> when the query executed does not produce a result. Throws an <code>IllegalArgumentException</code> when the <code>emailAddress</code> handed to the method is <code>null</code>.</td>
</tr>
</tbody></table>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/cce573ac08374c548fed98abfc259358-blog-09.jpg" alt="blog-09"></p>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/53817dd7328b4b86b946647232afbd42-blog-12.jpg" alt="blog-12"></p>
<table>
<thead>
<tr>
<th>1</th>
<th>存储库位于我们已为其定义非空行为的包（或子包）中。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><code>EmptyResultDataAccessException</code>当执行查询不产生结果时抛出。传递给方法<code>IllegalArgumentException</code>时抛出。<code>emailAddress``null</code></td>
</tr>
<tr>
<td>3</td>
<td><code>null</code>当执行的查询不产生结果时返回。也接受<code>null</code>作为的值<code>emailAddress</code>。</td>
</tr>
<tr>
<td>4</td>
<td><code>Optional.empty()</code>当执行的查询不产生结果时返回。传递给方法<code>IllegalArgumentException</code>时抛出。<code>emailAddress``null</code></td>
</tr>
</tbody></table>
<h5 id="Nullability-in-Kotlin-based-Repositories"><a href="#Nullability-in-Kotlin-based-Repositories" class="headerlink" title="Nullability in Kotlin-based Repositories"></a>Nullability in Kotlin-based Repositories</h5><h5 id="基于Kotlin的存储库中的可空性"><a href="#基于Kotlin的存储库中的可空性" class="headerlink" title="基于Kotlin的存储库中的可空性"></a>基于Kotlin的存储库中的可空性</h5><blockquote>
<p>Kotlin has the definition of <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/null-safety.html">nullability constraints</a> baked into the language. Kotlin code compiles to bytecode, which does not express nullability constraints through method signatures but rather through compiled-in metadata. Make sure to include the <code>kotlin-reflect</code> JAR in your project to enable introspection of Kotlin’s nullability constraints. Spring Data repositories use the language mechanism to define those constraints to apply the same runtime checks, as follows:</p>
</blockquote>
<p>Kotlin定义了语言中包含的可<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/null-safety.html">空性约束</a>。Kotlin代码编译为字节码，该字节码不通过方法签名来表达可空性约束，而是通过内置的元数据来表达。确保<code>kotlin-reflect</code>在您的项目中包含JAR，以对Kotlin的可空性约束进行自省。Spring Data存储库使用语言机制来定义这些约束以应用相同的运行时检查，如下所示：</p>
<p>Example 22. Using nullability constraints on Kotlin repositories</p>
<p><strong>例子22.在Kotlin存储库上使用可空性约束</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> : <span class="type">Repository</span>&lt;<span class="type">User, String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findByUsername</span><span class="params">(username: <span class="type">String</span>)</span></span>: User     </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findByFirstname</span><span class="params">(firstname: <span class="type">String</span>?)</span></span>: User? </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>1</th>
<th>The method defines both the parameter and the result as non-nullable (the Kotlin default). The Kotlin compiler rejects method invocations that pass <code>null</code> to the method. If the query execution yields an empty result, an <code>EmptyResultDataAccessException</code> is thrown.</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>This method accepts <code>null</code> for the <code>firstname</code> parameter and returns <code>null</code> if the query execution does not produce a result.</td>
</tr>
</tbody></table>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/eb0065a2dcd84e0aaae6a6083bd02926-blog-10.jpg" alt="blog-10"></p>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/57abb12afe4e4174876128165a36cba6-blog-11.jpg" alt="blog-11"></p>
<table>
<thead>
<tr>
<th>1</th>
<th>该方法将参数和结果都定义为不可为空（Kotlin默认值）。Kotlin编译器拒绝传递<code>null</code>给该方法的方法调用。如果查询执行产生空结果，则引发一个<code>EmptyResultDataAccessException</code>。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>该方法接受<code>null</code>的<code>firstname</code>参数，如果查询执行不产生结果，会返回<code>null</code>。</td>
</tr>
</tbody></table>
<h4 id="8-4-8-Streaming-query-results"><a href="#8-4-8-Streaming-query-results" class="headerlink" title="8.4.8. Streaming query results"></a>8.4.8. Streaming query results</h4><p><code>流查询结果</code></p>
<blockquote>
<p>The results of query methods can be processed incrementally by using a Java 8 <code>Stream&lt;T&gt;</code> as return type. Instead of wrapping the query results in a <code>Stream</code> data store-specific methods are used to perform the streaming, as shown in the following example:</p>
<p>通过使用Java 8 <code>Stream&lt;T&gt;</code>作为返回类型，可以逐步处理查询方法的结果。<code>Stream</code>并非将查询结果包装在数据存储区中，而是使用特定于方法的方法来执行流传输，如以下示例所示：</p>
</blockquote>
<p>Example 23. Stream the result of a query with Java 8 <code>Stream&lt;T&gt;</code></p>
<p>例子23.用Java 8流式查询的结果 <code>Stream&lt;T&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;select u from User u&quot;)</span></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">findAllByCustomQueryAndStream</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">readAllByFirstnameNotNull</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(&quot;select u from User u&quot;)</span></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">streamAllPaged</span><span class="params">(Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>A <code>Stream</code> potentially wraps underlying data store-specific resources and must, therefore, be closed after usage. You can either manually close the <code>Stream</code> by using the <code>close()</code> method or by using a Java 7 <code>try-with-resources</code> block, as shown in the following example:</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>一个<code>Stream</code>封装底层数据存储专用的资源，因此必须在使用之后被关闭。您可以<code>Stream</code>使用<code>close()</code>方法或使用Java 7 <code>try-with-resources</code>块来手动关闭，如以下示例所示：</td>
</tr>
</tbody></table>
<p>Example 24. Working with a <code>Stream&lt;T&gt;</code> result in a try-with-resources block</p>
<p>例子24. <code>Stream&lt;T&gt;</code>在try-with-resources块中处理结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) &#123;</span><br><span class="line">  stream.forEach(…);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>Not all Spring Data modules currently support <code>Stream&lt;T&gt;</code> as a return type.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>当前，并非所有的Spring Data模块都支持<code>Stream&lt;T&gt;</code>作为返回类型。</td>
</tr>
</tbody></table>
<h4 id="8-4-9-Async-query-results"><a href="#8-4-9-Async-query-results" class="headerlink" title="8.4.9. Async query results"></a>8.4.9. Async query results</h4><p><code>异步查询结果</code></p>
<blockquote>
<p>Repository queries can be run asynchronously by using <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/integration.html#scheduling">Spring’s asynchronous method execution capability</a>. This means the method returns immediately upon invocation while the actual query execution occurs in a task that has been submitted to a Spring <code>TaskExecutor</code>. Asynchronous query execution is different from reactive query execution and should not be mixed. Refer to store-specific documentation for more details on reactive support. The following example shows a number of asynchronous queries:</p>
<p>仓库查询可以通过使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/integration.html#scheduling">Spring的异步方法执行功能异步</a>运行。这意味着该方法在调用时立即返回，而实际查询执行发生在已提交给Spring的任务中<code>TaskExecutor</code>。异步查询执行与反应式查询执行不同，因此不应混为一谈。有关响应式支持的更多详细信息，请参阅存储库特定的文档。以下示例显示了多种异步查询：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">Future&lt;User&gt; <span class="title">findByFirstname</span><span class="params">(String firstname)</span></span>;               </span><br><span class="line"></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">CompletableFuture&lt;User&gt; <span class="title">findOneByFirstname</span><span class="params">(String firstname)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">ListenableFuture&lt;User&gt; <span class="title">findOneByLastname</span><span class="params">(String lastname)</span></span>;    </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>Use <code>java.util.concurrent.Future</code> as the return type.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Use a Java 8 <code>java.util.concurrent.CompletableFuture</code> as the return type.</td>
</tr>
<tr>
<td></td>
<td>Use a <code>org.springframework.util.concurrent.ListenableFuture</code> as the return type.</td>
</tr>
</tbody></table>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/80b1faeecf964d6c901bbb1f1613916a-blog-13.jpg" alt="blog-13"></p>
<ol>
<li>使用<code>java.util.concurrent.Future</code>作为返回类型。</li>
<li>使用Java 8 <code>java.util.concurrent.CompletableFuture</code>作为返回类型。</li>
<li>使用a <code>org.springframework.util.concurrent.ListenableFuture</code>作为返回类型。</li>
</ol>
<h3 id="8-5-Creating-Repository-Instances"><a href="#8-5-Creating-Repository-Instances" class="headerlink" title="8.5. Creating Repository Instances"></a>8.5. Creating Repository Instances</h3><p><code>创建存储库实例</code></p>
<blockquote>
<p>In this section, you create instances and bean definitions for the defined repository interfaces. One way to do so is by using the Spring namespace that is shipped with each Spring Data module that supports the repository mechanism, although we generally recommend using Java configuration.</p>
<p>在本部分中，将为已定义的存储库接口创建实例和Bean定义。一种方法是使用支持存储库机制的每个Spring Data模块随附的Spring名称空间，尽管我们通常建议使用Java配置。</p>
</blockquote>
<h4 id="8-5-1-XML-configuration"><a href="#8-5-1-XML-configuration" class="headerlink" title="8.5.1. XML configuration"></a>8.5.1. XML configuration</h4><blockquote>
<p>Each Spring Data module includes a <code>repositories</code> element that lets you define a base package that Spring scans for you, as shown in the following example:</p>
</blockquote>
<p>每个Spring Data模块都包含一个<code>repositories</code>元素，可让您定义Spring会为您扫描的基本软件包，如以下示例所示：</p>
<p>Example 25. Enabling Spring Data repositories via XML</p>
<p><strong>例子25.通过XML启用Spring数据仓库</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:beans</span> <span class="attr">xmlns:beans</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/data/jpa&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/jpa</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repositories&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>In the preceding example, Spring is instructed to scan <code>com.acme.repositories</code> and all its sub-packages for interfaces extending <code>Repository</code> or one of its sub-interfaces. For each interface found, the infrastructure registers the persistence technology-specific <code>FactoryBean</code> to create the appropriate proxies that handle invocations of the query methods. Each bean is registered under a bean name that is derived from the interface name, so an interface of <code>UserRepository</code> would be registered under <code>userRepository</code>. The <code>base-package</code> attribute allows wildcards so that you can define a pattern of scanned packages.</p>
<p>在前面的示例中，指示Spring扫描<code>com.acme.repositories</code>及其所有子包以查找扩展的接口<code>Repository</code>或其中一个子接口。对于找到的每个接口，基础结构都会注册特定<code>FactoryBean</code>于持久性技术的内容，以创建处理查询方法调用的适当代理。每个Bean都使用从接口名称派生的Bean名称<code>UserRepository</code>进行注册，因此的接口将注册在<code>userRepository</code>之下。该<code>base-package</code>属性允许使用通配符，以便您可以定义扫描程序包的模式。</p>
</blockquote>
<h5 id="Using-filters"><a href="#Using-filters" class="headerlink" title="Using filters"></a>Using filters</h5><h5 id="使用过滤器"><a href="#使用过滤器" class="headerlink" title="使用过滤器"></a>使用过滤器</h5><blockquote>
<p>By default, the infrastructure picks up every interface extending the persistence technology-specific <code>Repository</code> sub-interface located under the configured base package and creates a bean instance for it. However, you might want more fine-grained control over which interfaces have bean instances created for them. To do so, use <code>&lt;include-filter /&gt;</code> and <code>&lt;exclude-filter /&gt;</code> elements inside the <code>&lt;repositories /&gt;</code> element. The semantics are exactly equivalent to the elements in Spring’s context namespace. For details, see the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans-scanning-filters">Spring reference documentation</a> for these elements.</p>
<p>默认情况下，基础结构会拾取扩展<code>Repository</code>位于配置的基本程序包下的特定于持久性技术的子接口的每个接口，并为其创建一个bean实例。但是，您可能希望更精细地控制哪些接口具有为其创建的Bean实例。为此，请在元素<code>&lt;repositories /&gt;</code>内部使用<code>&lt;include-filter /&gt;</code>和<code>&lt;exclude-filter /&gt;</code>元素。语义完全等同于Spring的上下文命名空间中的元素。有关详细信息，请参见这些元素的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans-scanning-filters">Spring参考文档</a>。</p>
</blockquote>
<p>For example, to exclude certain interfaces from instantiation as repository beans, you could use the following configuration:</p>
<p>例如，要将某些接口从实例中排除为存储库Bean，可以使用以下配置：</p>
<p>Example 26. Using exclude-filter element</p>
<p><strong>例子26.使用exclude-filter元素</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repositories&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;regex&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;.*SomeRepository&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>The preceding example excludes all interfaces ending in <code>SomeRepository</code> from being instantiated.</p>
<p>前面的示例排除了所有以<code>SomeRepository</code>结尾的接口。</p>
<h4 id="8-5-2-JavaConfig"><a href="#8-5-2-JavaConfig" class="headerlink" title="8.5.2. JavaConfig"></a>8.5.2. JavaConfig</h4><blockquote>
<p>The repository infrastructure can also be triggered by using a store-specific <code>@Enable$&#123;store&#125;Repositories</code> annotation on a JavaConfig class. For an introduction into Java-based configuration of the Spring container, see <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans-java">JavaConfig in the Spring reference documentation</a>.</p>
<p>还可以通过<code>@Enable$&#123;store&#125;Repositories</code>在JavaConfig类上使用存储库特定的注释来触发存储库基础结构。有关Spring容器基于Java的配置的介绍，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans-java">Spring参考文档中的JavaConfig</a>。</p>
</blockquote>
<p>A sample configuration to enable Spring Data repositories resembles the following:</p>
<p>启用Spring数据存储库的示例配置类似于以下内容：</p>
<p>Example 27. Sample annotation based repository configuration</p>
<p><strong>例子27.基于样本注释的存储库配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(&quot;com.acme.repositories&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function">EntityManagerFactory <span class="title">entityManagerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>The preceding example uses the JPA-specific annotation, which you would change according to the store module you actually use. The same applies to the definition of the <code>EntityManagerFactory</code> bean. See the sections covering the store-specific configuration.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>前面的示例使用特定于JPA的注释，您将根据实际使用的存储库模块对其进行更改。<code>EntityManagerFactory</code>Bean 的定义也是如此。请参阅有关存储库特定配置的部分。</td>
</tr>
</tbody></table>
<h4 id="8-5-3-Standalone-usage"><a href="#8-5-3-Standalone-usage" class="headerlink" title="8.5.3. Standalone usage"></a>8.5.3. Standalone usage</h4><p>​    <code>独立使用</code></p>
<blockquote>
<p>You can also use the repository infrastructure outside of a Spring container — for example, in CDI environments. You still need some Spring libraries in your classpath, but, generally, you can set up repositories programmatically as well. The Spring Data modules that provide repository support ship a persistence technology-specific <code>RepositoryFactory</code> that you can use as follows:</p>
<p>您还可以在Spring容器之外使用存储库基础结构，例如在CDI环境中。您的类路径中仍然需要一些Spring库，但是，通常，您也可以通过编程方式设置存储库。提供存储库支持的Spring Data模块附带了特定于<code>RepositoryFactory</code>持久性技术的代码，您可以按以下方式使用它：</p>
</blockquote>
<p>Example 28. Standalone usage of repository factory</p>
<p><strong>例子28.仓库工厂的独立使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RepositoryFactorySupport factory = … <span class="comment">// Instantiate factory here</span></span><br><span class="line">UserRepository repository = factory.getRepository(UserRepository.class);</span><br></pre></td></tr></table></figure>

<h3 id="8-6-Custom-Implementations-for-Spring-Data-Repositories"><a href="#8-6-Custom-Implementations-for-Spring-Data-Repositories" class="headerlink" title="8.6. Custom Implementations for Spring Data Repositories"></a>8.6. Custom Implementations for Spring Data Repositories</h3><p><code>Spring数据存储库的定制实现</code></p>
<blockquote>
<p>This section covers repository customization and how fragments form a composite repository.</p>
<p>When a query method requires a different behavior or cannot be implemented by query derivation, then it is necessary to provide a custom implementation. Spring Data repositories let you provide custom repository code and integrate it with generic CRUD abstraction and query method functionality.</p>
</blockquote>
<p>本节介绍存储库定制以及片段如何形成复合存储库。</p>
<p>当查询方法需要不同的行为或无法通过查询派生实现时，则有必要提供自定义实现。Spring Data存储库使您可以提供自定义存储库代码，并将其与通用CRUD抽象和查询方法功能集成。</p>
<h4 id="8-6-1-Customizing-Individual-Repositories"><a href="#8-6-1-Customizing-Individual-Repositories" class="headerlink" title="8.6.1. Customizing Individual Repositories"></a>8.6.1. Customizing Individual Repositories</h4><h4 id="自定义单个存储库"><a href="#自定义单个存储库" class="headerlink" title="自定义单个存储库"></a>自定义单个存储库</h4><blockquote>
<p>To enrich a repository with custom functionality, you must first define a fragment interface and an implementation for the custom functionality, as shown in the following example:</p>
</blockquote>
<p>要使用自定义功能丰富存储库，必须首先定义片段接口和自定义功能的实现，如以下示例所示：</p>
<p>Example 29. Interface for custom repository functionality</p>
<p><strong>例子29.定制存储库功能的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">someCustomMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Example 30. Implementation of custom repository functionality</p>
<p><strong>例子30.定制存储库功能的实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedUserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someCustomMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>The most important part of the class name that corresponds to the fragment interface is the <code>Impl</code> postfix.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>类名中与片段接口相对应的最重要部分是<code>Impl</code>后缀。</td>
</tr>
</tbody></table>
<p>The implementation itself does not depend on Spring Data and can be a regular Spring bean. Consequently, you can use standard dependency injection behavior to inject references to other beans (such as a <code>JdbcTemplate</code>), take part in aspects, and so on.</p>
<p>实现本身不依赖于Spring Data，可以是常规的Spring bean。因此，您可以使用标准的依赖项注入行为来注入对其他bean（例如<code>JdbcTemplate</code>）的引用，参与各个方面，等等。</p>
<p>Then you can let your repository interface extend the fragment interface, as shown in the following example:</p>
<p>然后，可以让您的存储库接口扩展片段接口，如以下示例所示：</p>
<p>Example 31. Changes to your repository interface</p>
<p><strong>示例31.对您的存储库接口的更改</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Declare query methods here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Extending the fragment interface with your repository interface combines the CRUD and custom functionality and makes it available to clients.</p>
<p>Spring Data repositories are implemented by using fragments that form a repository composition. Fragments are the base repository, functional aspects (such as <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#core.extensions.querydsl">QueryDsl</a>), and custom interfaces along with their implementation. Each time you add an interface to your repository interface, you enhance the composition by adding a fragment. The base repository and repository aspect implementations are provided by each Spring Data module.</p>
<p>The following example shows custom interfaces and their implementations:</p>
</blockquote>
<p>将片段接口扩展为您的存储库接口，将CRUD和自定义功能结合在一起，并使它可用于客户端。</p>
<p>Spring Data存储库是通过使用构成存储库组成的片段来实现的。片段是基础存储库，功能方面（例如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#core.extensions.querydsl">QueryDsl</a>）以及自定义接口及其实现。每次向存储库接口添加接口时，都通过添加片段来增强组合。每个Spring Data模块都提供了基础存储库和存储库方面的实现。</p>
<p>以下示例显示了自定义接口及其实现：</p>
<p>Example 32. Fragments with their implementations</p>
<p><strong>例子32.片段及其实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HumanRepository</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">someHumanMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumanRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">HumanRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someHumanMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ContactRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">someContactMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">User <span class="title">anotherContactMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">ContactRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someContactMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">anotherContactMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The following example shows the interface for a custom repository that extends <code>CrudRepository</code>:</p>
<p>以下示例显示了扩展的自定义存储库的接口<code>CrudRepository</code>：</p>
<p>Example 33. Changes to your repository interface</p>
<p><strong>例子33.对您的存储库接口的更改</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">HumanRepository</span>, <span class="title">ContactRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Declare query methods here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Repositories may be composed of multiple custom implementations that are imported in the order of their declaration. Custom implementations have a higher priority than the base implementation and repository aspects. This ordering lets you override base repository and aspect methods and resolves ambiguity if two fragments contribute the same method signature. Repository fragments are not limited to use in a single repository interface. Multiple repositories may use a fragment interface, letting you reuse customizations across different repositories.</p>
</blockquote>
<blockquote>
<p>The following example shows a repository fragment and its implementation:</p>
</blockquote>
<p>存储库可能由多个自定义实现组成，这些自定义实现按其声明顺序导入。定制实现比基础实现和存储库方面的优先级更高。通过此排序，可以覆盖基本存储库和方面方法，并在两个片段贡献相同方法签名的情况下解决歧义。存储库片段不限于在单个存储库接口中使用。多个存储库可以使用片段接口，使您可以跨不同的存储库重用自定义项。</p>
<p>以下示例显示了存储库片段及其实现：</p>
<p>Example 34. Fragments overriding <code>save(…)</code></p>
<p>例子34.片段覆盖 <code>save(…)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomizedSave</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedSaveImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CustomizedSave</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The following example shows a repository that uses the preceding repository fragment:</p>
<p>以下示例显示了使用上述存储库片段的存储库：</p>
<p>Example 35. Customized repository interfaces</p>
<p><strong>例子35.定制的存储库接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">CustomizedSave</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt;, <span class="title">CustomizedSave</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h5><blockquote>
<p>If you use namespace configuration, the repository infrastructure tries to autodetect custom implementation fragments by scanning for classes below the package in which it found a repository. These classes need to follow the naming convention of appending the namespace element’s <code>repository-impl-postfix</code> attribute to the fragment interface name. This postfix defaults to <code>Impl</code>. The following example shows a repository that uses the default postfix and a repository that sets a custom value for the postfix:</p>
</blockquote>
<p>如果使用命名空间配置，则存储库基础结构会尝试通过扫描发现存储库的包下方的类来自动检测自定义实现片段。这些类需要遵循将命名空间元素的<code>repository-impl-postfix</code>属性附加到片段接口名称的命名约定。此后缀默认为<code>Impl</code>。以下示例显示了使用默认后缀的存储库和为后缀设置自定义值的存储库：</p>
<p>Example 36. Configuration example</p>
<p><strong>例子36.配置例子</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repository&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repository&quot;</span> <span class="attr">repository-impl-postfix</span>=<span class="string">&quot;MyPostfix&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The first configuration in the preceding example tries to look up a class called <code>com.acme.repository.CustomizedUserRepositoryImpl</code> to act as a custom repository implementation. The second example tries to lookup <code>com.acme.repository.CustomizedUserRepositoryMyPostfix</code>.</p>
<p>上一个示例中的第一个配置试图查找一个称为<code>com.acme.repository.CustomizedUserRepositoryImpl</code>自定义存储库实现的类。第二个示例尝试查找<code>com.acme.repository.CustomizedUserRepositoryMyPostfix</code>。</p>
</blockquote>
<h6 id="Resolution-of-Ambiguity"><a href="#Resolution-of-Ambiguity" class="headerlink" title="Resolution of Ambiguity"></a>Resolution of Ambiguity</h6><p><strong>解决歧义</strong></p>
<blockquote>
<p>If multiple implementations with matching class names are found in different packages, Spring Data uses the bean names to identify which one to use.</p>
<p>Given the following two custom implementations for the <code>CustomizedUserRepository</code> shown earlier, the first implementation is used. Its bean name is <code>customizedUserRepositoryImpl</code>, which matches that of the fragment interface (<code>CustomizedUserRepository</code>) plus the postfix <code>Impl</code>.</p>
</blockquote>
<p>如果在不同的包中找到具有匹配类名的多个实现，Spring Data将使用Bean名称来标识要使用的那个。</p>
<p>给定<code>CustomizedUserRepository</code>前面显示的以下两个自定义实现，将使用第一个实现。它的bean名称是<code>customizedUserRepositoryImpl</code>，与片段接口（<code>CustomizedUserRepository</code>）和后缀的名称匹配<code>Impl</code>。</p>
<p>Example 37. Resolution of amibiguous implementations</p>
<p><strong>例子37.歧义实现的解决</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.acme.impl.one;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedUserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Your custom implementation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.acme.impl.two;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;specialCustomImpl&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedUserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Your custom implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>If you annotate the <code>UserRepository</code> interface with <code>@Component(&quot;specialCustom&quot;)</code>, the bean name plus <code>Impl</code> then matches the one defined for the repository implementation in <code>com.acme.impl.two</code>, and it is used instead of the first one.</p>
<p>如果您使用注释<code>UserRepository</code>接口<code>@Component(&quot;specialCustom&quot;)</code>，则Bean名称plus <code>Impl</code>将匹配存储库实现定义的名称相同的<code>com.acme.impl.two</code>，并且将使用它代替第一个。</p>
</blockquote>
<h6 id="Manual-Wiring"><a href="#Manual-Wiring" class="headerlink" title="Manual Wiring"></a>Manual Wiring</h6><p><strong>手动编写</strong></p>
<blockquote>
<p>If your custom implementation uses annotation-based configuration and autowiring only, the preceding approach shown works well, because it is treated as any other Spring bean. If your implementation fragment bean needs special wiring, you can declare the bean and name it according to the conventions described in the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.single-repository-behaviour.ambiguity">preceding section</a>. The infrastructure then refers to the manually defined bean definition by name instead of creating one itself. The following example shows how to manually wire a custom implementation:</p>
<p>如果您的自定义实现仅使用基于注释的配置和自动装配，则上述显示的方法可以很好地工作，因为它被视为其他任何Spring bean。如果实现片段bean需要特殊的编写，则可以声明bean并根据上<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.single-repository-behaviour.ambiguity">一节中</a>描述的约定对其进行命名。然后，基础结构通过名称引用手动定义的bean定义，而不是自己创建一个。以下示例显示如何手动编写自定义实现：</p>
</blockquote>
<p>Example 38. Manual wiring of custom implementations</p>
<p><strong>例子38.手工编写定制实现</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repository&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">id</span>=<span class="string">&quot;userRepositoryImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;…&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- further configuration --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="8-6-2-Customize-the-Base-Repository"><a href="#8-6-2-Customize-the-Base-Repository" class="headerlink" title="8.6.2. Customize the Base Repository"></a>8.6.2. Customize the Base Repository</h4><p><code>自定义基础存储库</code></p>
<p>The approach described in the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.manual-wiring">preceding section</a> requires customization of each repository interfaces when you want to customize the base repository behavior so that all repositories are affected. To instead change behavior for all repositories, you can create an implementation that extends the persistence technology-specific repository base class. This class then acts as a custom base class for the repository proxies, as shown in the following example:</p>
<p>Example 39. Custom repository base class</p>
<p>当您要自定义基本存储库行为以使所有存储库受到影响时，上<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.manual-wiring">一节中</a>描述的方法要求自定义每个存储库接口。要改为更改所有存储库的行为，您可以创建一个实现，以扩展特定于持久性技术的存储库基类。然后，该类充当存储库代理的自定义基类，如以下示例所示：</p>
<p><strong>例子39.定制存储库基类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRepositoryImpl</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">  MyRepositoryImpl(JpaEntityInformation entityInformation,</span><br><span class="line">                          EntityManager entityManager) &#123;</span><br><span class="line">    <span class="keyword">super</span>(entityInformation, entityManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep the EntityManager around to used from the newly introduced methods.</span></span><br><span class="line">    <span class="keyword">this</span>.entityManager = entityManager;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation goes here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> The class needs to have a constructor of the super class which the store-specific repository factory implementation uses. If the repository base class has multiple constructors, override the one taking an <code>EntityInformation</code> plus a store specific infrastructure object (such as an <code>EntityManager</code> or a template class).</p>
<p> 该类需要具有特定于存储库的存储库工厂实现使用的超类的构造函数。如果存储库基类具有多个构造函数，请覆盖一个构造函数，<code>EntityInformation</code>再加上一个存储库特定的基础结构对象（例如<code>EntityManager</code>或模板类）。</p>
</blockquote>
<blockquote>
<p>The final step is to make the Spring Data infrastructure aware of the customized repository base class. In Java configuration, you can do so by using the <code>repositoryBaseClass</code> attribute of the <code>@Enable$&#123;store&#125;Repositories</code> annotation, as shown in the following example:</p>
<p>最后一步是使Spring Data基础结构了解定制的存储库基类。在Java配置中，可以通过使用批注<code>@Enable$&#123;store&#125;Repositories</code>的<code>repositoryBaseClass</code>属性来执行此操作，如以下示例所示：</p>
</blockquote>
<p>Example 40. Configuring a custom repository base class using JavaConfig</p>
<p><strong>例子40.使用JavaConfig配置一个定制的存储库基类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>A corresponding attribute is available in the XML namespace, as shown in the following example:</p>
<p>XML命名空间中提供了相应的属性，如以下示例所示：</p>
<p>Example 41. Configuring a custom repository base class using XML</p>
<p><strong>例子41.使用XML配置一个定制的存储库基类</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repository&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">base-class</span>=<span class="string">&quot;….MyRepositoryImpl&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-7-Publishing-Events-from-Aggregate-Roots"><a href="#8-7-Publishing-Events-from-Aggregate-Roots" class="headerlink" title="8.7. Publishing Events from Aggregate Roots"></a>8.7. Publishing Events from Aggregate Roots</h3><p><code>从汇总根发布事件</code></p>
<blockquote>
<p>Entities managed by repositories are aggregate roots. In a Domain-Driven Design application, these aggregate roots usually publish domain events. Spring Data provides an annotation called <code>@DomainEvents</code> that you can use on a method of your aggregate root to make that publication as easy as possible, as shown in the following example:</p>
<p>由存储库管理的实体是聚合根。在域驱动的设计应用程序中，这些聚合根通常发布域事件。Spring Data提供了一个称为<code>@DomainEvents</code>的注释，您可以在聚合根的方法上使用该注释，以使该发布尽可能容易，如以下示例所示：</p>
</blockquote>
<p>Example 42. Exposing domain events from an aggregate root</p>
<p><strong>例子42.从聚合根公开域事件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnAggregateRoot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DomainEvents</span> </span><br><span class="line">    <span class="function">Collection&lt;Object&gt; <span class="title">domainEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// … return events you want to get published here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterDomainEventPublication</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callbackMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// … potentially clean up domain events list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>The method using <code>@DomainEvents</code> can return either a single event instance or a collection of events. It must not take any arguments.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>After all events have been published, we have a method annotated with <code>@AfterDomainEventPublication</code>. It can be used to potentially clean the list of events to be published (among other uses).</td>
</tr>
</tbody></table>
<p>The methods are called every time one of a Spring Data repository’s <code>save(…)</code> methods is called.</p>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/9a59c9c068eb49ec9e1fe520808566ce-blog-14.jpg" alt="blog-14"></p>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/2580af7d82554d31b9d02bc254ca4b56-blog-15.jpg" alt="blog-15"></p>
<table>
<thead>
<tr>
<th>1</th>
<th>使用的方法<code>@DomainEvents</code>可以返回单个事件实例或事件集合。它不能接受任何参数。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>在发布所有事件之后，我们将使用注释方法<code>@AfterDomainEventPublication</code>。它可以用来潜在地清除要发布的事件列表（以及其他用途）。</td>
</tr>
</tbody></table>
<p>The methods are called every time one of a Spring Data repository’s <code>save(…)</code> methods is called.</p>
<p>每次调用Spring Data存储库中的<code>save(…)</code>一种方法时，就会调用这些方法。</p>
<h3 id="8-8-Spring-Data-Extensions"><a href="#8-8-Spring-Data-Extensions" class="headerlink" title="8.8. Spring Data Extensions"></a>8.8. Spring Data Extensions</h3><p><code>Spring数据扩展</code></p>
<blockquote>
<p>This section documents a set of Spring Data extensions that enable Spring Data usage in a variety of contexts. Currently, most of the integration is targeted towards Spring MVC.</p>
<p>本节记录了一组Spring Data扩展，这些扩展允许在各种上下文中使用Spring Data。当前，大多数集成都针对Spring MVC。</p>
</blockquote>
<h4 id="8-8-1-Querydsl-Extension"><a href="#8-8-1-Querydsl-Extension" class="headerlink" title="8.8.1. Querydsl Extension"></a>8.8.1. Querydsl Extension</h4><p><code>Querydsl扩展</code></p>
<p><a target="_blank" rel="noopener" href="http://www.querydsl.com/">Querydsl</a> is a framework that enables the construction of statically typed SQL-like queries through its fluent API.</p>
<p><a target="_blank" rel="noopener" href="http://www.querydsl.com/">Querydsl</a>是一个框架，可通过其流畅的API来构造静态类型的类似SQL的查询。</p>
<p>Several Spring Data modules offer integration with Querydsl through <code>QuerydslPredicateExecutor</code>, as shown in the following example:</p>
<p>几个Spring Data模块通过<code>QuerydslPredicateExecutor</code>提供与Querydsl的集成，如以下示例所示：</p>
<p>Example 43. QuerydslPredicateExecutor interface</p>
<p><strong>例子43. QuerydslPredicateExecutor接口</strong></p>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/aaa500ddc926434d92d5ea944f855f34-blog-16.jpg" alt="blog-16"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuerydslPredicateExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(Predicate predicate)</span></span>;  </span><br><span class="line"></span><br><span class="line">  <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Predicate predicate)</span></span>;   </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">(Predicate predicate)</span></span>;            </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(Predicate predicate)</span></span>;        </span><br><span class="line"></span><br><span class="line">  <span class="comment">// … more functionality omitted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>Finds and returns a single entity matching the <code>Predicate</code>.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Finds and returns all entities matching the <code>Predicate</code>.</td>
</tr>
<tr>
<td></td>
<td>Returns the number of entities matching the <code>Predicate</code>.</td>
</tr>
<tr>
<td></td>
<td>Returns whether an entity that matches the <code>Predicate</code> exists.</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>1</th>
<th>查找并返回与匹配的单个实体<code>Predicate</code>。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>查找并返回与匹配的所有实体<code>Predicate</code>。</td>
</tr>
<tr>
<td>3</td>
<td>返回与匹配的实体数<code>Predicate</code>。</td>
</tr>
<tr>
<td>4</td>
<td>返回匹配<code>Predicate</code>存在的实体。</td>
</tr>
</tbody></table>
<p>To make use of Querydsl support, extend <code>QuerydslPredicateExecutor</code> on your repository interface, as shown in the following example</p>
<p>要使用Querydsl支持，请扩展<code>QuerydslPredicateExecutor</code>存储库接口，如以下示例所示</p>
<p>Example 44. Querydsl integration on repositories</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">QuerydslPredicateExecutor</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The preceding example lets you write typesafe queries using Querydsl <code>Predicate</code> instances, as shown in the following example:</p>
<p>前面的示例使您可以使用Querydsl <code>Predicate</code>实例编写类型安全查询，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Predicate predicate = user.firstname.equalsIgnoreCase(<span class="string">&quot;dave&quot;</span>)</span><br><span class="line">    .and(user.lastname.startsWithIgnoreCase(<span class="string">&quot;mathews&quot;</span>));</span><br><span class="line"></span><br><span class="line">userRepository.findAll(predicate);</span><br></pre></td></tr></table></figure>

<h4 id="8-8-2-Web-support"><a href="#8-8-2-Web-support" class="headerlink" title="8.8.2. Web support"></a>8.8.2. Web support</h4><table>
<thead>
<tr>
<th></th>
<th>This section contains the documentation for the Spring Data web support as it is implemented in the current (and later) versions of Spring Data Commons. As the newly introduced support changes many things, we kept the documentation of the former behavior in [<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#web.legacy">web.legacy]</a>.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>本部分包含Spring Data Web支持的文档，该文档在Spring Data Commons的当前（和更高版本）中实现。随着新引入的支持发生了很多变化，我们将以前行为的文档保存在[<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#web.legacy">web.legacy]中</a>。</td>
</tr>
</tbody></table>
<blockquote>
<p>Spring Data modules that support the repository programming model ship with a variety of web support. The web related components require Spring MVC JARs to be on the classpath. Some of them even provide integration with <a target="_blank" rel="noopener" href="https://github.com/SpringSource/spring-hateoas">Spring HATEOAS</a>. In general, the integration support is enabled by using the <code>@EnableSpringDataWebSupport</code> annotation in your JavaConfig configuration class, as shown in the following example:</p>
<p>支持存储库编程模型的Spring Data模块附带各种Web支持。与Web相关的组件要求Spring MVC JAR位于类路径上。其中一些甚至提供与<a target="_blank" rel="noopener" href="https://github.com/SpringSource/spring-hateoas">Spring HATEOAS的</a>集成。通常，通过使用<code>@EnableSpringDataWebSupport</code>JavaConfig配置类中的注释来启用集成支持，如以下示例所示：</p>
</blockquote>
<p>Example 45. Enabling Spring Data web support</p>
<p><strong>例子45.启用Spring Data Web支持</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableSpringDataWebSupport</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The <code>@EnableSpringDataWebSupport</code> annotation registers a few components we will discuss in a bit. It will also detect Spring HATEOAS on the classpath and register integration components for it as well if present.</p>
</blockquote>
<blockquote>
<p>Alternatively, if you use XML configuration, register either <code>SpringDataWebConfiguration</code> or <code>HateoasAwareSpringDataWebConfiguration</code> as Spring beans, as shown in the following example (for <code>SpringDataWebConfiguration</code>):</p>
</blockquote>
<p>该<code>@EnableSpringDataWebSupport</code>批注注解注册了一些我们将要讨论的组件。它还将在类路径上检测Spring HATEOAS，并为其注册集成组件（如果存在）。</p>
<p>另外，如果您使用XML配置，请注册<code>SpringDataWebConfiguration</code>或注册<code>HateoasAwareSpringDataWebConfiguration</code>为Spring Bean，如以下示例（针对<code>SpringDataWebConfiguration</code>）所示：</p>
<p>Example 46. Enabling Spring Data web support in XML</p>
<p><strong>例子46.在XML中启用Spring Data Web支持</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.web.config.SpringDataWebConfiguration&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- If you use Spring HATEOAS, register this one *instead* of the former --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Basic-Web-Support"><a href="#Basic-Web-Support" class="headerlink" title="Basic Web Support"></a>Basic Web Support</h5><blockquote>
<p>The configuration shown in the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#core.web">previous section</a> registers a few basic components:</p>
<ul>
<li><p>A <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#core.web.basic.domain-class-converter"><code>DomainClassConverter</code></a> to let Spring MVC resolve instances of repository-managed domain classes from request parameters or path variables.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#core.web.basic.paging-and-sorting"><code>HandlerMethodArgumentResolver</code></a> implementations to let Spring MVC resolve <code>Pageable</code> and <code>Sort</code> instances from request parameters.</p>
</li>
</ul>
<p>  <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#core.web">上一节中</a>显示的配置注册了一些基本组件：</p>
<ul>
<li>一个<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#core.web.basic.domain-class-converter"><code>DomainClassConverter</code></a>让Spring MVC等通过请求参数或路径变量解析资源库管理的域类的实例。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#core.web.basic.paging-and-sorting"><code>HandlerMethodArgumentResolver</code></a>让Spring MVC通过请求参数解析<code>Pageable</code>和<code>Sort</code>实例。</li>
</ul>
</blockquote>
<h6 id="DomainClassConverter"><a href="#DomainClassConverter" class="headerlink" title="DomainClassConverter"></a><code>DomainClassConverter</code></h6><blockquote>
<p>The <code>DomainClassConverter</code> lets you use domain types in your Spring MVC controller method signatures directly, so that you need not manually lookup the instances through the repository, as shown in the following example:</p>
</blockquote>
<p>使用<code>DomainClassConverter</code>，您可以直接在Spring MVC控制器方法签名中使用域类型，从而无需通过存储库手动查找实例，如以下示例所示：</p>
<p>Example 47. A Spring MVC controller using domain types in method signatures</p>
<p><strong>例子47.一个在方法签名中使用域类型的Spring MVC控制器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">showUserForm</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> User user, Model model)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;userForm&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, the method receives a <code>User</code> instance directly, and no further lookup is necessary. The instance can be resolved by letting Spring MVC convert the path variable into the <code>id</code> type of the domain class first and eventually access the instance through calling <code>findById(…)</code> on the repository instance registered for the domain type.</p>
<p>如您所见，该方法<code>User</code>直接接收一个实例，不需要进一步的查找。可以通过让Spring MVC首先将路径变量转换为<code>id</code>域类的类型并最终通过调用该域类型注册的存储库实例<code>findById(…)</code>来访问该实例实现解析该实例。</p>
<table>
<thead>
<tr>
<th></th>
<th>Currently, the repository has to implement <code>CrudRepository</code> to be eligible to be discovered for conversion.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>当前，该存储库必须实现<code>CrudRepository</code>才有资格被发现以进行转换。</td>
</tr>
</tbody></table>
<h6 id="HandlerMethodArgumentResolvers-for-Pageable-and-Sort"><a href="#HandlerMethodArgumentResolvers-for-Pageable-and-Sort" class="headerlink" title="HandlerMethodArgumentResolvers for Pageable and Sort"></a>HandlerMethodArgumentResolvers for Pageable and Sort</h6><p><code>用于分页和排序的HandlerMethodArgumentResolvers</code></p>
<blockquote>
<p>The configuration snippet shown in the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#core.web.basic.domain-class-converter">previous section</a> also registers a <code>PageableHandlerMethodArgumentResolver</code> as well as an instance of <code>SortHandlerMethodArgumentResolver</code>. The registration enables <code>Pageable</code> and <code>Sort</code> as valid controller method arguments, as shown in the following example:</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#core.web.basic.domain-class-converter">上一节中</a>显示的配置代码<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#core.web.basic.domain-class-converter">段</a>还注册<code>PageableHandlerMethodArgumentResolver</code>以及的实例<code>SortHandlerMethodArgumentResolver</code>。注册启用<code>Pageable</code>和<code>Sort</code>作为有效的控制器方法参数，如以下示例所示：</p>
</blockquote>
<p>Example 48. Using Pageable as controller method argument</p>
<p><strong>例子48.使用Pageable作为控制器方法参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UserRepository repository;</span><br><span class="line"></span><br><span class="line">  UserController(UserRepository repository) &#123;</span><br><span class="line">    <span class="keyword">this</span>.repository = repository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span></span><br><span class="line">  <span class="function">String <span class="title">showUsers</span><span class="params">(Model model, Pageable pageable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">&quot;users&quot;</span>, repository.findAll(pageable));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;users&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The preceding method signature causes Spring MVC try to derive a <code>Pageable</code> instance from the request parameters by using the following default configuration:</p>
<p>前面的方法签名使Spring MVC尝试<code>Pageable</code>使用以下默认配置从请求参数派生实例：</p>
<table>
<thead>
<tr>
<th><code>page</code></th>
<th>Page you want to retrieve. 0-indexed and defaults to 0.</th>
</tr>
</thead>
<tbody><tr>
<td><code>size</code></td>
<td>Size of the page you want to retrieve. Defaults to 20.</td>
</tr>
<tr>
<td><code>sort</code></td>
<td>Properties that should be sorted by in the format `property,property(,ASC</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>page</code></th>
<th>您要检索的页面。0索引，默认为0。</th>
</tr>
</thead>
<tbody><tr>
<td><code>size</code></td>
<td>您要检索的页面大小。默认为20</td>
</tr>
<tr>
<td><code>sort</code></td>
<td>应该以…格式排序的属性`property,property(,ASC</td>
</tr>
</tbody></table>
<blockquote>
<p>To customize this behavior, register a bean implementing the <code>PageableHandlerMethodArgumentResolverCustomizer</code> interface or the <code>SortHandlerMethodArgumentResolverCustomizer</code> interface, respectively. Its <code>customize()</code> method gets called, letting you change settings, as shown in the following example:</p>
<p>要定制此行为，请分别注册一个实现该<code>PageableHandlerMethodArgumentResolverCustomizer</code>接口或该<code>SortHandlerMethodArgumentResolverCustomizer</code>接口的bean 。它的<code>customize()</code>方法被调用，让您更改设置，如以下示例所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="function">SortHandlerMethodArgumentResolverCustomizer <span class="title">sortCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s -&gt; s.setPropertyDelimiter(<span class="string">&quot;&lt;--&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>If setting the properties of an existing <code>MethodArgumentResolver</code> is not sufficient for your purpose, extend either <code>SpringDataWebConfiguration</code> or the HATEOAS-enabled equivalent, override the <code>pageableResolver()</code> or <code>sortResolver()</code> methods, and import your customized configuration file instead of using the <code>@Enable</code> annotation.</p>
<p>If you need multiple <code>Pageable</code> or <code>Sort</code> instances to be resolved from the request (for multiple tables, for example), you can use Spring’s <code>@Qualifier</code> annotation to distinguish one from another. The request parameters then have to be prefixed with <code>$&#123;qualifier&#125;_</code>. The followig example shows the resulting method signature:</p>
</blockquote>
<p>如果设置现有属性<code>MethodArgumentResolver</code>不足以实现您的目的，请扩展<code>SpringDataWebConfiguration</code>或扩展启用HATEOAS的等效项，覆盖<code>pageableResolver()</code>或<code>sortResolver()</code>方法，然后导入自定义的配置文件，而不使用<code>@Enable</code>注释。</p>
<p>如果您需要从请求中解析多个<code>Pageable</code>或<code>Sort</code>实例（例如，对于多个表），则可以使用Spring的<code>@Qualifier</code>注释将一个或另一个区分。然后，请求参数必须以开头<code>$&#123;qualifier&#125;_</code>。以下示例显示了生成的方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">showUsers</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Qualifier(&quot;thing1&quot;)</span> Pageable first,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Qualifier(&quot;thing2&quot;)</span> Pageable second)</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>you have to populate <code>thing1_page</code> and <code>thing2_page</code> and so on.</p>
<p>The default <code>Pageable</code> passed into the method is equivalent to a <code>PageRequest.of(0, 20)</code> but can be customized by using the <code>@PageableDefault</code> annotation on the <code>Pageable</code> parameter.</p>
<p>你需要填充<code>thing1_page</code>和<code>thing2_page</code>等。</p>
<p><code>Pageable</code>传递给该方法的默认值等效于<code>PageRequest.of(0, 20)</code>但可以使用参数<code>@PageableDefault</code>上的注释进行自定义<code>Pageable</code>。</p>
</blockquote>
<h5 id="Hypermedia-Support-for-Pageables"><a href="#Hypermedia-Support-for-Pageables" class="headerlink" title="Hypermedia Support for Pageables"></a>Hypermedia Support for Pageables</h5><h5 id="超媒体对分页的支持"><a href="#超媒体对分页的支持" class="headerlink" title="超媒体对分页的支持"></a>超媒体对分页的支持</h5><blockquote>
<p>Spring HATEOAS ships with a representation model class (<code>PagedResources</code>) that allows enriching the content of a <code>Page</code> instance with the necessary <code>Page</code> metadata as well as links to let the clients easily navigate the pages. The conversion of a Page to a <code>PagedResources</code> is done by an implementation of the Spring HATEOAS <code>ResourceAssembler</code> interface, called the <code>PagedResourcesAssembler</code>. The following example shows how to use a <code>PagedResourcesAssembler</code> as a controller method argument:</p>
<p>Example 49. Using a PagedResourcesAssembler as controller method argument</p>
<p>Spring HATEOAS附带一个表示模型类（<code>PagedResources</code>），该类允许<code>Page</code>使用必要的<code>Page</code>元数据和链接丰富实例的内容，以使客户端可以轻松浏览页面。Page到转换<code>PagedResources</code>是通过Spring HATEOAS <code>ResourceAssembler</code>称为<code>PagedResourcesAssembler</code>的实现完成的。以下示例显示如何将 <code>PagedResourcesAssembler</code>用作控制器方法参数：</p>
<p>例子49.使用PagedResourcesAssembler作为控制器方法参数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span> PersonRepository repository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/persons&quot;, method = RequestMethod.GET)</span></span><br><span class="line">  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable,</span><br><span class="line">    PagedResourcesAssembler assembler) &#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;Person&gt; persons = repository.findAll(pageable);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Enabling the configuration as shown in the preceding example lets the <code>PagedResourcesAssembler</code> be used as a controller method argument. Calling <code>toResources(…)</code> on it has the following effects:</p>
<ul>
<li>The content of the <code>Page</code> becomes the content of the <code>PagedResources</code> instance.</li>
<li>The <code>PagedResources</code> object gets a <code>PageMetadata</code> instance attached, and it is populated with information from the <code>Page</code> and the underlying <code>PageRequest</code>.</li>
<li>The <code>PagedResources</code> may get <code>prev</code> and <code>next</code> links attached, depending on the page’s state. The links point to the URI to which the method maps. The pagination parameters added to the method match the setup of the <code>PageableHandlerMethodArgumentResolver</code> to make sure the links can be resolved later.</li>
</ul>
<p>Assume we have 30 Person instances in the database. You can now trigger a request (<code>GET http://localhost:8080/persons</code>) and see output similar to the following:</p>
<p>如上例所示启用配置，可以将<code>PagedResourcesAssembler</code>其用作控制器方法参数。调用<code>toResources(…)</code>它具有以下效果：</p>
<ul>
<li><code>Page</code>的内容成为<code>PagedResources</code>实例的内容。</li>
<li>所述<code>PagedResources</code>对象获得一个<code>PageMetadata</code>附加实例，并且它填充了从信息<code>Page</code>和底层<code>PageRequest</code>。</li>
<li><code>PagedResources</code>可能获取<code>prev</code>和<code>next</code>连接链路，根据页面的状态。链接指向方法映射到的URI。添加到该方法的分页参数与<code>PageableHandlerMethodArgumentResolver</code>设置匹配，以确保以后可以解析链接。</li>
</ul>
<p>假设数据库中有30个Person实例。现在，您可以触发请求（）并查看类似于以下内容的输出：<code>GET http://localhost:8080/persons</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;links&quot;</span> : [ &#123; <span class="string">&quot;rel&quot;</span> : <span class="string">&quot;next&quot;</span>,</span><br><span class="line">                <span class="string">&quot;href&quot;</span> : <span class="string">&quot;http://localhost:8080/persons?page=1&amp;size=20 &#125;</span></span><br><span class="line"><span class="string">  ],</span></span><br><span class="line"><span class="string">  &quot;</span>content<span class="string">&quot; : [</span></span><br><span class="line"><span class="string">     … // 20 Person instances rendered here</span></span><br><span class="line"><span class="string">  ],</span></span><br><span class="line"><span class="string">  &quot;</span>pageMetadata<span class="string">&quot; : &#123;</span></span><br><span class="line"><span class="string">    &quot;</span>size<span class="string">&quot; : 20,</span></span><br><span class="line"><span class="string">    &quot;</span>totalElements<span class="string">&quot; : 30,</span></span><br><span class="line"><span class="string">    &quot;</span>totalPages<span class="string">&quot; : 2,</span></span><br><span class="line"><span class="string">    &quot;</span>number<span class="string">&quot; : 0</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>You see that the assembler produced the correct URI and also picked up the default configuration to resolve the parameters into a <code>Pageable</code> for an upcoming request. This means that, if you change that configuration, the links automatically adhere to the change. By default, the assembler points to the controller method it was invoked in, but that can be customized by handing in a custom <code>Link</code> to be used as base to build the pagination links, which overloads the <code>PagedResourcesAssembler.toResource(…)</code> method.</p>
<p>您会看到汇编器生成了正确的URI，并且还选择了默认配置以将参数解析<code>Pageable</code>为即将到来的请求。这意味着，如果您更改该配置，则链接将自动遵循更改。默认情况下，汇编器指向调用它的控制器方法，但是可以通过传递一个自定义<code>Link</code>来进行自定义，该自定义用作构建分页链接的基础，这会使重载该<code>PagedResourcesAssembler.toResource(…)</code>方法。</p>
</blockquote>
<h5 id="Web-Databinding-Support"><a href="#Web-Databinding-Support" class="headerlink" title="Web Databinding Support"></a>Web Databinding Support</h5><h5 id="Web数据绑定支持"><a href="#Web数据绑定支持" class="headerlink" title="Web数据绑定支持"></a>Web数据绑定支持</h5><blockquote>
<p>Spring Data projections (described in [<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#projections">projections]</a>) can be used to bind incoming request payloads by either using <a target="_blank" rel="noopener" href="https://goessner.net/articles/JsonPath/">JSONPath</a> expressions (requires <a target="_blank" rel="noopener" href="https://github.com/json-path/JsonPath">Jayway JsonPath</a> or <a target="_blank" rel="noopener" href="https://www.w3.org/TR/xpath-31/">XPath</a> expressions (requires <a target="_blank" rel="noopener" href="https://xmlbeam.org/">XmlBeam</a>), as shown in the following example:</p>
<p>Example 50. HTTP payload binding using JSONPath or XPath expressions</p>
</blockquote>
<p>通过使用<a target="_blank" rel="noopener" href="https://goessner.net/articles/JsonPath/">JSONPath</a>表达式（需要<a target="_blank" rel="noopener" href="https://github.com/json-path/JsonPath">Jayway JsonPath</a>或<a target="_blank" rel="noopener" href="https://www.w3.org/TR/xpath-31/">XPath</a>表达式（需要<a target="_blank" rel="noopener" href="https://xmlbeam.org/">XmlBeam</a>）），可以使用Spring Data投影（在[<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#projections">projections]中</a>描述）来绑定传入的请求有效负载，如以下示例所示：</p>
<p>例子50.使用JSONPath或XPath表达式的HTTP有效负载绑定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ProjectedPayload</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserPayload</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@XBRead(&quot;//firstname&quot;)</span></span><br><span class="line">  <span class="meta">@JsonPath(&quot;$..firstname&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">getFirstname</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@XBRead(&quot;/lastname&quot;)</span></span><br><span class="line">  <span class="meta">@JsonPath(&#123; &quot;$.lastname&quot;, &quot;$.user.lastname&quot; &#125;)</span></span><br><span class="line">  <span class="function">String <span class="title">getLastname</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The type shown in the preceding example can be used as a Spring MVC handler method argument or by using <code>ParameterizedTypeReference</code> on one of <code>RestTemplate</code>‘s methods. The preceding method declarations would try to find <code>firstname</code> anywhere in the given document. The <code>lastname</code> XML lookup is performed on the top-level of the incoming document. The JSON variant of that tries a top-level <code>lastname</code> first but also tries <code>lastname</code> nested in a <code>user</code> sub-document if the former does not return a value. That way, changes in the structure of the source document can be mitigated easily without having clients calling the exposed methods (usually a drawback of class-based payload binding).</p>
<p>在前面的示例中给出的类型可以用作一个Spring MVC处理程序方法参数或通过使用<code>ParameterizedTypeReference</code>上的一个<code>RestTemplate</code>的方法。前面的方法声明将尝试<code>firstname</code>在给定文档中找到任何地方。该<code>lastname</code>XML查询是对输入文档的顶层进行。JSON变体的<code>lastname</code>首先尝试顶层，但如果前者没有返回值，则还尝试<code>lastname</code>嵌套在<code>user</code>子文档中。这样，可以轻松缓解源文档结构的更改，而无需客户端调用公开的方法（通常是基于类的有效负载绑定的缺点）。</p>
</blockquote>
<p>Nested projections are supported as described in [<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#projections">projections]</a>. If the method returns a complex, non-interface type, a Jackson <code>ObjectMapper</code> is used to map the final value.</p>
<p>如[<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#projections">投影]中</a>所述，支持嵌套投影。如果该方法返回复杂的非接口类型，<code>ObjectMapper</code>则使用Jackson 来映射最终值。</p>
<blockquote>
<p>For Spring MVC, the necessary converters are registered automatically as soon as <code>@EnableSpringDataWebSupport</code> is active and the required dependencies are available on the classpath. For usage with <code>RestTemplate</code>, register a <code>ProjectingJackson2HttpMessageConverter</code> (JSON) or <code>XmlBeamHttpMessageConverter</code> manually.</p>
</blockquote>
<p>对于Spring MVC，必要的转换器在<code>@EnableSpringDataWebSupport</code>运行时会立即自动注册，并且所需的依赖项在类路径上可用。要用于<code>RestTemplate</code>，请手动注册<code>ProjectingJackson2HttpMessageConverter</code>（JSON）或<code>XmlBeamHttpMessageConverter</code>。</p>
<p>For more information, see the <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples/tree/master/web/projection">web projection example</a> in the canonical <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples">Spring Data Examples repository</a>.</p>
<p>有关更多信息，请参阅规范的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples">Spring Data Examples存储库中</a>的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples/tree/master/web/projection">Web投影示例</a>。</p>
<h5 id="Querydsl-Web-Support"><a href="#Querydsl-Web-Support" class="headerlink" title="Querydsl Web Support"></a>Querydsl Web Support</h5><p>For those stores having <a target="_blank" rel="noopener" href="http://www.querydsl.com/">QueryDSL</a> integration, it is possible to derive queries from the attributes contained in a <code>Request</code> query string.</p>
<p>对于那些具有<a target="_blank" rel="noopener" href="http://www.querydsl.com/">QueryDSL</a>集成的存储库，可以从<code>Request</code>查询字符串中包含的属性派生查询。</p>
<p>Consider the following query string:</p>
<p>考虑以下查询字符串：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?firstname=Dave&amp;lastname=Matthews</span><br></pre></td></tr></table></figure>

<p>Given the <code>User</code> object from previous examples, a query string can be resolved to the following value by using the <code>QuerydslPredicateArgumentResolver</code>.</p>
<p>给定<code>User</code>前面示例中的对象，可以使用来将查询字符串解析为以下值<code>QuerydslPredicateArgumentResolver</code>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QUser.user.firstname.eq(&quot;Dave&quot;).and(QUser.user.lastname.eq(&quot;Matthews&quot;))</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>The feature is automatically enabled, along with <code>@EnableSpringDataWebSupport</code>, when Querydsl is found on the classpath.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>当在类路径上找到Querydsl时 ，该功能将与<code>@EnableSpringDataWebSupport</code>一起自动启用。</td>
</tr>
</tbody></table>
<p>Adding a <code>@QuerydslPredicate</code> to the method signature provides a ready-to-use <code>Predicate</code>, which can be run by using the <code>QuerydslPredicateExecutor</code>.</p>
<p><code>@QuerydslPredicate</code>在方法签名中添加一个即可使用<code>Predicate</code>，可以使用来运行<code>QuerydslPredicateExecutor</code>。</p>
<table>
<thead>
<tr>
<th></th>
<th>Type information is typically resolved from the method’s return type. Since that information does not necessarily match the domain type, it might be a good idea to use the <code>root</code> attribute of <code>QuerydslPredicate</code>.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>类型信息通常从方法的返回类型中解析。由于该信息不一定与域类型匹配，因此使用<code>QuerydslPredicate</code>的<code>root</code>属性可能是一个好主意。</td>
</tr>
</tbody></table>
<p>The following exampe shows how to use <code>@QuerydslPredicate</code> in a method signature:</p>
<p>以下示例显示了如何在方法签名中使用<code>@QuerydslPredicate</code>：</p>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/38fdb797f65b4e97ba475cfbc6bd5924-blog-17.jpg" alt="blog-17"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span> UserRepository repository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)</span></span><br><span class="line">  <span class="function">String <span class="title">index</span><span class="params">(Model model, <span class="meta">@QuerydslPredicate(root = User.class)</span> Predicate predicate,    </span></span></span><br><span class="line"><span class="function"><span class="params">          Pageable pageable, <span class="meta">@RequestParam</span> MultiValueMap&lt;String, String&gt; parameters)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">&quot;users&quot;</span>, repository.findAll(predicate, pageable));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>Resolve query string arguments to matching <code>Predicate</code> for <code>User</code>.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>解析查询字符串参数匹配<code>Predicate</code>的<code>User</code>。</td>
</tr>
</tbody></table>
<blockquote>
<p>The default binding is as follows:</p>
<ul>
<li><code>Object</code> on simple properties as <code>eq</code>.</li>
<li><code>Object</code> on collection like properties as <code>contains</code>.</li>
<li><code>Collection</code> on simple properties as <code>in</code>.</li>
</ul>
<p>Those bindings can be customized through the <code>bindings</code> attribute of <code>@QuerydslPredicate</code> or by making use of Java 8 <code>default methods</code> and adding the <code>QuerydslBinderCustomizer</code> method to the repository interface.</p>
</blockquote>
<p>默认绑定如下：</p>
<ul>
<li><code>Object</code>的简单属性<code>eq</code>。</li>
<li><code>Object</code>像属性一样的集合<code>contains</code>。</li>
<li><code>Collection</code>的简单属性<code>in</code>。</li>
</ul>
<p>可以通过Java 8 的<code>bindings</code>属性<code>@QuerydslPredicate</code>或通过使用Java 8 <code>default methods</code>并将这些<code>QuerydslBinderCustomizer</code>方法添加到存储库接口来定制这些绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">String</span>&gt;,</span></span><br><span class="line"><span class="class">                                 <span class="title">QuerydslPredicateExecutor</span>&lt;<span class="title">User</span>&gt;,                </span></span><br><span class="line"><span class="class">                                 <span class="title">QuerydslBinderCustomizer</span>&lt;<span class="title">QUser</span>&gt; </span>&#123;               </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(QuerydslBindings bindings, QUser user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    bindings.bind(user.username).first((path, value) -&gt; path.contains(value))    </span><br><span class="line">    bindings.bind(String.class)</span><br><span class="line">      .first((StringPath path, String value) -&gt; path.containsIgnoreCase(value)); </span><br><span class="line">    bindings.excluding(user.password);                                           </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th><code>QuerydslPredicateExecutor</code> provides access to specific finder methods for <code>Predicate</code>.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>QuerydslBinderCustomizer</code> defined on the repository interface is automatically picked up and shortcuts <code>@QuerydslPredicate(bindings=…)</code>.</td>
</tr>
<tr>
<td></td>
<td>Define the binding for the <code>username</code> property to be a simple <code>contains</code> binding.</td>
</tr>
<tr>
<td></td>
<td>Define the default binding for <code>String</code> properties to be a case-insensitive <code>contains</code> match.</td>
</tr>
<tr>
<td></td>
<td>Exclude the <code>password</code> property from <code>Predicate</code> resolution.</td>
</tr>
</tbody></table>
<p><img src="C:\Users\Cheri_Du\Desktop\blog-18.jpg" alt="blog-18"></p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>QuerydslPredicateExecutor</code>提供对特定查找器方法的访问<code>Predicate</code>。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><code>QuerydslBinderCustomizer</code>在存储库接口上定义的内容会自动获取和快捷方式<code>@QuerydslPredicate(bindings=…)</code>。</td>
</tr>
<tr>
<td>3</td>
<td>将<code>username</code>属性的绑定定义为简单<code>contains</code>绑定。</td>
</tr>
<tr>
<td>4</td>
<td>将<code>String</code>属性的默认绑定定义为不区分大小写的<code>contains</code>匹配。</td>
</tr>
<tr>
<td>5</td>
<td><code>password</code>从<code>Predicate</code>分辨率中排除该属性。</td>
</tr>
</tbody></table>
<h4 id="8-8-3-Repository-Populators"><a href="#8-8-3-Repository-Populators" class="headerlink" title="8.8.3. Repository Populators"></a>8.8.3. Repository Populators</h4><p>​    <code>存储库填充器</code></p>
<blockquote>
<p>If you work with the Spring JDBC module, you are probably familiar with the support to populate a <code>DataSource</code> with SQL scripts. A similar abstraction is available on the repositories level, although it does not use SQL as the data definition language because it must be store-independent. Thus, the populators support XML (through Spring’s OXM abstraction) and JSON (through Jackson) to define data with which to populate the repositories.</p>
<p>Assume you have a file <code>data.json</code> with the following content:</p>
</blockquote>
<p>如果您使用Spring JDBC模块，则可能熟悉使用SQL脚本填充<code>DataSource</code>的支持。尽管它不使用SQL作为数据定义语言，因为它必须独立于存储，因此在存储库级别上可以使用类似的抽象。因此，填充器支持XML（通过Spring的OXM抽象）和JSON（通过Jackson）来定义用于填充存储库的数据。</p>
<p>假设您有一个<code>data.json</code>包含以下内容的文件：</p>
<p>Example 51. Data defined in JSON</p>
<p><strong>例子51.用JSON定义的数据</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; <span class="string">&quot;_class&quot;</span> : <span class="string">&quot;com.acme.Person&quot;</span>,</span><br><span class="line"> <span class="string">&quot;firstname&quot;</span> : <span class="string">&quot;Dave&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lastname&quot;</span> : <span class="string">&quot;Matthews&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;_class&quot;</span> : <span class="string">&quot;com.acme.Person&quot;</span>,</span><br><span class="line"> <span class="string">&quot;firstname&quot;</span> : <span class="string">&quot;Carter&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lastname&quot;</span> : <span class="string">&quot;Beauford&quot;</span> &#125; ]</span><br></pre></td></tr></table></figure>

<p>You can populate your repositories by using the populator elements of the repository namespace provided in Spring Data Commons. To populate the preceding data to your PersonRepository, declare a populator similar to the following:</p>
<p>您可以使用Spring Data Commons中提供的存储库命名空间的populator元素来填充存储库。要将前面的数据填充到您的PersonRepository中，请声明一个类似于以下内容的填充器：</p>
<p>Example 52. Declaring a Jackson repository populator</p>
<p><strong>例子52.声明一个Jackson存储库填充器</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:repository</span>=<span class="string">&quot;http://www.springframework.org/schema/data/repository&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/repository</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/data/repository/spring-repository.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository:jackson2-populator</span> <span class="attr">locations</span>=<span class="string">&quot;classpath:data.json&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The preceding declaration causes the <code>data.json</code> file to be read and deserialized by a Jackson <code>ObjectMapper</code>.</p>
<p>The type to which the JSON object is unmarshalled is determined by inspecting the <code>_class</code> attribute of the JSON document. The infrastructure eventually selects the appropriate repository to handle the object that was deserialized.</p>
<p>To instead use XML to define the data the repositories should be populated with, you can use the <code>unmarshaller-populator</code> element. You configure it to use one of the XML marshaller options available in Spring OXM. See the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/data-access.html#oxm">Spring reference documentation</a> for details. The following example shows how to unmarshal a repository populator with JAXB:</p>
</blockquote>
<p>前面的声明使<code>data.json</code>文件由Jackson读取并反序列化<code>ObjectMapper</code>。</p>
<p>通过检查<code>_class</code>JSON文档的属性来确定将JSON对象类型解析。基础结构最终选择适当的存储库来处理反序列化的对象。</p>
<p>要改为使用XML定义应向存储库填充的数据，可以使用<code>unmarshaller-populator</code>元素。您可以将其配置为使用Spring OXM中可用的XML marshaller选项之一。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/data-access.html#oxm">Spring参考文档</a>。以下示例显示如何使用JAXB解组存储库填充器：</p>
<p>Example 53. Declaring an unmarshalling repository populator (using JAXB)</p>
<p><strong>例子53.声明一个解组存储库填充器（使用JAXB）</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:repository</span>=<span class="string">&quot;http://www.springframework.org/schema/data/repository&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:oxm</span>=<span class="string">&quot;http://www.springframework.org/schema/oxm&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/repository</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/data/repository/spring-repository.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/oxm</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/oxm/spring-oxm.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository:unmarshaller-populator</span> <span class="attr">locations</span>=<span class="string">&quot;classpath:data.json&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">unmarshaller-ref</span>=<span class="string">&quot;unmarshaller&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">oxm:jaxb2-marshaller</span> <span class="attr">contextPath</span>=<span class="string">&quot;com.acme&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Reference-Documentation"><a href="#Reference-Documentation" class="headerlink" title="Reference Documentation"></a>Reference Documentation</h1><p><code> 参考文件</code></p>
<h2 id="9-JDBC-Repositories"><a href="#9-JDBC-Repositories" class="headerlink" title="9. JDBC Repositories"></a>9. JDBC Repositories</h2><p><code> JDBC存储库</code></p>
<p>This chapter points out the specialties for repository support for JDBC. This builds on the core repository support explained in <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories">Working with Spring Data Repositories</a>. You should have a sound understanding of the basic concepts explained there.</p>
<p>本章指出了JDBC存储库支持的特性。它建立在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories">使用Spring Data Repositories所</a>解释的核心存储库支持的基础上。您应该对这里介绍的基本概念有一个很好的了解。</p>
<h3 id="9-1-Why-Spring-Data-JDBC"><a href="#9-1-Why-Spring-Data-JDBC" class="headerlink" title="9.1. Why Spring Data JDBC?"></a>9.1. Why Spring Data JDBC?</h3><p><code>为什么选择Spring Data JDBC？</code></p>
<blockquote>
<p>The main persistence API for relational databases in the Java world is certainly JPA, which has its own Spring Data module. Why is there another one?</p>
<p>JPA does a lot of things in order to help the developer. Among other things, it tracks changes to entities. It does lazy loading for you. It lets you map a wide array of object constructs to an equally wide array of database designs.</p>
<p>This is great and makes a lot of things really easy. Just take a look at a basic JPA tutorial. But it often gets really confusing as to why JPA does a certain thing. Also, things that are really simple conceptually get rather difficult with JPA.</p>
<p>Spring Data JDBC aims to be much simpler conceptually, by embracing the following design decisions:</p>
<ul>
<li>If you load an entity, SQL statements get run. Once this is done, you have a completely loaded entity. No lazy loading or caching is done.</li>
<li>If you save an entity, it gets saved. If you do not, it does not. There is no dirty tracking and no session.</li>
<li>There is a simple model of how to map entities to tables. It probably only works for rather simple cases. If you do not like that, you should code your own strategy. Spring Data JDBC offers only very limited support for customizing the strategy with annotations.</li>
</ul>
</blockquote>
<p>Java世界中用于关系数据库的主要持久性API当然是JPA，它具有自己的Spring Data模块。为什么还有另一个？</p>
<p>JPA为了帮助开发人员做了很多事情。除其他外，它跟踪对实体的更改。它为您完成了延迟加载。它使您可以将各种各样的对象构造映射到同样广泛的数据库设计中。</p>
<p>这很棒，而且使很多事情变得非常容易。只需看一下基本的JPA教程即可。但是，为什么JPA会做某件事常常使人感到困惑。而且，从概念上讲，真正简单的事情在JPA中变得相当困难。</p>
<p>通过包含以下设计决策，Spring Data JDBC的目标是从概念上简化得多：</p>
<ul>
<li>如果加载实体，则将运行SQL语句。完成此操作后，您将拥有一个完全加载的实体。不会进行延迟加载或缓存。</li>
<li>如果保存实体，则将保存它。如果您不这样做，则不会。没有肮脏的跟踪，也没有会话。</li>
<li>有一个简单的模型可以将实体映射到表。它可能仅适用于相当简单的情况。如果您不喜欢这样做，则应编写自己的策略。Spring Data JDBC仅提供非常有限的支持，但可以通过注释自定义策略。</li>
</ul>
<h3 id="9-2-Domain-Driven-Design-and-Relational-Databases"><a href="#9-2-Domain-Driven-Design-and-Relational-Databases" class="headerlink" title="9.2. Domain Driven Design and Relational Databases."></a>9.2. Domain Driven Design and Relational Databases.</h3><p><code>域驱动的设计和关系数据库</code>        </p>
<blockquote>
<p>All Spring Data modules are inspired by the concepts of “repository”, “aggregate”, and “aggregate root” from Domain Driven Design. These are possibly even more important for Spring Data JDBC, because they are, to some extent, contrary to normal practice when working with relational databases.</p>
<p>An aggregate is a group of entities that is guaranteed to be consistent between atomic changes to it. A classic example is an <code>Order</code> with <code>OrderItems</code>. A property on <code>Order</code> (for example, <code>numberOfItems</code> is consistent with the actual number of <code>OrderItems</code>) remains consistent as changes are made.</p>
<p>References across aggregates are not guaranteed to be consistent at all times. They are guaranteed to become consistent eventually.</p>
<p>Each aggregate has exactly one aggregate root, which is one of the entities of the aggregate. The aggregate gets manipulated only through methods on that aggregate root. These are the atomic changes mentioned earlier.</p>
<p>A repository is an abstraction over a persistent store that looks like a collection of all the aggregates of a certain type. For Spring Data in general, this means you want to have one <code>Repository</code> per aggregate root. In addition, for Spring Data JDBC this means that all entities reachable from an aggregate root are considered to be part of that aggregate root. Spring Data JDBC assumes that only the aggregate has a foreign key to a table storing non-root entities of the aggregate and no other entity points toward non-root entities.</p>
<p>You can overwrite the repository methods with implementations that match your style of working and designing your database.</p>
</blockquote>
<p>所有Spring Data模块均受“域驱动设计”中“存储库”，“聚合”和“聚合根”概念的启发。这些对于Spring Data JDBC可能甚至更为重要，因为它们在某种程度上与使用关系数据库时的常规做法背道而驰。</p>
<p>集合是一组实体，可以保证在对其进行原子更改之间保持一致。一个经典的例子是<code>Order</code>with <code>OrderItems</code>。<code>Order</code>进行更改时，的属性（例如<code>numberOfItems</code>与的实际数量<code>OrderItems</code>一致）保持一致。</p>
<p>跨集合的引用不能保证始终保持一致。他们保证最终会变得一致。</p>
<p>每个集合都只有一个集合根，这是集合的实体之一。聚合只能通过该聚合根上的方法进行操作。这些是前面提到的原子变化。</p>
<p>存储库是对持久性存储的抽象，它看起来像某种特定类型的所有聚合的集合。一般来说，对于Spring Data，这意味着您希望<code>Repository</code>每个聚合根都有一个。另外，对于Spring Data JDBC，这意味着从聚合根可访问的所有实体均被视为该聚合根的一部分。Spring Data JDBC假定只有聚合对存储聚合的非根实体的表具有外键，并且没有其他实体指向非根实体。</p>
<table>
<thead>
<tr>
<th>In the current implementation, entities referenced from an aggregate root are deleted and recreated by Spring Data JDBC.</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>在当前实现中，Spring Data JDBC删除并重新创建了从聚合根引用的实体。</td>
<td></td>
</tr>
</tbody></table>
<p>您可以使用与您的数据库工作和设计风格相匹配的实现来覆盖存储库方法。</p>
<h3 id="9-3-Getting-Started"><a href="#9-3-Getting-Started" class="headerlink" title="9.3. Getting Started"></a>9.3. Getting Started</h3><p>An easy way to bootstrap setting up a working environment is to create a Spring-based project in <a target="_blank" rel="noopener" href="https://spring.io/tools/sts">STS</a> or from <a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initializr</a>.</p>
<p>引导工作环境的一种简单方法是在<a target="_blank" rel="noopener" href="https://spring.io/tools/sts">STS</a>或<a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initializr中</a>创建基于Spring的项目。</p>
<p>First, you need to set up a running database server. Refer to your vendor documentation on how to configure your database for JDBC access.</p>
<p>首先，您需要设置一个正在运行的数据库服务器。有关如何配置数据库以进行JDBC访问，请参阅供应商文档。</p>
<p>To create a Spring project in STS:</p>
<p>在STS中创建Spring项目：</p>
<ol>
<li><p>Go to File → New → Spring Template Project → Simple Spring Utility Project, and press Yes when prompted. Then enter a project and a package name, such as <code>org.spring.jdbc.example</code>.</p>
</li>
<li><p>Add the following to the <code>pom.xml</code> files <code>dependencies</code> element:</p>
<ol>
<li>转到文件→新建→Spring模板项目→Simple Spring Utility项目，然后在出现提示时按Yes。然后输入项目和包名称，例如<code>org.spring.jdbc.example</code>。</li>
<li>将以下内容添加到<code>pom.xml</code>files <code>dependencies</code>元素：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- other dependency elements omitted --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Change the version of Spring in the pom.xml to be</p>
<p>在pom.xml中将Spring的版本更改为</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring.framework.version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">spring.framework.version</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Add the following location of the Spring Milestone repository for Maven to your <code>pom.xml</code> such that it is at the same level of your <code>&lt;dependencies/&gt;</code> element:</p>
<p>将Maven的Spring Milestone存储库的以下位置添加到您的位置，以<code>pom.xml</code>使其与您的<code>&lt;dependencies/&gt;</code>元素处于同一级别</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestone<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Maven MILESTONE Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>The repository is also <a target="_blank" rel="noopener" href="https://repo.spring.io/milestone/org/springframework/data/">browseable here</a>.</p>
<p>该存储库也可<a target="_blank" rel="noopener" href="https://repo.spring.io/milestone/org/springframework/data/">在此处浏览</a>。</p>
<h3 id="9-4-Examples-Repository"><a href="#9-4-Examples-Repository" class="headerlink" title="9.4. Examples Repository"></a>9.4. Examples Repository</h3><p><code>示例库</code></p>
<p>There is a <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples">GitHub repository with several examples</a> that you can download and play around with to get a feel for how the library works.</p>
<p>有一个<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples">GitHub存储库，其中包含几个示例</a>，您可以下载并试用它们，以了解库的工作方式。</p>
<h3 id="9-5-Annotation-based-Configuration"><a href="#9-5-Annotation-based-Configuration" class="headerlink" title="9.5. Annotation-based Configuration"></a>9.5. Annotation-based Configuration</h3><p><code>基于注释的配置</code></p>
<p>The Spring Data JDBC repositories support can be activated by an annotation through Java configuration, as the following example shows:</p>
<p>可以通过Java配置中的注释来激活Spring Data JDBC存储库支持，如以下示例所示：</p>
<p>Example 54. Spring Data JDBC repositories using Java configuration</p>
<p><strong>例子54.使用Java配置的Spring Data JDBC存储库</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJdbcRepositories</span>                                                                </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> <span class="keyword">extends</span> <span class="title">AbstractJdbcConfiguration</span> </span>&#123;                            </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;                                                   </span><br><span class="line"></span><br><span class="line">        EmbeddedDatabaseBuilder builder = <span class="keyword">new</span> EmbeddedDatabaseBuilder();</span><br><span class="line">        <span class="keyword">return</span> builder.setType(EmbeddedDatabaseType.HSQL).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">NamedParameterJdbcOperations <span class="title">namedParameterJdbcOperations</span><span class="params">(DataSource dataSource)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NamedParameterJdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span> </span>&#123;                     </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th><code>@EnableJdbcRepositories</code> creates implementations for interfaces derived from <code>Repository</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>AbstractJdbcConfiguration</code> provides various default beans required by Spring Data JDBC</td>
</tr>
<tr>
<td></td>
<td>Creates a <code>DataSource</code> connecting to a database. This is required by the following two bean methods.</td>
</tr>
<tr>
<td></td>
<td>Creates the <code>NamedParameterJdbcOperations</code> used by Spring Data JDBC to access the database.</td>
</tr>
<tr>
<td></td>
<td>Spring Data JDBC utilizes the transaction management provided by Spring JDBC.</td>
</tr>
</tbody></table>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/b1897c2d27464695b6f59c2cea82ae12-blog-19.jpg" alt="blog-19"></p>
<ol>
<li><code>@EnableJdbcRepositories</code> 创建派生自接口的实现 `Repository``</li>
<li>``AbstractJdbcConfiguration` 提供Spring Data JDBC所需的各种默认bean</li>
<li>创建<code>DataSource</code>与数据库的连接。以下两个bean方法需要这样做。</li>
<li>创建<code>NamedParameterJdbcOperations</code>Spring Data JDBC用于访问数据库的对象。</li>
<li>Spring Data JDBC利用Spring JDBC提供的事务管理。</li>
</ol>
<blockquote>
<p>The configuration class in the preceding example sets up an embedded HSQL database by using the <code>EmbeddedDatabaseBuilder</code> API of <code>spring-jdbc</code>. The <code>DataSource</code> is then used to set up <code>NamedParameterJdbcOperations</code> and a <code>TransactionManager</code>. We finally activate Spring Data JDBC repositories by using the <code>@EnableJdbcRepositories</code>. If no base package is configured, it uses the package in which the configuration class resides. Extending <code>AbstractJdbcConfiguration</code> ensures various beans get registered. Overwriting its methods can be used to customize the setup (see below).</p>
<p>This configuration can be further simplified by using Spring Boot. With Spring Boot a <code>DataSource</code> is sufficient once the starter <code>spring-boot-starter-data-jdbc</code> is included in the dependencies. Everything else is done by Spring Boot.</p>
<p>There are a couple of things one might want to customize in this setup.</p>
</blockquote>
<p>上一示例中的配置类使用的<code>EmbeddedDatabaseBuilder</code>API 设置了嵌入式HSQL数据库<code>spring-jdbc</code>。该<code>DataSource</code>则用来建立<code>NamedParameterJdbcOperations</code>和<code>TransactionManager</code>。最后，我们使用来激活Spring Data JDBC存储库<code>@EnableJdbcRepositories</code>。如果未配置任何基本程序包，它将使用配置类所在的程序包。扩展<code>AbstractJdbcConfiguration</code>可确保各种bean被注册。覆盖其方法可用于自定义设置（请参见下文）。</p>
<p>使用Spring Boot可以进一步简化此配置。对于Spring Boot，一旦依赖项中包含了启动器“ spring-boot-starter-data-jdbc”，则“ DataSource”就足够了。 其他一切都由Spring Boot完成</p>
<p>您可能需要在此设置中自定义几件事。</p>
<h4 id="9-5-1-Dialects"><a href="#9-5-1-Dialects" class="headerlink" title="9.5.1. Dialects"></a>9.5.1. Dialects</h4><blockquote>
<p>Spring Data JDBC uses implementations of the interface <code>Dialect</code> to encapsulate behavior that is specific to a database or its JDBC driver. By default, the <code>AbstractJdbcConfiguration</code> tries to determine the database in use an register the correct <code>Dialect</code>. This behavior can be changed by overwriting <code>jdbcDialect(NamedParameterJdbcOperations)</code>.</p>
<p>If you use a database for which no dialect is available, then your application won’t startup. In that case, you’ll have to ask your vendor to provide a <code>Dialect</code> implementation. Alternatively, you can:</p>
<ol>
<li>Implement your own <code>Dialect</code>.</li>
<li>Implement a <code>JdbcDialectProvider</code> returning the <code>Dialect</code>.</li>
<li>Register the provider by creating a <code>spring.factories</code> resource under <code>META-INF</code> and perform the registration by adding a line<br><code>org.springframework.data.jdbc.repository.config.DialectResolver$JdbcDialectProvider=&lt;fully qualified name of your JdbcDialectProvider&gt;</code></li>
</ol>
</blockquote>
<p>Spring Data JDBC使用接口的实现<code>Dialect</code>来封装特定于数据库或其JDBC驱动程序的行为。默认情况下，<code>AbstractJdbcConfiguration</code>试图确定正在使用的数据库的尝试将注册正确<code>Dialect</code>。可以通过覆盖更改此行为<code>jdbcDialect(NamedParameterJdbcOperations)</code>。</p>
<p>如果您使用的数据库没有方言，则您的应用程序将无法启动。在这种情况下，您必须要求供应商提供<code>Dialect</code>实现。或者，您可以：</p>
<ol>
<li>实现自己的<code>Dialect</code>。</li>
<li>实施<code>JdbcDialectProvider</code>返回<code>Dialect</code>。</li>
<li>通过<code>spring.factories</code>在下面创建资源来注册提供者，<code>META-INF</code>并通过添加一行来执行注册<br><code>org.springframework.data.jdbc.repository.config.DialectResolver$JdbcDialectProvider=&lt;fully qualified name of your JdbcDialectProvider&gt;</code></li>
</ol>
<h3 id="9-6-Persisting-Entities"><a href="#9-6-Persisting-Entities" class="headerlink" title="9.6. Persisting Entities"></a>9.6. Persisting Entities</h3><p><code>持久化实体</code></p>
<p>Saving an aggregate can be performed with the <code>CrudRepository.save(…)</code> method. If the aggregate is new, this results in an insert for the aggregate root, followed by insert statements for all directly or indirectly referenced entities.</p>
<p>If the aggregate root is not new, all referenced entities get deleted, the aggregate root gets updated, and all referenced entities get inserted again. Note that whether an instance is new is part of the instance’s state.</p>
<p>可以使用该<code>CrudRepository.save(…)</code>方法执行保存聚合。如果聚合是新的，则会为聚合根生成一个插入，然后是所有直接或间接引用的实体的插入语句。</p>
<p>如果聚合根不是新的，则将删除所有引用的实体，更新聚合根，并再次插入所有引用的实体。请注意，实例是否为新实例是该实例状态的一部分。</p>
<table>
<thead>
<tr>
<th></th>
<th>This approach has some obvious downsides. If only few of the referenced entities have been actually changed, the deletion and insertion is wasteful. While this process could and probably will be improved, there are certain limitations to what Spring Data JDBC can offer. It does not know the previous state of an aggregate. So any update process always has to take whatever it finds in the database and make sure it converts it to whatever is the state of the entity passed to the save method.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>这种方法有一些明显的缺点。如果实际上仅更改了几个引用实体，则删除和插入是浪费的。尽管可以并且可能会改进此过程，但是Spring Data JDBC可以提供的功能存在某些限制。它不知道聚合的先前状态。因此，任何更新过程都必须在数据库中获取找到所有内容，并确保将其转换为传递给save方法的实体的状态。</td>
</tr>
</tbody></table>
<h4 id="9-6-1-Object-Mapping-Fundamentals"><a href="#9-6-1-Object-Mapping-Fundamentals" class="headerlink" title="9.6.1. Object Mapping Fundamentals"></a>9.6.1. Object Mapping Fundamentals</h4><p>​    <code>对象映射基础</code>    </p>
<blockquote>
<p>This section covers the fundamentals of Spring Data object mapping, object creation, field and property access, mutability and immutability. Note, that this section only applies to Spring Data modules that do not use the object mapping of the underlying data store (like JPA). Also be sure to consult the store-specific sections for store-specific object mapping, like indexes, customizing column or field names or the like.</p>
<p>Core responsibility of the Spring Data object mapping is to create instances of domain objects and map the store-native data structures onto those. This means we need two fundamental steps:</p>
<ol>
<li>Instance creation by using one of the constructors exposed.</li>
<li>Instance population to materialize all exposed properties.</li>
</ol>
</blockquote>
<p>本节介绍了Spring Data对象映射，对象创建，字段和属性访问，可变性和不可变性的基础。请注意，本部分仅适用于不使用基础数据存储（例如JPA）的对象映射的Spring Data模块。另外，请确保参考存储库特定的部分以获取存储库特定的对象映射，例如索引，自定义列或字段名称等。</p>
<p>Spring Data对象映射的核心职责是创建域对象的实例，并将存储本机数据结构映射到这些实例上。这意味着我们需要两个基本步骤：</p>
<ol>
<li>使用公开的构造函数之一创建实例。</li>
<li>实例填充以实现所有暴露的属性。</li>
</ol>
<h5 id="Object-creation"><a href="#Object-creation" class="headerlink" title="Object creation"></a>Object creation</h5><p><code> 对象创建</code></p>
<blockquote>
<p>Spring Data automatically tries to detect a persistent entity’s constructor to be used to materialize objects of that type. The resolution algorithm works as follows:</p>
<ol>
<li>If there’s a no-argument constructor, it will be used. Other constructors will be ignored.</li>
<li>If there’s a single constructor taking arguments, it will be used.</li>
<li>If there are multiple constructors taking arguments, the one to be used by Spring Data will have to be annotated with <code>@PersistenceConstructor</code>.</li>
</ol>
<p>The value resolution assumes constructor argument names to match the property names of the entity, i.e. the resolution will be performed as if the property was to be populated, including all customizations in mapping (different datastore column or field name etc.). This also requires either parameter names information available in the class file or an <code>@ConstructorProperties</code> annotation being present on the constructor.</p>
<p>The value resolution can be customized by using Spring Framework’s <code>@Value</code> value annotation using a store-specific SpEL expression. Please consult the section on store specific mappings for further details.</p>
</blockquote>
<p>Spring Data自动尝试检测要用于实现该类型对象的持久性实体的构造函数。解析算法的工作原理如下：</p>
<ol>
<li>如果有一个无参数的构造函数，则将使用它。其他构造函数将被忽略。</li>
<li>如果只有一个构造函数接受参数，则将使用它。</li>
<li>如果有多个构造函数采用参数，则必须用Spring注释由Spring Data使用的构造函数<code>@PersistenceConstructor</code>。</li>
</ol>
<p>值解析假定构造函数参数名称与实体的属性名称匹配，即，解析将像要填充属性一样执行，包括映射中的所有自定义项（不同的数据存储列或字段名称等）。这还需要类文件中可用的参数名称信息或<code>@ConstructorProperties</code>构造函数上存在的注释。</p>
<p>可以<code>@Value</code>使用特定于存储库的SpEL表达式使用Spring Framework的值注释来自定义值分辨率。请参阅有关存储库特定映射的部分以获取更多详细信息。</p>
<blockquote>
<p>Object creation internals</p>
<p>To avoid the overhead of reflection, Spring Data object creation uses a factory class generated at runtime by default, which will call the domain classes constructor directly. I.e. for this example type:</p>
</blockquote>
<p>创建内部对象</p>
<p>为了避免反射的开销，Spring Data对象的创建使用默认情况下在运行时生成的工厂类，该工厂类将直接调用域类的构造函数。即此示例类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  Person(String firstname, String lastname) &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>we will create a factory class semantically equivalent to this one at runtime:</p>
<p>我们将在运行时创建一个在语义上等效于该类的工厂类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonObjectInstantiator</span> <span class="keyword">implements</span> <span class="title">ObjectInstantiator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">newInstance</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person((String) args[<span class="number">0</span>], (String) args[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This gives us a roundabout 10% performance boost over reflection. For the domain class to be eligible for such optimization, it needs to adhere to a set of constraints:</p>
<ul>
<li>it must not be a private class</li>
<li>it must not be a non-static inner class</li>
<li>it must not be a CGLib proxy class</li>
<li>the constructor to be used by Spring Data must not be private</li>
</ul>
<p>If any of these criteria match, Spring Data will fall back to entity instantiation via reflection.</p>
</blockquote>
<p>与反射相比，这使我们的性能提高了约10％。为了使域类有资格进行此类优化，它需要遵守一组约束：</p>
<ul>
<li>它不能是私有类</li>
<li>它不能是非静态内部类</li>
<li>它不能是CGLib代理类</li>
<li>Spring Data使用的构造函数不能为私有</li>
</ul>
<p>如果这些条件中的任何一个匹配，Spring Data将回退到通过反射实体的实例化。</p>
<h5 id="Property-population"><a href="#Property-population" class="headerlink" title="Property population"></a>Property population</h5><p><code>属性填充器</code></p>
<blockquote>
<p>Once an instance of the entity has been created, Spring Data populates all remaining persistent properties of that class. Unless already populated by the entity’s constructor (i.e. consumed through its constructor argument list), the identifier property will be populated first to allow the resolution of cyclic object references. After that, all non-transient properties that have not already been populated by the constructor are set on the entity instance. For that we use the following algorithm:</p>
<ol>
<li>If the property is immutable but exposes a <code>with…</code> method (see below), we use the <code>with…</code> method to create a new entity instance with the new property value.</li>
<li>If property access (i.e. access through getters and setters) is defined, we’re invoking the setter method.</li>
<li>If the property is mutable we set the field directly.</li>
<li>If the property is immutable we’re using the constructor to be used by persistence operations (see <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#mapping.object-creation">Object creation</a>) to create a copy of the instance.</li>
<li>By default, we set the field value directly.</li>
</ol>
</blockquote>
<p>创建实体的实例后，Spring Data会填充该类的所有剩余持久性属性。除非已由实体的构造函数填充（即通过其构造函数参数列表使用），否则将首先填充identifier属性，以允许解析循环对象引用。之后，在实体实例上设置所有尚未由构造函数填充的非临时属性。为此，我们使用以下算法：</p>
<ol>
<li>如果属性是不可变的，但是公开了一个<code>with…</code>方法（请参见下文），则我们使用该<code>with…</code>方法创建具有新属性值的新实体实例。</li>
<li>如果定义了属性访问（即通过getter和setter的访问），则我们正在调用setter方法。</li>
<li>如果该属性是可变的，则直接设置该字段。</li>
<li>如果属性是不可变的，那么我们将使用持久性操作（请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#mapping.object-creation">Object creation</a>）使用的构造函数来创建实例的副本。</li>
<li>默认情况下，我们直接设置字段值。</li>
</ol>
<p>Property population internals</p>
<p>属性填充器内部</p>
<p>Similarly to our <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#mapping.object-creation.details">optimizations in object construction</a> we also use Spring Data runtime generated accessor classes to interact with the entity instance.</p>
<p>与我们<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#mapping.object-creation.details">在对象构造方面</a>的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#mapping.object-creation.details">优化</a>类似，我们还使用Spring Data运行时生成的访问器类与实体实例进行交互。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String firstname;</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@AccessType(Type.PROPERTY)</span> String lastname;</span><br><span class="line"></span><br><span class="line">  Person() &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person(Long id, String firstname, String lastname) &#123;</span><br><span class="line">    <span class="comment">// Field assignments</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">withId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(id, <span class="keyword">this</span>.firstname, <span class="keyword">this</span>.lastame);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setLastname</span><span class="params">(String lastname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lastname = lastname;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Example 55. A generated Property Accessor</p>
<p><strong>例子55.生成的属性访问器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonPropertyAccessor</span> <span class="keyword">implements</span> <span class="title">PersistentPropertyAccessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodHandle firstname;              </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Person person;                                    </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperty</span><span class="params">(PersistentProperty property, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = property.getName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;firstname&quot;</span>.equals(name)) &#123;</span><br><span class="line">      firstname.invoke(person, (String) value);             </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;id&quot;</span>.equals(name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.person = person.withId((Long) value);            </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;lastname&quot;</span>.equals(name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.person.setLastname((String) value);              </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>PropertyAccessor’s hold a mutable instance of the underlying object. This is, to enable mutations of otherwise immutable properties.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>By default, Spring Data uses field-access to read and write property values. As per visibility rules of <code>private</code> fields, <code>MethodHandles</code> are used to interact with fields.</td>
</tr>
<tr>
<td></td>
<td>The class exposes a <code>withId(…)</code> method that’s used to set the identifier, e.g. when an instance is inserted into the datastore and an identifier has been generated. Calling <code>withId(…)</code> creates a new <code>Person</code> object. All subsequent mutations will take place in the new instance leaving the previous untouched.</td>
</tr>
<tr>
<td></td>
<td>Using property-access allows direct method invocations without using <code>MethodHandles</code>.</td>
</tr>
</tbody></table>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/48ef52501bf042e5a44f90c74bd1df8d-blog-20.jpg" alt="blog-20"></p>
<table>
<thead>
<tr>
<th>1</th>
<th>PropertyAccessor持有基础对象的可变实例。这是为了使原本不可变的属性发生突变。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>默认情况下，Spring Data使用字段访问来读取和写入属性值。根据<code>private</code>字段的可见性规则，<code>MethodHandles</code>用于与字段进行交互。</td>
</tr>
<tr>
<td>3</td>
<td>该类提供了<code>withId(…)</code>一种用于设置标识符的方法，例如，将实例插入数据存储区并且已生成标识符时。调用将<code>withId(…)</code>创建一个新<code>Person</code>对象。所有后续突变都将在新实例中发生，而先前的实例将保持不变。</td>
</tr>
<tr>
<td>4</td>
<td>使用属性访问可以直接调用方法，而无需使用<code>MethodHandles</code>。</td>
</tr>
</tbody></table>
<blockquote>
<p>This gives us a roundabout 25% performance boost over reflection. For the domain class to be eligible for such optimization, it needs to adhere to a set of constraints:</p>
<ul>
<li>Types must not reside in the default or under the <code>java</code> package.</li>
<li>Types and their constructors must be <code>public</code></li>
<li>Types that are inner classes must be <code>static</code>.</li>
<li>The used Java Runtime must allow for declaring classes in the originating <code>ClassLoader</code>. Java 9 and newer impose certain limitations.</li>
</ul>
<p>By default, Spring Data attempts to use generated property accessors and falls back to reflection-based ones if a limitation is detected.</p>
</blockquote>
<p>与反射相比，这使我们的性能提高了约25％。为了使域类有资格进行此类优化，它需要遵守一组约束：</p>
<ul>
<li>类型不得位于默认值或<code>java</code>程序包中。</li>
<li>类型及其构造函数必须为 <code>public</code></li>
<li>内部类的类型必须为<code>static</code>。</li>
<li>使用的Java运行时必须允许在origin中声明类<code>ClassLoader</code>。Java 9和更高版本强加了某些限制。</li>
</ul>
<p>默认情况下，Spring Data尝试使用生成的属性访问器，如果检测到限制，则回退到基于反射的属性访问器。</p>
<p>Let’s have a look at the following entity:</p>
<p>让我们看一下以下实体：</p>
<p>Example 56. A sample entity</p>
<p><strong>例子56.一个样本实体</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Id</span> Long id;                                                </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String firstname, lastname;                                 </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LocalDate birthday;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;                                                    </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String comment;                                                   </span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@AccessType(Type.PROPERTY)</span> String remarks;                        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Person <span class="title">of</span><span class="params">(String firstname, String lastname, LocalDate birthday)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="keyword">null</span>, firstname, lastname, birthday,</span><br><span class="line">      Period.between(birthday, LocalDate.now()).getYears());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person(Long id, String firstname, String lastname, LocalDate birthday, <span class="keyword">int</span> age) &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.firstname = firstname;</span><br><span class="line">    <span class="keyword">this</span>.lastname = lastname;</span><br><span class="line">    <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">withId</span><span class="params">(Long id)</span> </span>&#123;                                                  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(id, <span class="keyword">this</span>.firstname, <span class="keyword">this</span>.lastname, <span class="keyword">this</span>.birthday, <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setRemarks</span><span class="params">(String remarks)</span> </span>&#123;                                         </span><br><span class="line">    <span class="keyword">this</span>.remarks = remarks;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>The identifier property is final but set to <code>null</code> in the constructor. The class exposes a <code>withId(…)</code> method that’s used to set the identifier, e.g. when an instance is inserted into the datastore and an identifier has been generated. The original <code>Person</code> instance stays unchanged as a new one is created. The same pattern is usually applied for other properties that are store managed but might have to be changed for persistence operations. The wither method is optional as the persistence constructor (see 6) is effectively a copy constructor and setting the property will be translated into creating a fresh instance with the new identifier value applied.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>The <code>firstname</code> and <code>lastname</code> properties are ordinary immutable properties potentially exposed through getters.</td>
</tr>
<tr>
<td></td>
<td>The <code>age</code> property is an immutable but derived one from the <code>birthday</code> property. With the design shown, the database value will trump the defaulting as Spring Data uses the only declared constructor. Even if the intent is that the calculation should be preferred, it’s important that this constructor also takes <code>age</code> as parameter (to potentially ignore it) as otherwise the property population step will attempt to set the age field and fail due to it being immutable and no <code>with…</code> method being present.</td>
</tr>
<tr>
<td></td>
<td>The <code>comment</code> property is mutable is populated by setting its field directly.</td>
</tr>
<tr>
<td></td>
<td>The <code>remarks</code> properties are mutable and populated by setting the <code>comment</code> field directly or by invoking the setter method for</td>
</tr>
<tr>
<td></td>
<td>The class exposes a factory method and a constructor for object creation. The core idea here is to use factory methods instead of additional constructors to avoid the need for constructor disambiguation through <code>@PersistenceConstructor</code>. Instead, defaulting of properties is handled within the factory method.</td>
</tr>
</tbody></table>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/36d1f8d68bda42f49b7aa0f359450b92-blog-21.jpg" alt="blog-21"></p>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/27d66dc299a44a7bbd7e78f7f8af2471-blog-22.jpg" alt="blog-22"></p>
<table>
<thead>
<tr>
<th>1</th>
<th>标识符属性是final，但<code>null</code>在构造函数中设置为。该类提供了<code>withId(…)</code>一种用于设置标识符的方法，例如，将实例插入数据存储区并且已生成标识符时。<code>Person</code>创建新实例后，原始实例保持不变。通常将相同的模式应用于由存储管理的其他属性，但可能需要为持久性操作进行更改。wither方法是可选的，因为持久性构造函数（请参见6）实际上是一个副本构造函数，设置该属性将转换为使用新的标识符值创建一个新实例。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>的<code>firstname</code>和<code>lastname</code>特性是通过吸气剂可能暴露普通不可变属性。</td>
</tr>
<tr>
<td>3</td>
<td>该<code>age</code>属性是一个不变的但从该属性派生的<code>birthday</code>属性。按照所示的设计，由于Spring Data使用唯一声明的构造函数，因此数据库值将胜过默认值。即使意图是首选计算，此构造函数也必须将其<code>age</code>用作参数（以可能忽略它），这一点很重要，否则属性填充步骤将尝试设置age字段并由于其不可变且没有<code>with…</code>方法而失败。</td>
</tr>
<tr>
<td>4</td>
<td>该<code>comment</code>属性是可变的，通过直接设置其填充字段。</td>
</tr>
<tr>
<td>5</td>
<td>这些<code>remarks</code>属性是可变的，并且可以通过<code>comment</code>直接设置字段或通过调用setter方法来填充</td>
</tr>
<tr>
<td>6</td>
<td>该类公开用于对象创建的工厂方法和构造函数。这里的核心思想是使用工厂方法而不是其他构造函数，以避免通过进行歧义消除<code>@PersistenceConstructor</code>。相反，属性的默认设置是在工厂方法中处理的。</td>
</tr>
</tbody></table>
<h5 id="General-recommendations"><a href="#General-recommendations" class="headerlink" title="General recommendations"></a>General recommendations</h5><p><code>一般建议</code></p>
<blockquote>
<ul>
<li><em>Try to stick to immutable objects</em> — Immutable objects are straightforward to create as materializing an object is then a matter of calling its constructor only. Also, this avoids your domain objects to be littered with setter methods that allow client code to manipulate the objects state. If you need those, prefer to make them package protected so that they can only be invoked by a limited amount of co-located types. Constructor-only materialization is up to 30% faster than properties population.</li>
<li><em>Provide an all-args constructor</em> — Even if you cannot or don’t want to model your entities as immutable values, there’s still value in providing a constructor that takes all properties of the entity as arguments, including the mutable ones, as this allows the object mapping to skip the property population for optimal performance.</li>
<li><em>Use factory methods instead of overloaded constructors to avoid <code>@PersistenceConstructor</code></em> — With an all-argument constructor needed for optimal performance, we usually want to expose more application use case specific constructors that omit things like auto-generated identifiers etc. It’s an established pattern to rather use static factory methods to expose these variants of the all-args constructor.</li>
<li><em>Make sure you adhere to the constraints that allow the generated instantiator and property accessor classes to be used</em> — </li>
<li><em>For identifiers to be generated, still use a final field in combination with an all-arguments persistence constructor (preferred) or a <code>with…</code> method</em> — </li>
<li><em>Use Lombok to avoid boilerplate code</em> — As persistence operations usually require a constructor taking all arguments, their declaration becomes a tedious repetition of boilerplate parameter to field assignments that can best be avoided by using Lombok’s <code>@AllArgsConstructor</code>.</li>
</ul>
</blockquote>
<ul>
<li><em>尝试坚持不变的对象</em> -不变的对象很容易创建，因为实现一个对象只需要调用其构造函数即可。同样，这避免了用允许客户端代码操纵对象状态的setter方法乱扔您的域对象。如果需要它们，则最好使它们受到程序包保护，以便只能由有限数量的同一位置类型调用它们。仅限构造函数的实现比属性填充快30％。</li>
<li><em>提供一个全参数的构造函数</em> -即使您不能或不希望将实体建模为不可变的值，仍然可以提供一个将实体的所有属性作为参数（包括可变属性）作为参数的构造函数，因为这样做可以对象映射以跳过属性填充以获得最佳性能。</li>
<li><em>使用工厂方法而不是重载的构造函数来避免<code>@PersistenceConstructor</code></em> —为了获得最佳性能，需要使用全参数构造函数，我们通常希望公开更多针对应用程序用例的特定构造函数，这些构造函数会忽略诸如自动生成的标识符等内容。工厂方法公开all-args构造函数的这些变体。</li>
<li><em>确保遵守所有允许使用生成的实例化器和属性访问器类的约束</em> </li>
<li><em>对于要生成的标识符，仍然将final字段与全参数持久性构造函数（首选）或<code>with…</code>方法结合使用</em> - </li>
<li><em>使用Lombok来避免样板代码</em> -由于持久性操作通常需要构造函数接受所有参数，因此它们的声明成为对字段分配的样板参数的繁琐重复，最好使用Lombok来避免<code>@AllArgsConstructor</code>。</li>
</ul>
<h5 id="Kotlin-support"><a href="#Kotlin-support" class="headerlink" title="Kotlin support"></a>Kotlin support</h5><p>Spring Data adapts specifics of Kotlin to allow object creation and mutation.</p>
<h5 id="Kotlin支持"><a href="#Kotlin支持" class="headerlink" title="Kotlin支持"></a>Kotlin支持</h5><p>Spring Data修改了Kotlin的细节以允许对象创建和变异。</p>
<h6 id="Kotlin-object-creation"><a href="#Kotlin-object-creation" class="headerlink" title="Kotlin object creation"></a>Kotlin object creation</h6><p>Kotlin classes are supported to be instantiated , all classes are immutable by default and require explicit property declarations to define mutable properties. Consider the following <code>data</code> class <code>Person</code>:</p>
<h6 id="Kotlin对象创建"><a href="#Kotlin对象创建" class="headerlink" title="Kotlin对象创建"></a>Kotlin对象创建</h6><p>支持实例化Kotlin类，默认情况下所有类都是不可变的，并且需要显式属性声明来定义可变属性。考虑以下<code>data</code>课程<code>Person</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">data class <span class="title">Person</span><span class="params">(val id: String, val name: String)</span></span></span><br></pre></td></tr></table></figure>

<p>The class above compiles to a typical class with an explicit constructor. We can customize this class by adding another constructor and annotate it with <code>@PersistenceConstructor</code> to indicate a constructor preference:</p>
<p>上面的类使用显式构造函数编译为典型类。我们可以通过添加另一个构造函数来自定义此类，并用对其<code>@PersistenceConstructor</code>进行注释以指示构造函数的首选项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">data class <span class="title">Person</span><span class="params">(<span class="keyword">var</span> id: String, val name: String)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceConstructor</span></span><br><span class="line">    constructor(id: String) : <span class="keyword">this</span>(id, <span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin supports parameter optionality by allowing default values to be used if a parameter is not provided. When Spring Data detects a constructor with parameter defaulting, then it leaves these parameters absent if the data store does not provide a value (or simply returns <code>null</code>) so Kotlin can apply parameter defaulting. Consider the following class that applies parameter defaulting for <code>name</code></p>
<p>Kotlin通过允许在未提供参数的情况下使用默认值来支持参数可选性。当Spring Data检测到带有参数默认值的构造函数时，如果数据存储区不提供值（或简单地返回<code>null</code>），它将使这些参数不存在，因此Kotlin可以应用参数默认值。考虑以下将参数默认值应用于<code>name</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">data class <span class="title">Person</span><span class="params">(<span class="keyword">var</span> id: String, val name: String = <span class="string">&quot;unknown&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>Every time the <code>name</code> parameter is either not part of the result or its value is <code>null</code>, then the <code>name</code> defaults to <code>unknown</code>.</p>
<p>每次<code>name</code>参数不是结果的一部分或其值是时<code>null</code>，<code>name</code>默认值为<code>unknown</code>。</p>
<h6 id="Property-population-of-Kotlin-data-classes"><a href="#Property-population-of-Kotlin-data-classes" class="headerlink" title="Property population of Kotlin data classes"></a>Property population of Kotlin data classes</h6><p><strong>Kotlin数据类别的属性填充器</strong></p>
<p>In Kotlin, all classes are immutable by default and require explicit property declarations to define mutable properties. Consider the following <code>data</code> class <code>Person</code>:</p>
<p>在Kotlin中，所有类默认都是不可变的，并且需要显式的属性声明来定义可变属性。考虑以下<code>data Person类</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">data class <span class="title">Person</span><span class="params">(val id: String, val name: String)</span></span></span><br></pre></td></tr></table></figure>

<p>This class is effectively immutable. It allows to create new instances as Kotlin generates a <code>copy(…)</code> method that creates new object instances copying all property values from the existing object and applying property values provided as arguments to the method.</p>
<p>该类实际上是不可变的。当Kotlin生成一种<code>copy(…)</code>方法时，它可以创建新实例，该方法可以创建新对象实例，该对象实例从现有对象复制所有属性值，并将作为参数提供的属性值应用于该方法。</p>
<h4 id="9-6-2-Supported-Types-in-Your-Entity"><a href="#9-6-2-Supported-Types-in-Your-Entity" class="headerlink" title="9.6.2. Supported Types in Your Entity"></a>9.6.2. Supported Types in Your Entity</h4><p><code>实体中支持的类型</code></p>
<p>The properties of the following types are currently supported:</p>
<blockquote>
<ul>
<li><p>All primitive types and their boxed types (<code>int</code>, <code>float</code>, <code>Integer</code>, <code>Float</code>, and so on)</p>
</li>
<li><p>Enums get mapped to their name.</p>
</li>
<li><p><code>String</code></p>
</li>
<li><p><code>java.util.Date</code>, <code>java.time.LocalDate</code>, <code>java.time.LocalDateTime</code>, and <code>java.time.LocalTime</code></p>
</li>
<li><p>Arrays and Collections of the types mentioned above can be mapped to columns of array type if your database supports that.</p>
</li>
<li><p>Anything your database driver accepts.</p>
</li>
</ul>
<p>  当前支持以下类型的属性：</p>
<ul>
<li><p>所有的基本类型和它们的盒装类型（<code>int</code>，<code>float</code>，<code>Integer</code>，<code>Float</code>，等）</p>
</li>
<li><p>枚举被映射到其名称。</p>
</li>
<li><p><code>String</code></p>
</li>
<li><p><code>java.util.Date</code>，<code>java.time.LocalDate</code>，<code>java.time.LocalDateTime</code>，和<code>java.time.LocalTime</code></p>
</li>
<li><p>如果数据库支持，则可以将上述类型的数组和集合映射到数组类型的列。</p>
</li>
<li><p>数据库驱动程序接受的任何内容。</p>
</li>
</ul>
<ul>
<li><p>References to other entities. They are considered a one-to-one relationship, or an embedded type. It is optional for one-to-one relationship entities to have an <code>id</code> attribute. The table of the referenced entity is expected to have an additional column named the same as the table of the referencing entity. You can change this name by implementing <code>NamingStrategy.getReverseColumnName(PersistentPropertyPathExtension path)</code>. Embedded entities do not need an <code>id</code>. If one is present it gets ignored.</p>
</li>
<li><p><code>Set&lt;some entity&gt;</code> is considered a one-to-many relationship. The table of the referenced entity is expected to have an additional column named the same as the table of the referencing entity. You can change this name by implementing <code>NamingStrategy.getReverseColumnName(PersistentPropertyPathExtension path)</code>.</p>
</li>
<li><p><code>Map&lt;simple type, some entity&gt;</code> is considered a qualified one-to-many relationship. The table of the referenced entity is expected to have two additional columns: One named the same as the table of the referencing entity for the foreign key and one with the same name and an additional <code>_key</code> suffix for the map key. You can change this behavior by implementing <code>NamingStrategy.getReverseColumnName(PersistentPropertyPathExtension path)</code> and <code>NamingStrategy.getKeyColumn(RelationalPersistentProperty property)</code>, respectively. Alternatively you may annotate the attribute with <code>@MappedCollection(idColumn=&quot;your_column_name&quot;, keyColumn=&quot;your_key_column_name&quot;)</code></p>
</li>
<li><p><code>List&lt;some entity&gt;</code> is mapped as a <code>Map&lt;Integer, some entity&gt;</code>.</p>
</li>
<li><p>对其他实体的引用。它们被认为是一对一的关系或嵌入式类型。一对一关系实体具有<code>id</code>属性是可选的。所引用实体的表应具有与引用实体表相同名称的附加列。您可以通过实现更改此名称<code>NamingStrategy.getReverseColumnName(PersistentPropertyPathExtension path)</code>。嵌入式实体不需要<code>id</code>。如果存在，它将被忽略。</p>
</li>
<li><p><code>Set&lt;some entity&gt;</code>被认为是一对多的关系。所引用实体的表应具有与引用实体表相同名称的附加列。您可以通过实现更改此名称<code>NamingStrategy.getReverseColumnName(PersistentPropertyPathExtension path)</code>。</p>
</li>
<li><p><code>Map&lt;simple type, some entity&gt;</code>被认为是合适的一对多关系。所引用实体的表应具有两列：一列与外键的引用实体表相同，一列具有相同名称，<code>_key</code>而图键具有后缀。您可以分别实现<code>NamingStrategy.getReverseColumnName(PersistentPropertyPathExtension path)</code>和来更改此行为<code>NamingStrategy.getKeyColumn(RelationalPersistentProperty property)</code>。另外，您也可以使用<code>@MappedCollection(idColumn=&quot;your_column_name&quot;, keyColumn=&quot;your_key_column_name&quot;)</code></p>
</li>
<li><p><code>List&lt;some entity&gt;</code>映射为<code>Map&lt;Integer, some entity&gt;</code>。</p>
</li>
</ul>
</blockquote>
<p>The handling of referenced entities is limited. This is based on the idea of aggregate roots as described above. If you reference another entity, that entity is, by definition, part of your aggregate. So, if you remove the reference, the previously referenced entity gets deleted. This also means references are 1-1 or 1-n, but not n-1 or n-m.</p>
<p>If you have n-1 or n-m references, you are, by definition, dealing with two separate aggregates. References between those should be encoded as simple <code>id</code> values, which should map properly with Spring Data JDBC.</p>
<p>引用实体的处理受到限制。这基于如上所述的聚合根的思想。如果您引用另一个实体，那么根据定义，该实体就是集合的一部分。因此，如果删除引用，则先前引用的实体将被删除。这也意味着引用是1-1或1-n，而不是n-1或nm。</p>
<p>如果您具有n-1或nm引用，那么根据定义，您将处理两个单独的聚合。它们之间的引用应编码为简单<code>id</code>值，应与Spring Data JDBC正确映射。</p>
<h4 id="9-6-3-Custom-converters"><a href="#9-6-3-Custom-converters" class="headerlink" title="9.6.3. Custom converters"></a>9.6.3. Custom converters</h4><p><code>定制转换器</code></p>
<p>Custom converters can be registered, for types that are not supported by default, by inheriting your configuration from <code>AbstractJdbcConfiguration</code> and overwriting the method <code>jdbcCustomConversions()</code>.</p>
<p>通过从中继承配置<code>AbstractJdbcConfiguration</code>并覆盖method ，可以为默认情况下不支持的类型注册自定义转换器<code>jdbcCustomConversions()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataJdbcConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractJdbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcCustomConversions <span class="title">jdbcCustomConversions</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JdbcCustomConversions(Collections.singletonList(TimestampTzToDateConverter.INSTANCE));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ReadingConverter</span></span><br><span class="line">    <span class="keyword">enum</span> TimestampTzToDateConverter implements Converter&lt;TIMESTAMPTZ, Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(TIMESTAMPTZ source)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The constructor of <code>JdbcCustomConversions</code> accepts a list of <code>org.springframework.core.convert.converter.Converter</code>.</p>
<p>Converters should be annotated with <code>@ReadingConverter</code> or <code>@WritingConverter</code> in order to control their applicability to only reading from or to writing to the database.</p>
<p><code>TIMESTAMPTZ</code> in the example is a database specific data type that needs conversion into something more suitable for a domain model.</p>
<p><code>JdbcCustomConversions</code>的构造函数接受的列表<code>org.springframework.core.convert.converter.Converter</code>。</p>
<p>转换器应带有<code>@ReadingConverter</code>或注释，<code>@WritingConverter</code>以便控制其适用性，使其仅适用于读取或写入数据库。</p>
<p><code>TIMESTAMPTZ</code> 在该示例中，是特定于数据库的数据类型，需要将其转换为更适合域模型的数据。</p>
<h5 id="JdbcValue"><a href="#JdbcValue" class="headerlink" title="JdbcValue"></a>JdbcValue</h5><p>Value conversion uses <code>JdbcValue</code> to enrich values propagated to JDBC operations with a <code>java.sql.Types</code> type. Register a custom write converter if you need to specify a JDBC-specific type instead of using type derivation. This converter should convert the value to <code>JdbcValue</code> which has a field for the value and for the actual <code>JDBCType</code>.</p>
<p>值转换使用<code>JdbcValue</code>一种<code>java.sql.Types</code>类型来丰富传播到JDBC操作的值。如果需要指定特定于JDBC的类型而不是使用类型派生，请注册自定义写转换器。此转换器应将value 转换为<code>JdbcValue</code>，<code>JdbcValue</code>其中具有一个用于表示值和实际值的字段<code>JDBCType</code>。</p>
<h4 id="9-6-4-NamingStrategy"><a href="#9-6-4-NamingStrategy" class="headerlink" title="9.6.4. NamingStrategy"></a>9.6.4. <code>NamingStrategy</code></h4><p>When you use the standard implementations of <code>CrudRepository</code> that Spring Data JDBC provides, they expect a certain table structure. You can tweak that by providing a <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/NamingStrategy.html"><code>NamingStrategy</code></a> in your application context.</p>
<p>当您使用<code>CrudRepository</code>Spring Data JDBC提供的标准实现时，它们期望某种表结构。您可以通过<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/NamingStrategy.html"><code>NamingStrategy</code></a>在应用程序上下文中提供来进行调整。</p>
<h4 id="9-6-5-Custom-table-names"><a href="#9-6-5-Custom-table-names" class="headerlink" title="9.6.5. Custom table names"></a>9.6.5. <code>Custom table names</code></h4><p>When the NamingStrategy does not matching on your database table names, you can customize the names with the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/Table.html"><code>@Table</code></a> annotation. The element <code>value</code> of this annotation provides the custom table name. The following example maps the <code>MyEntity</code> class to the <code>CUSTOM_TABLE_NAME</code> table in the database:</p>
<p>当NamingStrategy与数据库表名称不匹配时，可以使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/Table.html"><code>@Table</code></a>批注自定义名称。<code>value</code>此批注的元素提供自定义表名称。下面的示例将<code>MyEntity</code>类映射到<code>CUSTOM_TABLE_NAME</code>数据库中的表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table(&quot;CUSTOM_TABLE_NAME&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEntity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    Integer id;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-6-6-Custom-column-names"><a href="#9-6-6-Custom-column-names" class="headerlink" title="9.6.6. Custom column names"></a>9.6.6. <code>Custom column names</code></h4><p>When the NamingStrategy does not matching on your database column names, you can customize the names with the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/Column.html"><code>@Column</code></a> annotation. The element <code>value</code> of this annotation provides the custom column name. The following example maps the <code>name</code> property of the <code>MyEntity</code> class to the <code>CUSTOM_COLUMN_NAME</code> column in the database:</p>
<p>当NamingStrategy与数据库列名称不匹配时，可以使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/Column.html"><code>@Column</code></a>批注自定义名称。<code>value</code>此批注的元素提供自定义列名称。下面的示例将类的<code>name</code>属性映射<code>MyEntity</code>到<code>CUSTOM_COLUMN_NAME</code>数据库中的列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEntity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(&quot;CUSTOM_COLUMN_NAME&quot;)</span></span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/MappedCollection.html"><code>@MappedCollection</code></a> annotation can be used on a reference type (one-to-one relationship) or on Sets, Lists, and Maps (one-to-many relationship). <code>idColumn</code> element of the annotation provides a custom name for the foreign key column referencing the id column in the other table. In the following example the corresponding table for the <code>MySubEntity</code> class has a <code>NAME</code> column, and the <code>CUSTOM_MY_ENTITY_ID_COLUMN_NAME</code> column of the <code>MyEntity</code> id for relationship reasons:</p>
<p>该<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/MappedCollection.html"><code>@MappedCollection</code></a> 注释可以对引用类型（一对一的关系）或集合，列表被使用，并且图（一个一对多关系）。 <code>idColumn</code>注释的元素为外键列提供了自定义名称，该外键列引用了另一个表中的id列。在以下示例中，<code>MySubEntity</code>类的对应表具有一<code>NAME</code>列，而出于关系原因<code>CUSTOM_MY_ENTITY_ID_COLUMN_NAME</code>，<code>MyEntity</code>id 的列也具有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEntity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MappedCollection(idColumn = &quot;CUSTOM_MY_ENTITY_ID_COLUMN_NAME&quot;)</span></span><br><span class="line">    Set&lt;MySubEntity&gt; subEntities;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySubEntity</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When using <code>List</code> and <code>Map</code> you must have an additional column for the position of a dataset in the <code>List</code> or the key value of the entity in the <code>Map</code>. This additional column name may be customized with the <code>keyColumn</code> Element of the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/MappedCollection.html"><code>@MappedCollection</code></a> annotation:</p>
<p>当使用<code>List</code>和<code>Map</code>时，必须有一个额外的列，用于数据集在List中的位置或实体在Map中的键值。。可以使用注释<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/MappedCollection.html"><code>@MappedCollection</code></a>的<code>keyColumn</code>元素自定义此附加列名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEntity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MappedCollection(idColumn = &quot;CUSTOM_COLUMN_NAME&quot;, keyColumn = &quot;CUSTOM_KEY_COLUMN_NAME&quot;)</span></span><br><span class="line">    List&lt;MySubEntity&gt; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySubEntity</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-6-7-Embedded-entities"><a href="#9-6-7-Embedded-entities" class="headerlink" title="9.6.7. Embedded entities"></a>9.6.7. Embedded entities</h4><p><code>嵌入式实体</code></p>
<blockquote>
<p>Embedded entities are used to have value objects in your java data model, even if there is only one table in your database. In the following example you see, that <code>MyEntity</code> is mapped with the <code>@Embedded</code> annotation. The consequence of this is, that in the database a table <code>my_entity</code> with the two columns <code>id</code> and <code>name</code> (from the <code>EmbeddedEntity</code> class) is expected.</p>
<p>However, if the <code>name</code> column is actually <code>null</code> within the result set, the entire property <code>embeddedEntity</code> will be set to null according to the <code>onEmpty</code> of <code>@Embedded</code>, which <code>null</code>s objects when all nested properties are <code>null</code>.<br>Opposite to this behavior <code>USE_EMPTY</code> tries to create a new instance using either a default constructor or one that accepts nullable parameter values from the result set.</p>
</blockquote>
<p>即使数据库中只有一个表，嵌入式实体也通常在Java数据模型中具有值对象。在下面的示例中，您将看到它<code>MyEntity</code>与<code>@Embedded</code>注释映射。这样做的后果是，在数据库中的表<code>my_entity</code>有<code>id</code>，和<code>name</code>（从<code>EmbeddedEntity</code>类）两列的预期。</p>
<p>但是，如果结果集中的name列实际上为null，当所有嵌套时为null的对象 属性也为null 则根据@Embedded的onEmpty，将整个属性embeddedEntity设置为null。 与该行为相反，尝试使用默认构造函数或从结果集中接受可为空的参数值的实例创建新实例。<code>null``null</code><br><code>USE_EMPTY</code></p>
<p>Example 57. Sample Code of embedding objects</p>
<p><strong>例子57.嵌入对象的示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embedded(onEmpty = USE_NULL)</span> </span><br><span class="line">    EmbeddedEntity embeddedEntity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedEntity</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th><code>Null</code>s <code>embeddedEntity</code> if <code>name</code> in <code>null</code>. Use <code>USE_EMPTY</code> to instantiate <code>embeddedEntity</code> with a potential <code>null</code> value for the <code>name</code> property.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>如果<code>null</code>s<code>embeddedEntity</code>中的<code>name</code>是<code>null</code>。 使用“ USE_EMPTY”实例化“ embeddedEntity”，并将“ name”属性的潜在值设置为“ null”。</td>
</tr>
</tbody></table>
<p><img src="http://my-blog-to-test.oss-cn-beijing.aliyuncs.com/test/2020-08-21/efa52b2beabb481f9cb069e1471615e7-blog-23.jpg" alt="blog-23"></p>
<p>If you need a value object multiple times in an entity, this can be achieved with the optional <code>prefix</code> element of the <code>@Embedded</code> annotation. This element represents a prefix and is prepend for each column name in the embedded object.</p>
<p>如果实体中需要多次使用值对象，则可以通过注释的可选<code>prefix</code>元素来实现<code>@Embedded</code>。此元素表示前缀，并且在嵌入式对象中的每个列名称之前。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embedded</span>.Nullable </span><br><span class="line">    EmbeddedEntity embeddedEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>利用快捷键<code>@Embedded.Nullable</code>和<code>@Embedded.Empty</code>用于<code>@Embedded(onEmpty = USE_NULL)</code>和<code>@Embedded(onEmpty = USE_EMPTY)</code>减少冗长并同时设置相应的JSR-305 <code>@javax.annotation.Nonnull</code>。</td>
</tr>
</tbody></table>
<p><img src="C:\Users\Cheri_Du\Desktop\blog-24.jpg" alt="blog-24"></p>
<p>Embedded entities containing a <code>Collection</code> or a <code>Map</code> will always be considered non empty since they will at least contain the empty collection or map. Such an entity will therefore never be <code>null</code> even when using @Embedded(onEmpty = USE_NULL).</p>
<p>包含<code>Collection</code>或嵌入式实体<code>Map</code>将始终被视为非空的，因为它们至少包含空的集合或映射。因此，<code>null</code>即使使用@Embedded（onEmpty = USE_NULL），此类实体也永远不会消失。</p>
<h4 id="9-6-8-Entity-State-Detection-Strategies"><a href="#9-6-8-Entity-State-Detection-Strategies" class="headerlink" title="9.6.8. Entity State Detection Strategies"></a>9.6.8. Entity State Detection Strategies</h4><p><code>实体状态检测策略</code></p>
<p>The following table describes the strategies that Spring Data JDBC offers for detecting whether an entity is new:</p>
<p>下表描述了Spring Data JDBC提供的用于检测实体是否为新实体的策略：</p>
<table>
<thead>
<tr>
<th>Id-Property inspection (the default)</th>
<th>By default, Spring Data JDBC inspects the identifier property of the given entity. If the identifier property is <code>null</code>, then the entity is assumed to be new. Otherwise, it is assumed to not be new.</th>
</tr>
</thead>
<tbody><tr>
<td>Implementing <code>Persistable</code></td>
<td>If an entity implements <code>Persistable</code>, Spring Data JDBC delegates the new detection to the <code>isNew(…)</code> method of the entity. See the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/data-commons/docs/current/api/index.html?org/springframework/data/domain/Persistable.html">Javadoc</a> for details.</td>
</tr>
<tr>
<td>Implementing <code>EntityInformation</code></td>
<td>You can customize the <code>EntityInformation</code> abstraction used in the <code>SimpleJdbcRepository</code> implementation by creating a subclass of <code>JdbcRepositoryFactory</code> and overriding the <code>getEntityInformation(…)</code> method. You then have to register the custom implementation of <code>JdbcRepositoryFactory</code> as a Spring bean. Note that this should rarely be necessary. See the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/jdbc/repository/support/JdbcRepositoryFactory.html">Javadoc</a> for details.</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>身份检查（默认）</th>
<th>默认情况下，Spring Data JDBC检查给定实体的标识符属性。如果identifier属性为<code>null</code>，则假定该实体为新实体。否则，假定它不是新的。</th>
</tr>
</thead>
<tbody><tr>
<td>实施中 <code>Persistable</code></td>
<td>如果一个实体实现<code>Persistable</code>，Spring Data JDBC将新的检测委托给<code>isNew(…)</code>该实体的方法。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/data-commons/docs/current/api/index.html?org/springframework/data/domain/Persistable.html">Javadoc</a>。</td>
</tr>
<tr>
<td>实施中 <code>EntityInformation</code></td>
<td>您可以通过创建方法的子类并覆盖该方法来定制实现中<code>EntityInformation</code>使用的抽象。然后，您必须将的自定义实现注册为Spring bean。请注意，这几乎没有必要。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/jdbc/repository/support/JdbcRepositoryFactory.html">Javadoc</a>。<code>SimpleJdbcRepository``JdbcRepositoryFactory``getEntityInformation(…)``JdbcRepositoryFactory</code></td>
</tr>
</tbody></table>
<h4 id="9-6-9-ID-Generation"><a href="#9-6-9-ID-Generation" class="headerlink" title="9.6.9. ID Generation"></a>9.6.9. ID Generation</h4><p><code>ID生成</code></p>
<p>Spring Data JDBC uses the ID to identify entities. The ID of an entity must be annotated with Spring Data’s <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/annotation/Id.html"><code>@Id</code></a> annotation.</p>
<p>When your data base has an auto-increment column for the ID column, the generated value gets set in the entity after inserting it into the database.</p>
<p>One important constraint is that, after saving an entity, the entity must not be new any more. Note that whether an entity is new is part of the entity’s state. With auto-increment columns, this happens automatically, because the ID gets set by Spring Data with the value from the ID column. If you are not using auto-increment columns, you can use a <code>BeforeSave</code> listener, which sets the ID of the entity (covered later in this document).</p>
<p>Spring Data JDBC使用该ID来标识实体。实体的ID必须使用Spring Data的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/annotation/Id.html"><code>@Id</code></a>注释进行注释。</p>
<p>当数据库的ID列具有自动递增列时，将生成的值插入到数据库中后即可在实体中设置该值。</p>
<p>一个重要的约束条件是，在保存实体之后，该实体就不能再是新的。请注意，实体是否为新实体是该实体状态的一部分。对于自动增量列，这是自动发生的，因为Spring会使用ID列中的值来设置ID。如果不使用自动增量列，则可以使用<code>BeforeSave</code>侦听器，该侦听器设置实体的ID（在本文档的后面介绍）。</p>
<h4 id="9-6-10-Optimistic-Locking"><a href="#9-6-10-Optimistic-Locking" class="headerlink" title="9.6.10. Optimistic Locking"></a>9.6.10. Optimistic Locking</h4><p><code>乐观锁</code></p>
<p>Spring Data JDBC supports optimistic locking by means of a numeric attribute that is annotated with <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/annotation/Version.html"><code>@Version</code></a> on the aggregate root. Whenever Spring Data JDBC saves an aggregate with such a version attribute two things happen: The update statement for the aggregate root will contain a where clause checking that the version stored in the database is actually unchanged. If this isn’t the case an <code>OptimisticLockingFailureException</code> will be thrown. Also the version attribute gets increased both in the entity and in the database so a concurrent action will notice the change and throw an <code>OptimisticLockingFailureException</code> if applicable as described above.</p>
<p>This process also applies to inserting new aggregates, where a <code>null</code> or <code>0</code> version indicates a new instance and the increased instance afterwards marks the instance as not new anymore, making this work rather nicely with cases where the id is generated during object construction for example when UUIDs are used.</p>
<p>During deletes the version check also applies but no version is increased.</p>
<p>Spring Data JDBC通过<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/annotation/Version.html"><code>@Version</code></a>在聚合根上注释的数字属性来支持乐观锁定 。每当Spring Data JDBC用这样的version属性保存一个聚合时，就会发生两件事：聚合根的update语句将包含一个where子句，以检查存储在数据库中的版本实际上没有更改。如果不是这种情况，<code>OptimisticLockingFailureException</code>将抛出。同样，实体和数据库中的版本属性都会增加，因此并发操作将注意到该更改并引发一个<code>OptimisticLockingFailureException</code>适用的更改（如上所述）。</p>
<p>此过程也适用于插入新的聚合，其中a <code>null</code>或<code>0</code>version表示一个新实例，之后增加的实例会将该实例标记为不再是新实例，这使得它在对象构造期间生成id的情况下（例如当UUID为用过的。</p>
<p>在删除期间，版本检查也适用，但是没有增加版本。</p>
<h3 id="9-7-Query-Methods"><a href="#9-7-Query-Methods" class="headerlink" title="9.7. Query Methods"></a>9.7. Query Methods</h3><p><code>查询方法</code></p>
<p>This section offers some specific information about the implementation and use of Spring Data JDBC.</p>
<p>Most of the data access operations you usually trigger on a repository result in a query being run against the databases. Defining such a query is a matter of declaring a method on the repository interface, as the following example shows:</p>
<p>本节提供有关Spring Data JDBC的实现和使用的一些特定信息。</p>
<p>通常在存储库上触发的大多数数据访问操作都会导致对数据库运行查询。定义此类查询只需在存储库接口上声明一个方法即可，如以下示例所示：</p>
<p>Example 58. PersonRepository with query methods</p>
<p><strong>例子58.使用查询方法的PersonRepository</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">Person</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByFirstname</span><span class="params">(String firstname)</span></span>;                                   </span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByFirstnameOrderByLastname</span><span class="params">(String firstname, Pageable pageable)</span></span>; </span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">findByFirstnameAndLastname</span><span class="params">(String firstname, String lastname)</span></span>;             </span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">findFirstByLastname</span><span class="params">(String lastname)</span></span>;                                      </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;SELECT * FROM person WHERE lastname = :lastname&quot;)</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;                                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>The method shows a query for all people with the given <code>lastname</code>. The query is derived by parsing the method name for constraints that can be concatenated with <code>And</code> and <code>Or</code>. Thus, the method name results in a query expression of <code>SELECT … FROM person WHERE firstname = :firstname</code>.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Use <code>Pageable</code> to pass offset and sorting parameters to the database.</td>
</tr>
<tr>
<td></td>
<td>Find a single entity for the given criteria. It completes with <code>IncorrectResultSizeDataAccessException</code> on non-unique results.</td>
</tr>
<tr>
<td></td>
<td>In contrast to &lt;3&gt;, the first entity is always emitted even if the query yields more result documents.</td>
</tr>
<tr>
<td></td>
<td>The <code>findByLastname</code> method shows a query for all people with the given last name.</td>
</tr>
</tbody></table>
<p><img src="C:\Users\Cheri_Du\Desktop\blog-25.jpg" alt="blog-25"></p>
<table>
<thead>
<tr>
<th>1</th>
<th>该方法显示了针对具有的所有人员的查询<code>lastname</code>。该查询是通过分析方法名称来获得可以与<code>And</code>和串联的约束的<code>Or</code>。因此，方法名称导致查询表达式为<code>SELECT … FROM person WHERE firstname = :firstname</code>。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>使用<code>Pageable</code>来抵消和排序参数传递到数据库。</td>
</tr>
<tr>
<td>3</td>
<td>为给定条件找到一个实体。它以<code>IncorrectResultSizeDataAccessException</code>非唯一结果完成。</td>
</tr>
<tr>
<td>4</td>
<td>与&lt;3&gt;相比，即使查询产生更多的结果文档，也会始终发出第一个实体。</td>
</tr>
<tr>
<td>5</td>
<td>该<code>findByLastname</code>方法显示一个查询所有具有给定姓氏的人。</td>
</tr>
</tbody></table>
<p>The following table shows the keywords that are supported for query methods:</p>
<p>下表显示了查询方法支持的关键字：</p>
<table>
<thead>
<tr>
<th align="left">Keyword</th>
<th align="left">Sample</th>
<th align="left">Logical result</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>After</code></td>
<td align="left"><code>findByBirthdateAfter(Date date)</code></td>
<td align="left"><code>birthdate &gt; date</code></td>
</tr>
<tr>
<td align="left"><code>GreaterThan</code></td>
<td align="left"><code>findByAgeGreaterThan(int age)</code></td>
<td align="left"><code>age &gt; age</code></td>
</tr>
<tr>
<td align="left"><code>GreaterThanEqual</code></td>
<td align="left"><code>findByAgeGreaterThanEqual(int age)</code></td>
<td align="left"><code>age &gt;= age</code></td>
</tr>
<tr>
<td align="left"><code>Before</code></td>
<td align="left"><code>findByBirthdateBefore(Date date)</code></td>
<td align="left"><code>birthdate &lt; date</code></td>
</tr>
<tr>
<td align="left"><code>LessThan</code></td>
<td align="left"><code>findByAgeLessThan(int age)</code></td>
<td align="left"><code>age &lt; age</code></td>
</tr>
<tr>
<td align="left"><code>LessThanEqual</code></td>
<td align="left"><code>findByAgeLessThanEqual(int age)</code></td>
<td align="left"><code>age ⇐ age</code></td>
</tr>
<tr>
<td align="left"><code>Between</code></td>
<td align="left"><code>findByAgeBetween(int from, int to)</code></td>
<td align="left"><code>age BETWEEN from AND to</code></td>
</tr>
<tr>
<td align="left"><code>NotBetween</code></td>
<td align="left"><code>findByAgeBetween(int from, int to)</code></td>
<td align="left"><code>age NOT BETWEEN from AND to</code></td>
</tr>
<tr>
<td align="left"><code>In</code></td>
<td align="left"><code>findByAgeIn(Collection&lt;Integer&gt; ages)</code></td>
<td align="left"><code>age IN (age1, age2, ageN)</code></td>
</tr>
<tr>
<td align="left"><code>NotIn</code></td>
<td align="left"><code>findByAgeNotIn(Collection ages)</code></td>
<td align="left"><code>age NOT IN (age1, age2, ageN)</code></td>
</tr>
<tr>
<td align="left"><code>IsNotNull</code>, <code>NotNull</code></td>
<td align="left"><code>findByFirstnameNotNull()</code></td>
<td align="left"><code>firstname IS NOT NULL</code></td>
</tr>
<tr>
<td align="left"><code>IsNull</code>, <code>Null</code></td>
<td align="left"><code>findByFirstnameNull()</code></td>
<td align="left"><code>firstname IS NULL</code></td>
</tr>
<tr>
<td align="left"><code>Like</code>, <code>StartingWith</code>, <code>EndingWith</code></td>
<td align="left"><code>findByFirstnameLike(String name)</code></td>
<td align="left"><code>firstname LIKE name</code></td>
</tr>
<tr>
<td align="left"><code>NotLike</code>, <code>IsNotLike</code></td>
<td align="left"><code>findByFirstnameNotLike(String name)</code></td>
<td align="left"><code>firstname NOT LIKE name</code></td>
</tr>
<tr>
<td align="left"><code>Containing</code> on String</td>
<td align="left"><code>findByFirstnameContaining(String name)</code></td>
<td align="left"><code>firstname LIKE &#39;%&#39; name +&#39;%&#39;</code></td>
</tr>
<tr>
<td align="left"><code>NotContaining</code> on String</td>
<td align="left"><code>findByFirstnameNotContaining(String name)</code></td>
<td align="left"><code>firstname NOT LIKE &#39;%&#39; name +&#39;%&#39;</code></td>
</tr>
<tr>
<td align="left"><code>(No keyword)</code></td>
<td align="left"><code>findByFirstname(String name)</code></td>
<td align="left"><code>firstname = name</code></td>
</tr>
<tr>
<td align="left"><code>Not</code></td>
<td align="left"><code>findByFirstnameNot(String name)</code></td>
<td align="left"><code>firstname != name</code></td>
</tr>
<tr>
<td align="left"><code>IsTrue</code>, <code>True</code></td>
<td align="left"><code>findByActiveIsTrue()</code></td>
<td align="left"><code>active IS TRUE</code></td>
</tr>
<tr>
<td align="left"><code>IsFalse</code>, <code>False</code></td>
<td align="left"><code>findByActiveIsFalse()</code></td>
<td align="left"><code>active IS FALSE</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>Query derivation is limited to properties that can be used in a <code>WHERE</code> clause without using joins.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>查询推导仅限于可在<code>WHERE</code>子句中使用而无需使用联接的属性。</td>
</tr>
</tbody></table>
<h4 id="9-7-1-Query-Lookup-Strategies"><a href="#9-7-1-Query-Lookup-Strategies" class="headerlink" title="9.7.1. Query Lookup Strategies"></a>9.7.1. Query Lookup Strategies</h4><p><code>查询查询策略</code></p>
<p>The JDBC module supports defining a query manually as a String in a <code>@Query</code> annotation or as named query in a property file. Deriving a query from the name of the method is currently not supported.</p>
<p>JDBC模块支持手动将查询定义为<code>@Query</code>注释中的字符串或属性文件中的命名查询。当前不支持从方法名称派生查询。</p>
<h4 id="9-7-2-Using-Query"><a href="#9-7-2-Using-Query" class="headerlink" title="9.7.2. Using @Query"></a>9.7.2. Using <code>@Query</code></h4><p>The following example shows how to use <code>@Query</code> to declare a query method:</p>
<p>下面的示例演示如何使用<code>@Query</code>声明查询方法：</p>
<p>Example 59. Declare a query method by using @Query</p>
<p><strong>例子59.使用@Query声明一个查询方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select firstName, lastName from User u where u.emailAddress = :email&quot;)</span></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(<span class="meta">@Param(&quot;email&quot;)</span> String email)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>For converting the query result into entities the same <code>RowMapper</code> is used by default as for the queries Spring Data JDBC generates itself. The query you provide must match the format the <code>RowMapper</code> expects. Columns for all properties that are used in the constructor of an entity must be provided. Columns for properties that get set via setter, wither or field access are optional. Properties that don’t have a matching column in the result will not be set. The query is used for populating the aggregate root, embedded entities and one-to-one relationships including arrays of primitive types which get stored and loaded as SQL-array-types. Separate queries are generated for maps, lists, sets and arrays of entities.</p>
</blockquote>
<p>为了将查询结果转换为实体<code>RowMapper</code>，默认情况下使用与Spring Data JDBC生成的查询相同的实体。您提供的查询必须与<code>RowMapper</code>期望的格式匹配。必须提供在实体的构造函数中使用的所有属性的列。通过setter，wither或field访问设置的属性列是可选的。结果中没有匹配列的属性将不会被设置。该查询用于填充聚集的根，嵌入式实体和一对一关系，包括原始类型的数组，这些原始类型的数组作为SQL数组类型存储和加载。针对实体的maps，列表，集合和数组生成单独的查询。</p>
<table>
<thead>
<tr>
<th></th>
<th>Spring fully supports Java 8’s parameter name discovery based on the <code>-parameters</code> compiler flag. By using this flag in your build as an alternative to debug information, you can omit the <code>@Param</code> annotation for named parameters.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Spring完全基于<code>-parameters</code>编译器标志支持Java 8的参数名称发现。通过在构建中使用此标志作为调试信息的替代方法，可以省略<code>@Param</code>命名参数的注释。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>Spring Data JDBC supports only named parameters.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Spring Data JDBC仅支持命名参数。</td>
</tr>
</tbody></table>
<h4 id="9-7-3-Named-Queries"><a href="#9-7-3-Named-Queries" class="headerlink" title="9.7.3. Named Queries"></a>9.7.3. Named Queries</h4><p><code>命名查询</code></p>
<p>If no query is given in an annotation as described in the previous section Spring Data JDBC will try to locate a named query. There are two ways how the name of the query can be determined. The default is to take the <em>domain class</em> of the query, i.e. the aggregate root of the repository, take its simple name and append the name of the method separated by a <code>.</code>. Alternatively the <code>@Query</code> annotation has a <code>name</code> attribute which can be used to specify the name of a query to be looked up.</p>
<p>如果没有如上一节中所述在注释中给出查询，Spring Data JDBC将尝试查找命名查询。有两种方法可以确定查询名称。默认值是采用查询的<em>域类</em>，即存储库的聚合根，采用其简单名称，并附加以分隔的方法名称<code>.</code>。或者，<code>@Query</code>注释具有<code>name</code>可用于指定要查找的查询的名称的属性。</p>
<p>Named queries are expected to be provided in the property file <code>META-INF/jdbc-named-queries.properties</code> on the classpath.</p>
<p>预期将在<code>META-INF/jdbc-named-queries.properties</code>类路径的属性文件中提供命名查询。</p>
<p>The location of that file may be changed by setting a value to <code>@EnableJdbcRepositories.namedQueriesLocation</code>.</p>
<p>可以通过设置<code>@EnableJdbcRepositories.namedQueriesLocation</code>的value 来更改该文件的位置。</p>
<h5 id="Custom-RowMapper"><a href="#Custom-RowMapper" class="headerlink" title="Custom RowMapper"></a>Custom <code>RowMapper</code></h5><p><code>自定义RowMapper</code></p>
<p>You can configure which <code>RowMapper</code> to use, either by using the <code>@Query(rowMapperClass = ….)</code> or by registering a <code>RowMapperMap</code> bean and registering a <code>RowMapper</code> per method return type. The following example shows how to register <code>DefaultQueryMappingConfiguration</code>:</p>
<p>您可以配置<code>RowMapper</code>使用<code>@Query(rowMapperClass = ….)</code>或通过注册<code>RowMapperMap</code>Bean并注册<code>RowMapper</code>每个方法的返回类型来配置要使用的类型。以下示例显示了如何注册<code>DefaultQueryMappingConfiguration</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">QueryMappingConfiguration <span class="title">rowMappers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultQueryMappingConfiguration()</span><br><span class="line">    .register(Person.class, <span class="keyword">new</span> PersonRowMapper())</span><br><span class="line">    .register(Address.class, <span class="keyword">new</span> AddressRowMapper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>When determining which <code>RowMapper</code> to use for a method, the following steps are followed, based on the return type of the method:</p>
<ol>
<li><p>If the type is a simple type, no <code>RowMapper</code> is used.</p>
<p>Instead, the query is expected to return a single row with a single column, and a conversion to the return type is applied to that value.</p>
</li>
<li><p>The entity classes in the <code>QueryMappingConfiguration</code> are iterated until one is found that is a superclass or interface of the return type in question. The <code>RowMapper</code> registered for that class is used.</p>
<p>Iterating happens in the order of registration, so make sure to register more general types after specific ones.</p>
</li>
</ol>
<p>If applicable, wrapper types such as collections or <code>Optional</code> are unwrapped. Thus, a return type of <code>Optional&lt;Person&gt;</code> uses the <code>Person</code> type in the preceding process.</p>
</blockquote>
<p>在确定<code>RowMapper</code>要使用哪种方法时，根据方法的返回类型，执行以下步骤：</p>
<ol>
<li><p>如果类型是简单类型，<code>RowMapper</code>则不使用 。</p>
<p>取而代之的是，查询应返回具有单列的单行，并将对该返回类型的转换应用于该值。</p>
</li>
<li><p><code>QueryMappingConfiguration</code>迭代中的实体类，直到找到一个是所讨论的返回类型的超类或接口。使用<code>RowMapper</code>该类别的注册者。</p>
<p>迭代按注册顺序进行，因此请确保在特定类型之后注册更多通用类型。</p>
</li>
</ol>
<p>如果适用，则包装类型（例如集合）或未包装类型<code>Optional</code>。那么，在前面的过程中返回类型的<code>Optional&lt;Person&gt;</code>使用<code>Person</code></p>
<table>
<thead>
<tr>
<th></th>
<th>Using a custom <code>RowMapper</code> through <code>QueryMappingConfiguration</code>, <code>@Query(rowMapperClass=…)</code>, or a custom <code>ResultSetExtractor</code> disables Entity Callbacks and Lifecycle Events as the result mapping can issue its own events/callbacks if needed.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>RowMapper</code>通过<code>QueryMappingConfiguration</code>，<code>@Query(rowMapperClass=…)</code>或自定义 使用自定义项<code>ResultSetExtractor</code>将禁用实体回调和生命周期事件，因为如果需要，结果映射可以发出自己的事件/回调。</td>
</tr>
</tbody></table>
<h5 id="Modifying-Query"><a href="#Modifying-Query" class="headerlink" title="Modifying Query"></a>Modifying Query</h5><p><code>修改查询</code></p>
<p>You can mark a query as being a modifying query by using the <code>@Modifying</code> on query method, as the following example shows:</p>
<p>您可以使用<code>@Modifying</code>on query方法将查询标记为修改查询，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query(&quot;UPDATE DUMMYENTITY SET name = :name WHERE id = :id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateName</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>You can specify the following return types:</p>
<ul>
<li><code>void</code></li>
<li><code>int</code> (updated record count)</li>
<li><code>boolean</code>(whether a record was updated)</li>
</ul>
</blockquote>
<p>您可以指定以下返回类型：</p>
<ul>
<li><code>void</code></li>
<li><code>int</code> （更新的记录数）</li>
<li><code>boolean</code>（记录是否已更新）</li>
</ul>
<h3 id="9-8-MyBatis-Integration"><a href="#9-8-MyBatis-Integration" class="headerlink" title="9.8. MyBatis Integration"></a>9.8. MyBatis Integration</h3><p><code>MyBatis整合</code></p>
<p>The CRUD operations and query methods can be delegated to MyBatis. This section describes how to configure Spring Data JDBC to integrate with MyBatis and which conventions to follow to hand over the running of the queries as well as the mapping to the library.</p>
<p>可以将CRUD操作和查询方法委托给MyBatis。本节描述如何配置Spring Data JDBC与MyBatis集成，以及遵循哪些约定来移交查询的运行以及到库的映射。</p>
<h4 id="9-8-1-Configuration"><a href="#9-8-1-Configuration" class="headerlink" title="9.8.1. Configuration"></a>9.8.1. Configuration</h4><p><code>配置</code></p>
<p>The easiest way to properly plug MyBatis into Spring Data JDBC is by importing <code>MyBatisJdbcConfiguration</code> into you application configuration:</p>
<p>将MyBatis正确插入Spring Data JDBC的最简单方法是导入<code>MyBatisJdbcConfiguration</code>应用程序配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJdbcRepositories</span></span><br><span class="line"><span class="meta">@Import(MyBatisJdbcConfiguration.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function">SqlSessionFactoryBean <span class="title">sqlSessionFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Configure MyBatis here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, all you need to declare is a <code>SqlSessionFactoryBean</code> as <code>MyBatisJdbcConfiguration</code> relies on a <code>SqlSession</code> bean to be available in the <code>ApplicationContext</code> eventually.</p>
<p>如您所见，您只需声明一个“SqlSessionFactoryBean”，因为“MyBatisJdbcConfiguration”最终依赖于“ApplicationContext”中可用的“SqlSession”bean。</p>
<h4 id="9-8-2-Usage-conventions"><a href="#9-8-2-Usage-conventions" class="headerlink" title="9.8.2. Usage conventions"></a>9.8.2. Usage conventions</h4><p><code>使用约定</code></p>
<blockquote>
<p>For each operation in <code>CrudRepository</code>, Spring Data JDBC runs multiple statements. If there is a <a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3/blob/master/src/main/java/org/apache/ibatis/session/SqlSessionFactory.java"><code>SqlSessionFactory</code></a> in the application context, Spring Data checks, for each step, whether the <code>SessionFactory</code> offers a statement. If one is found, that statement (including its configured mapping to an entity) is used.</p>
<p>The name of the statement is constructed by concatenating the fully qualified name of the entity type with <code>Mapper.</code> and a <code>String</code> determining the kind of statement. For example, if an instance of <code>org.example.User</code> is to be inserted, Spring Data JDBC looks for a statement named <code>org.example.UserMapper.insert</code>.</p>
<p>When the statement is run, an instance of [<code>MyBatisContext</code>] gets passed as an argument, which makes various arguments available to the statement.</p>
<p>The following table describes the available MyBatis statements:</p>
</blockquote>
<p>对于中的每个操作<code>CrudRepository</code>，Spring Data JDBC运行多个语句。如果<a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3/blob/master/src/main/java/org/apache/ibatis/session/SqlSessionFactory.java"><code>SqlSessionFactory</code></a>应用程序上下文中存在，Spring Data会针对每个步骤检查是否<code>SessionFactory</code>提供了一条语句。如果找到一个，则使用该语句（包括其配置的到实体的映射）。</p>
<p>语句的名称是通过将实体类型的标准名称与<code>Mapper.</code>和<code>String</code>确定语句的类型进行连接而构造的。例如，如果<code>org.example.User</code>要插入的实例，Spring Data JDBC将查找名<code>org.example.UserMapper.insert</code>为的语句。</p>
<p>语句运行时，[ <code>MyBatisContext</code>] 的实例作为参数传递，这使该语句可以使用各种参数。</p>
<p>下表描述了可用的MyBatis语句：</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Purpose</th>
<th align="left">CrudRepository methods that might trigger this statement</th>
<th align="left">Attributes available in the <code>MyBatisContext</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>insert</code></td>
<td align="left">Inserts a single entity. This also applies for entities referenced by the aggregate root.</td>
<td align="left"><code>save</code>, <code>saveAll</code>.</td>
<td align="left"><code>getInstance</code>: the instance to be saved<code>getDomainType</code>: The type of the entity to be saved.<code>get(&lt;key&gt;)</code>: ID of the referencing entity, where <code>&lt;key&gt;</code> is the name of the back reference column provided by the <code>NamingStrategy</code>.</td>
</tr>
<tr>
<td align="left"><code>update</code></td>
<td align="left">Updates a single entity. This also applies for entities referenced by the aggregate root.</td>
<td align="left"><code>save</code>, <code>saveAll</code>.</td>
<td align="left"><code>getInstance</code>: The instance to be saved<code>getDomainType</code>: The type of the entity to be saved.</td>
</tr>
<tr>
<td align="left"><code>delete</code></td>
<td align="left">Deletes a single entity.</td>
<td align="left"><code>delete</code>, <code>deleteById</code>.</td>
<td align="left"><code>getId</code>: The ID of the instance to be deleted<code>getDomainType</code>: The type of the entity to be deleted.</td>
</tr>
<tr>
<td align="left"><code>deleteAll-&lt;propertyPath&gt;</code></td>
<td align="left">Deletes all entities referenced by any aggregate root of the type used as prefix with the given property path. Note that the type used for prefixing the statement name is the name of the aggregate root, not the one of the entity to be deleted.</td>
<td align="left"><code>deleteAll</code>.</td>
<td align="left"><code>getDomainType</code>: The types of the entities to be deleted.</td>
</tr>
<tr>
<td align="left"><code>deleteAll</code></td>
<td align="left">Deletes all aggregate roots of the type used as the prefix</td>
<td align="left"><code>deleteAll</code>.</td>
<td align="left"><code>getDomainType</code>: The type of the entities to be deleted.</td>
</tr>
<tr>
<td align="left"><code>delete-&lt;propertyPath&gt;</code></td>
<td align="left">Deletes all entities referenced by an aggregate root with the given propertyPath</td>
<td align="left"><code>deleteById</code>.</td>
<td align="left"><code>getId</code>: The ID of the aggregate root for which referenced entities are to be deleted.<code>getDomainType</code>: The type of the entities to be deleted.</td>
</tr>
<tr>
<td align="left"><code>findById</code></td>
<td align="left">Selects an aggregate root by ID</td>
<td align="left"><code>findById</code>.</td>
<td align="left"><code>getId</code>: The ID of the entity to load.<code>getDomainType</code>: The type of the entity to load.</td>
</tr>
<tr>
<td align="left"><code>findAll</code></td>
<td align="left">Select all aggregate roots</td>
<td align="left"><code>findAll</code>.</td>
<td align="left"><code>getDomainType</code>: The type of the entity to load.</td>
</tr>
<tr>
<td align="left"><code>findAllById</code></td>
<td align="left">Select a set of aggregate roots by ID values</td>
<td align="left"><code>findAllById</code>.</td>
<td align="left"><code>getId</code>: A list of ID values of the entities to load.<code>getDomainType</code>: The type of the entity to load.</td>
</tr>
<tr>
<td align="left"><code>findAllByProperty-&lt;propertyName&gt;</code></td>
<td align="left">Select a set of entities that is referenced by another entity. The type of the referencing entity is used for the prefix. The referenced entities type is used as the suffix. <em>This method is deprecated. Use <code>findAllByPath</code> instead</em></td>
<td align="left">All <code>find*</code> methods. If no query is defined for <code>findAllByPath</code></td>
<td align="left"><code>getId</code>: The ID of the entity referencing the entities to be loaded.<code>getDomainType</code>: The type of the entity to load.</td>
</tr>
<tr>
<td align="left"><code>findAllByPath-&lt;propertyPath&gt;</code></td>
<td align="left">Select a set of entities that is referenced by another entity via a property path.</td>
<td align="left">All <code>find*</code> methods.</td>
<td align="left"><code>getIdentifier</code>: The <code>Identifier</code> holding the id of the aggregate root plus the keys and list indexes of all path elements.<code>getDomainType</code>: The type of the entity to load.</td>
</tr>
<tr>
<td align="left"><code>findAllSorted</code></td>
<td align="left">Select all aggregate roots, sorted</td>
<td align="left"><code>findAll(Sort)</code>.</td>
<td align="left"><code>getSort</code>: The sorting specification.</td>
</tr>
<tr>
<td align="left"><code>findAllPaged</code></td>
<td align="left">Select a page of aggregate roots, optionally sorted</td>
<td align="left"><code>findAll(Page)</code>.</td>
<td align="left"><code>getPageable</code>: The paging specification.</td>
</tr>
<tr>
<td align="left"><code>count</code></td>
<td align="left">Count the number of aggregate root of the type used as prefix</td>
<td align="left"><code>count</code></td>
<td align="left"><code>getDomainType</code>: The type of aggregate roots to count.</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">目的</th>
<th align="left">可能触发此语句的CrudRepository方法</th>
<th align="left">可用属性 <code>MyBatisContext</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>insert</code></td>
<td align="left">插入单个实体。这也适用于由聚合根引用的实体。</td>
<td align="left"><code>save</code>，<code>saveAll</code>。</td>
<td align="left"><code>getInstance</code>：要保存的实例<code>getDomainType</code>：要保存的实体的类型。<code>get(&lt;key&gt;)</code>：引用实体的ID，其中<code>&lt;key&gt;</code>是所提供的反向引用列的名称<code>NamingStrategy</code>。</td>
</tr>
<tr>
<td align="left"><code>update</code></td>
<td align="left">更新单个实体。这也适用于由聚合根引用的实体。</td>
<td align="left"><code>save</code>，<code>saveAll</code>。</td>
<td align="left"><code>getInstance</code>：要保存的实例<code>getDomainType</code>：要保存的实体的类型。</td>
</tr>
<tr>
<td align="left"><code>delete</code></td>
<td align="left">删除单个实体。</td>
<td align="left"><code>delete</code>，<code>deleteById</code>。</td>
<td align="left"><code>getId</code>：要删除的实例的ID<code>getDomainType</code>：要删除的实体的类型。</td>
</tr>
<tr>
<td align="left"><code>deleteAll-&lt;propertyPath&gt;</code></td>
<td align="left">删除由任何类型的聚合根引用的所有实体，该类型的根用作给定属性路径的前缀。请注意，为语句名称加上前缀的类型是聚合根的名称，而不是要删除的实体之一。</td>
<td align="left"><code>deleteAll</code>。</td>
<td align="left"><code>getDomainType</code>：要删除的实体的类型。</td>
</tr>
<tr>
<td align="left"><code>deleteAll</code></td>
<td align="left">删除用作前缀的类型的所有聚合根</td>
<td align="left"><code>deleteAll</code>。</td>
<td align="left"><code>getDomainType</code>：要删除的实体的类型。</td>
</tr>
<tr>
<td align="left"><code>delete-&lt;propertyPath&gt;</code></td>
<td align="left">删除具有给定propertyPath的聚合根引用的所有实体</td>
<td align="left"><code>deleteById</code>。</td>
<td align="left"><code>getId</code>：要删除其引用实体的聚合根的ID。<code>getDomainType</code>：要删除的实体的类型。</td>
</tr>
<tr>
<td align="left"><code>findById</code></td>
<td align="left">通过ID选择聚合根</td>
<td align="left"><code>findById</code>。</td>
<td align="left"><code>getId</code>：要加载的实体的ID。<code>getDomainType</code>：要加载的实体的类型。</td>
</tr>
<tr>
<td align="left"><code>findAll</code></td>
<td align="left">选择所有聚合根</td>
<td align="left"><code>findAll</code>。</td>
<td align="left"><code>getDomainType</code>：要加载的实体的类型。</td>
</tr>
<tr>
<td align="left"><code>findAllById</code></td>
<td align="left">通过ID值选择一组聚合根</td>
<td align="left"><code>findAllById</code>。</td>
<td align="left"><code>getId</code>：要加载的实体的ID值列表。<code>getDomainType</code>：要加载的实体的类型。</td>
</tr>
<tr>
<td align="left"><code>findAllByProperty-&lt;propertyName&gt;</code></td>
<td align="left">选择另一个实体引用的一组实体。引用实体的类型用于前缀。引用的实体类型用作后缀。<em>不建议使用此方法。使用<code>findAllByPath</code>替代</em></td>
<td align="left">所有<code>find*</code>方法。如果没有定义查询<code>findAllByPath</code></td>
<td align="left"><code>getId</code>：引用要加载的实体的实体的ID。<code>getDomainType</code>：要加载的实体的类型。</td>
</tr>
<tr>
<td align="left"><code>findAllByPath-&lt;propertyPath&gt;</code></td>
<td align="left">选择一组其他实体通过属性路径引用的实体。</td>
<td align="left">所有<code>find*</code>方法。</td>
<td align="left"><code>getIdentifier</code>：<code>Identifier</code>包含聚合根的ID以及所有路径元素的键和列表索引。<code>getDomainType</code>：要加载的实体的类型。</td>
</tr>
<tr>
<td align="left"><code>findAllSorted</code></td>
<td align="left">选择所有聚合根，排序</td>
<td align="left"><code>findAll(Sort)</code>。</td>
<td align="left"><code>getSort</code>：排序规范。</td>
</tr>
<tr>
<td align="left"><code>findAllPaged</code></td>
<td align="left">选择聚合根的页面，可以选择排序</td>
<td align="left"><code>findAll(Page)</code>。</td>
<td align="left"><code>getPageable</code>：分页规范。</td>
</tr>
<tr>
<td align="left"><code>count</code></td>
<td align="left">计算用作前缀的类型的聚合根的数量</td>
<td align="left"><code>count</code></td>
<td align="left"><code>getDomainType</code>：要计数的聚合根的类</td>
</tr>
</tbody></table>
<h3 id="9-9-Lifecycle-Events"><a href="#9-9-Lifecycle-Events" class="headerlink" title="9.9. Lifecycle Events"></a>9.9. Lifecycle Events</h3><p><code>生命周期事件</code></p>
<p>Spring Data JDBC triggers events that get published to any matching <code>ApplicationListener</code> beans in the application context. For example, the following listener gets invoked before an aggregate gets saved:</p>
<p>Spring Data JDBC触发事件，这些事件将发布到<code>ApplicationListener</code>应用程序上下文中的任何匹配bean。例如，在保存聚合之前，将调用以下侦听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ApplicationListener&lt;BeforeSaveEvent&lt;Object&gt;&gt; loggingSaves() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> event -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        Object entity = event.getEntity();</span><br><span class="line">        LOG.info(<span class="string">&quot;&#123;&#125; is getting saved.&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you want to handle events only for a specific domain type you may derive your listener from <code>AbstractRelationalEventListener</code> and overwrite one or more of the <code>onXXX</code> methods, where <code>XXX</code> stands for an event type. Callback methods will only get invoked for events related to the domain type and their subtypes so you don’t require further casting.</p>
<p>如果您只想处理特定域类型的事件，则可以从侦听器派生<code>AbstractRelationalEventListener</code>并覆盖一个或多个<code>onXXX</code>方法（其中<code>XXX</code>的一种表示事件类型）。回调方法将仅针对与域类型及其子类型相关的事件被调用，因此您不需要进一步的转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonLoadListener</span> <span class="keyword">extends</span> <span class="title">AbstractRelationalEventListener</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAfterLoad</span><span class="params">(AfterLoadEvent&lt;Person&gt; personLoad)</span> </span>&#123;</span><br><span class="line">        LOG.info(personLoad.getEntity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The following table describes the available events:</p>
<p>下表描述了可用事件：</p>
<table>
<thead>
<tr>
<th align="left">Event</th>
<th align="left">When It Is Published</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/BeforeDeleteEvent.html"><code>BeforeDeleteEvent</code></a></td>
<td align="left">Before an aggregate root gets deleted.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/AfterDeleteEvent.html"><code>AfterDeleteEvent</code></a></td>
<td align="left">After an aggregate root gets deleted.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api//org/springframework/data/relational/core/mapping/event/BeforeConvertEvent.html"><code>BeforeConvertEvent</code></a></td>
<td align="left">Before an aggregate root gets saved (that is, inserted or updated but after the decision about whether if it gets updated or deleted was made).</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api//org/springframework/data/relational/core/mapping/event/BeforeSaveEvent.html"><code>BeforeSaveEvent</code></a></td>
<td align="left">Before an aggregate root gets saved (that is, inserted or updated but after the decision about whether if it gets updated or deleted was made).</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/AfterSaveEvent.html"><code>AfterSaveEvent</code></a></td>
<td align="left">After an aggregate root gets saved (that is, inserted or updated).</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/AfterLoadEvent.html"><code>AfterLoadEvent</code></a></td>
<td align="left">After an aggregate root gets created from a database <code>ResultSet</code> and all its properties get set.</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>Lifecycle events depend on an <code>ApplicationEventMulticaster</code>, which in case of the <code>SimpleApplicationEventMulticaster</code> can be configured with a <code>TaskExecutor</code>, and therefore gives no guarantees when an Event is processed.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>生命周期事件依赖于“ApplicationEventMulticaster”，如果是“SimpleApplicationEventMulticaster”，则可以使用“TaskExecutor”配置该实例，因此不保证处理事件的时间。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">何时触发</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/BeforeDeleteEvent.html"><code>BeforeDeleteEvent</code></a></td>
<td align="left">在删除聚合根之前。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/AfterDeleteEvent.html"><code>AfterDeleteEvent</code></a></td>
<td align="left">删除聚合根之后。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api//org/springframework/data/relational/core/mapping/event/BeforeConvertEvent.html"><code>BeforeConvertEvent</code></a></td>
<td align="left">在保存聚合根之前（即，插入或更新根之前，但在决定是否更新或删除聚合根之前）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api//org/springframework/data/relational/core/mapping/event/BeforeSaveEvent.html"><code>BeforeSaveEvent</code></a></td>
<td align="left">在保存聚合根之前（即，插入或更新根之前，但在决定是否更新或删除聚合根之前）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/AfterSaveEvent.html"><code>AfterSaveEvent</code></a></td>
<td align="left">保存聚合根后（即插入或更新）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/AfterLoadEvent.html"><code>AfterLoadEvent</code></a></td>
<td align="left">从数据库创建聚合根<code>ResultSet</code>并设置其所有属性后。</td>
</tr>
</tbody></table>
<h3 id="9-10-Entity-Callbacks"><a href="#9-10-Entity-Callbacks" class="headerlink" title="9.10. Entity Callbacks"></a>9.10. Entity Callbacks</h3><p><code>实体回调</code></p>
<blockquote>
<p>The Spring Data infrastructure provides hooks for modifying an entity before and after certain methods are invoked. Those so called <code>EntityCallback</code> instances provide a convenient way to check and potentially modify an entity in a callback fashioned style.<br>An <code>EntityCallback</code> looks pretty much like a specialized <code>ApplicationListener</code>. Some Spring Data modules publish store specific events (such as <code>BeforeSaveEvent</code>) that allow modifying the given entity. In some cases, such as when working with immutable types, these events can cause trouble. Also, event publishing relies on <code>ApplicationEventMulticaster</code>. If configuring that with an asynchronous <code>TaskExecutor</code> it can lead to unpredictable outcomes, as event processing can be forked onto a Thread.</p>
</blockquote>
<p>Spring Data基础结构提供了用于在调用某些方法之前和之后修改实体的钩子。这些所谓的<code>EntityCallback</code>实例提供了一种方便的方式，可以以回调方式检查和潜在地修改实体。<br>一个<code>EntityCallback</code>看起来很像一个专门的<code>ApplicationListener</code>。一些Spring Data模块发布存储特定事件（例如<code>BeforeSaveEvent</code>），以允许修改给定实体。在某些情况下，例如使用不可变类型时，这些事件可能会引起麻烦。此外，事件发布还依赖<code>ApplicationEventMulticaster</code>。如果使用异步配置它，<code>TaskExecutor</code>则可能导致不可预测的结果，因为事件处理可以分叉到线程上。</p>
<p>Entity callbacks provide integration points with both synchronous and reactive APIs to guarantee in-order execution at well-defined checkpoints within the processing chain, returning a potentially modified entity or an reactive wrapper type.</p>
<p>Entity callbacks are typically separated by API type. This separation means that a synchronous API considers only synchronous entity callbacks and a reactive implementation considers only reactive entity callbacks.</p>
<p>实体回调提供同步和反应式API的集成点，以确保在处理链中定义明确的检查点处按顺序执行，返回可能修改的实体或反应式包装器类型。</p>
<p>实体回调通常按API类型分开。这种分离意味着同步API仅考虑同步实体回调，而反应式实现仅考虑反应实体回调。</p>
<table>
<thead>
<tr>
<th></th>
<th>The Entity Callback API has been introduced with Spring Data Commons 2.2. It is the recommended way of applying entity modifications. Existing store specific <code>ApplicationEvents</code> are still published <strong>before</strong> the invoking potentially registered <code>EntityCallback</code> instances.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>实体回调API已随Spring Data Commons 2.2引入。这是应用实体修改的推荐方法。在调用可能已注册的<code>EntityCallback</code>实例<strong>之前</strong>，特定于现有存储库的信息<code>ApplicationEvents</code>仍会发布。</td>
</tr>
</tbody></table>
<h4 id="9-10-1-Implementing-Entity-Callbacks"><a href="#9-10-1-Implementing-Entity-Callbacks" class="headerlink" title="9.10.1. Implementing Entity Callbacks"></a>9.10.1. Implementing Entity Callbacks</h4><p><code>实现类实体回调</code></p>
<p>An <code>EntityCallback</code> is directly associated with its domain type through its generic type argument. Each Spring Data module typically ships with a set of predefined <code>EntityCallback</code> interfaces covering the entity lifecycle.</p>
<p>An <code>EntityCallback</code>通过其泛型类型参数直接与其域类型相关联。每个Spring Data模块通常附带一组<code>EntityCallback</code>涵盖实体生命周期的预定义接口。</p>
<p>Example 60. Anatomy of an <code>EntityCallback</code></p>
<p>例子60.解析<code>EntityCallback</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeforeSaveCallback</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">EntityCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entity callback method invoked before a domain object is saved.</span></span><br><span class="line"><span class="comment">     * Can return either the same or a modified instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the domain object to be persisted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">onBeforeSave</span><span class="params">(T entity &lt;<span class="number">2</span>&gt;, String collection &lt;<span class="number">3</span>&gt;)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th><code>BeforeSaveCallback</code> specific method to be called before an entity is saved. Returns a potentially modifed instance.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>The entity right before persisting.</td>
</tr>
<tr>
<td></td>
<td>A number of store specific arguments like the <em>collection</em> the entity is persisted to.</td>
</tr>
</tbody></table>
<p><img src="C:\Users\Cheri_Du\Desktop\blog-26.jpg" alt="blog-26"></p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>BeforeSaveCallback</code>保存实体之前要调用的特定方法。返回一个可能被修改的实例。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>实体在保存之前。</td>
</tr>
<tr>
<td>3</td>
<td>许多存储库特定的参数，例如实体持久化的<em>集合</em>。</td>
</tr>
</tbody></table>
<p>Example 61. Anatomy of a reactive <code>EntityCallback</code></p>
<p>实施例61.反应物的解析<code>EntityCallback</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReactiveBeforeSaveCallback</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">EntityCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entity callback method invoked on subscription, before a domain object is saved.</span></span><br><span class="line"><span class="comment">     * The returned Publisher can emit either the same or a modified instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Publisher emitting the domain object to be persisted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Publisher&lt;T&gt; <span class="title">onBeforeSave</span><span class="params">(T entity &lt;<span class="number">2</span>&gt;, String collection &lt;<span class="number">3</span>&gt;)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th><code>BeforeSaveCallback</code> specific method to be called on subscription, before an entity is saved. Emits a potentially modifed instance.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>The entity right before persisting.</td>
</tr>
<tr>
<td></td>
<td>A number of store specific arguments like the <em>collection</em> the entity is persisted to.</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>Optional entity callback parameters are defined by the implementing Spring Data module and inferred from call site of <code>EntityCallback.callback()</code>.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>可选的实体回调参数由实施中的Spring Data模块定义，并从调用的站点推断出<code>EntityCallback.callback()</code>。</td>
</tr>
</tbody></table>
<p><img src="C:\Users\Cheri_Du\Desktop\blog-27.jpg" alt="blog-27"></p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>BeforeSaveCallback</code>保存实体之前在订阅上调用的特定方法。发出可能已修改的实例。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>实体在保存之前。</td>
</tr>
<tr>
<td>3</td>
<td>许多存储库特定的参数，例如实体持久化的<em>集合</em>。</td>
</tr>
</tbody></table>
<p>Implement the interface suiting your application needs like shown in the example below:</p>
<p>实现适合您的应用程序需求的接口，如下例所示</p>
<p>Example 62. Example <code>BeforeSaveCallback</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultingEntityCallback</span> <span class="keyword">implements</span> <span class="title">BeforeSaveCallback</span>&lt;<span class="title">Person</span>&gt;, <span class="title">Ordered</span> </span>&#123;      </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">onBeforeSave</span><span class="params">(Person entity, String collection)</span> </span>&#123;                   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(collection == <span class="string">&quot;user&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;                                                                  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>Callback implementation according to your requirements.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Potentially order the entity callback if multiple ones for the same domain type exist. Ordering follows lowest precedence.</td>
</tr>
</tbody></table>
<p><img src="C:\Users\Cheri_Du\Desktop\blog-28.jpg" alt="blog-28"></p>
<table>
<thead>
<tr>
<th>1</th>
<th>根据您的要求实现回调。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>如果存在相同域类型的多个实体回调，则可能对实体回调进行排序。排序遵循最低优先级。</td>
</tr>
</tbody></table>
<h4 id="9-10-2-Registering-Entity-Callbacks"><a href="#9-10-2-Registering-Entity-Callbacks" class="headerlink" title="9.10.2. Registering Entity Callbacks"></a>9.10.2. Registering Entity Callbacks</h4><p><code>注册实体回调</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityCallback&#96; beans are picked up by the store specific implementations in case they are registered in the &#96;ApplicationContext&#96;. Most template APIs already implement &#96;ApplicationContextAware&#96; and therefore have access to the &#96;ApplicationContext</span><br></pre></td></tr></table></figure>

<p>The following example explains a collection of valid entity callback registrations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityCallback&#96; bean由特定于存储库的实现来获取，以防它们在“ApplicationContext”中注册。大多数模板API已经实现&#96;ApplicationContextAware&#96;，因此有权访问“ApplicationContext”</span><br></pre></td></tr></table></figure>

<p>以下示例说明了有效的实体回调注册的集合：</p>
<p>Example 63. Example <code>EntityCallback</code> Bean registration</p>
<p><code>EntityCallback</code>Bean注册</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span>                                                           </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">First</span> <span class="keyword">implements</span> <span class="title">BeforeSaveCallback</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">onBeforeSave</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultingEntityCallback</span> <span class="keyword">implements</span> <span class="title">BeforeSaveCallback</span>&lt;<span class="title">Person</span>&gt;,</span></span><br><span class="line"><span class="class">                                                           <span class="title">Ordered</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">onBeforeSave</span><span class="params">(Person entity, String collection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;                                                  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityCallbackConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">BeforeSaveCallback&lt;Person&gt; <span class="title">unorderedLambdaReceiverCallback</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> (BeforeSaveCallback&lt;Person&gt;) it -&gt; <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCallbacks</span> <span class="keyword">implements</span> <span class="title">BeforeConvertCallback</span>&lt;<span class="title">User</span>&gt;,</span></span><br><span class="line"><span class="class">                                        <span class="title">BeforeSaveCallback</span>&lt;<span class="title">User</span>&gt; </span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">onBeforeConvert</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">onBeforeSave</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th><code>BeforeSaveCallback</code> receiving its order from the <code>@Order</code> annotation.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>BeforeSaveCallback</code> receiving its order via the <code>Ordered</code> interface implementation.</td>
</tr>
<tr>
<td></td>
<td><code>BeforeSaveCallback</code> using a lambda expression. Unordered by default and invoked last. Note that callbacks implemented by a lambda expression do not expose typing information hence invoking these with a non-assignable entity affects the callback throughput. Use a <code>class</code> or <code>enum</code> to enable type filtering for the callback bean.</td>
</tr>
<tr>
<td></td>
<td>Combine multiple entity callback interfaces in a single implementation class.</td>
</tr>
</tbody></table>
<p><img src="C:\Users\Cheri_Du\Desktop\blog-29.jpg" alt="blog-29"></p>
<p><img src="C:\Users\Cheri_Du\Desktop\blog-30.jpg" alt="blog-30"></p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>BeforeSaveCallback</code>从<code>@Order</code>注释中接收其顺序。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><code>BeforeSaveCallback</code>通过<code>Ordered</code>接口实现接收顺序。</td>
</tr>
<tr>
<td>3</td>
<td><code>BeforeSaveCallback</code>使用lambda表达式。默认情况下无序，最后调用。请注意，由lambda表达式实现的回调不会公开类型信息，因此使用不可分配的实体调用这些信息会影响回调吞吐量。使用<code>class</code>或<code>enum</code>来为回调bean启用类型过滤。</td>
</tr>
<tr>
<td>4</td>
<td>在单个实现类中组合多个实体回调接口。</td>
</tr>
</tbody></table>
<h4 id="9-10-3-Store-specific-EntityCallbacks"><a href="#9-10-3-Store-specific-EntityCallbacks" class="headerlink" title="9.10.3. Store-specific EntityCallbacks"></a>9.10.3. Store-specific EntityCallbacks</h4><p><code>特定于存储库的EntityCallbacks</code></p>
<p>Spring Data JDBC uses the <code>EntityCallback</code> API for its auditing support and reacts on the following callbacks:</p>
<p>Spring Data JDBC使用该<code>EntityCallback</code>API进行审核，并对以下回调做出反应：</p>
<table>
<thead>
<tr>
<th align="left"><code>EntityCallback</code></th>
<th align="left">When It Is Published</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/BeforeDeleteCallback.html"><code>BeforeDeleteCallback</code></a></td>
<td align="left">Before an aggregate root gets deleted.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/AfterDeleteCallback.html"><code>AfterDeleteCallback</code></a></td>
<td align="left">After an aggregate root gets deleted.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api//org/springframework/data/relational/core/mapping/event/BeforeConvertCallback.html"><code>BeforeConvertCallback</code></a></td>
<td align="left">Before an aggregate root gets saved (that is, inserted or updated but after the decision about whether if it gets updated or deleted was made).</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api//org/springframework/data/relational/core/mapping/event/BeforeSaveCallback.html"><code>BeforeSaveCallback</code></a></td>
<td align="left">Before an aggregate root gets saved (that is, inserted or updated but after the decision about whether if it gets updated or deleted was made).</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/AfterSaveCallback.html"><code>AfterSaveCallback</code></a></td>
<td align="left">After an aggregate root gets saved (that is, inserted or updated).</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/AfterLoadCallback.html"><code>AfterLoadCallback</code></a></td>
<td align="left">After an aggregate root gets created from a database <code>ResultSet</code> and all its property get set.</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"><code>EntityCallback</code></th>
<th align="left">何时出版</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/BeforeDeleteCallback.html"><code>BeforeDeleteCallback</code></a></td>
<td align="left">在删除聚合根之前。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/AfterDeleteCallback.html"><code>AfterDeleteCallback</code></a></td>
<td align="left">删除聚合根之后。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api//org/springframework/data/relational/core/mapping/event/BeforeConvertCallback.html"><code>BeforeConvertCallback</code></a></td>
<td align="left">在保存聚合根之前（即，插入或更新根之前，但在决定是否更新或删除聚合根之前）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api//org/springframework/data/relational/core/mapping/event/BeforeSaveCallback.html"><code>BeforeSaveCallback</code></a></td>
<td align="left">在保存聚合根之前（即，插入或更新根之前，但在决定是否更新或删除聚合根之前）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/AfterSaveCallback.html"><code>AfterSaveCallback</code></a></td>
<td align="left">保存聚合根后（即插入或更新）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/relational/core/mapping/event/AfterLoadCallback.html"><code>AfterLoadCallback</code></a></td>
<td align="left">从数据库创建聚合根<code>ResultSet</code>并设置其所有属性后。</td>
</tr>
</tbody></table>
<h3 id="9-11-Custom-Conversions"><a href="#9-11-Custom-Conversions" class="headerlink" title="9.11. Custom Conversions"></a>9.11. Custom Conversions</h3><p><code>自定义转化</code></p>
<p>Spring Data JDBC allows registration of custom converters to influence how values are mapped in the database. Currently, converters are only applied on property-level.</p>
<p>Spring Data JDBC允许注册自定义转换器，以影响在数据库中映射值的方式。当前，转换器仅应用于属性级别。</p>
<h4 id="9-11-1-Writing-a-Property-by-Using-a-Registered-Spring-Converter"><a href="#9-11-1-Writing-a-Property-by-Using-a-Registered-Spring-Converter" class="headerlink" title="9.11.1. Writing a Property by Using a Registered Spring Converter"></a>9.11.1. Writing a Property by Using a Registered Spring Converter</h4><p>​    <code>使用注册的Spring转换器编写属性</code></p>
<p>The following example shows an implementation of a <code>Converter</code> that converts from a <code>Boolean</code> object to a <code>String</code> value:</p>
<p>以下示例显示了<code>Converter</code>将<code>Boolean</code>对象从<code>String</code>值转换为值value的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WritingConverter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanToStringConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">Boolean</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(Boolean source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source != <span class="keyword">null</span> &amp;&amp; source ? <span class="string">&quot;T&quot;</span> : <span class="string">&quot;F&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are a couple of things to notice here: <code>Boolean</code> and <code>String</code> are both simple types hence Spring Data requires a hint in which direction this converter should apply (reading or writing). By annotating this converter with <code>@WritingConverter</code> you instruct Spring Data to write every <code>Boolean</code> property as <code>String</code> in the database.</p>
<p>这里有两点需要注意：<code>Boolean</code>和<code>String</code>都是简单类型，因此Spring Data需要提示此转换器应应用的方向（读或写）。通过为该转换器添加注释，<code>@WritingConverter</code>可以指示Spring Data写入数据库中的每个<code>Boolean</code>属性为<code>String</code>。</p>
<h4 id="9-11-2-Reading-by-Using-a-Spring-Converter"><a href="#9-11-2-Reading-by-Using-a-Spring-Converter" class="headerlink" title="9.11.2. Reading by Using a Spring Converter"></a>9.11.2. Reading by Using a Spring Converter</h4><p>​    <code>使用Spring转换器读取</code></p>
<p>The following example shows an implementation of a <code>Converter</code> that converts from a <code>String</code> to a <code>Boolean</code> value:</p>
<p>以下示例显示了将 <code>String</code>转换为<code>Boolean</code>值的<code>Converter</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReadingConverter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToBooleanConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source != <span class="keyword">null</span> &amp;&amp; source.equalsIgnoreCase(<span class="string">&quot;T&quot;</span>) ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are a couple of things to notice here: <code>String</code> and <code>Boolean</code> are both simple types hence Spring Data requires a hint in which direction this converter should apply (reading or writing). By annotating this converter with <code>@ReadingConverter</code> you instruct Spring Data to convert every <code>String</code> value from the database that should be assigned to a <code>Boolean</code> property.</p>
<p>这里有两点需要注意：<code>String</code>和<code>Boolean</code>都是简单类型，因此Spring Data需要提示此转换器应应用的方向（读或写）。通过为该转换器添加注释，<code>@ReadingConverter</code>可以指示Spring Data转换<code>String</code>数据库中应分配给<code>Boolean</code>属性的每个值。</p>
<h4 id="9-11-3-Registering-Spring-Converters-with-the-JdbcConverter"><a href="#9-11-3-Registering-Spring-Converters-with-the-JdbcConverter" class="headerlink" title="9.11.3. Registering Spring Converters with the JdbcConverter"></a>9.11.3. Registering Spring Converters with the <code>JdbcConverter</code></h4><p><code>将Spring转换器注册到</code>JdbcConverter``</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJdbcConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractJdbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Overwrite</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcCustomConversions <span class="title">jdbcCustomConversions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcCustomConversions(Arrays.asList(<span class="keyword">new</span> BooleanToStringConverter(), <span class="keyword">new</span> StringToBooleanConverter()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The following example of a Spring <code>Converter</code> implementation converts from a <code>String</code> to a custom <code>Email</code> value object:</p>
<p>以下Spring <code>Converter</code>实现从<code>String</code>为转换自定义<code>Email</code>值对象的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReadingConverter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailReadConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Email</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Email <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Email.valueOf(source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>If you write a <code>Converter</code> whose source and target type are native types, we cannot determine whether we should consider it as a reading or a writing converter. Registering the converter instance as both might lead to unwanted results. For example, a <code>Converter&lt;String, Long&gt;</code> is ambiguous, although it probably does not make sense to try to convert all <code>String</code> instances into <code>Long</code> instances when writing. To let you force the infrastructure to register a converter for only one way, we provide <code>@ReadingConverter</code> and <code>@WritingConverter</code> annotations to be used in the converter implementation.</p>
<p>Converters are subject to explicit registration as instances are not picked up from a classpath or container scan to avoid unwanted registration with a conversion service and the side effects resulting from such a registration. Converters are registered with <code>CustomConversions</code> as the central facility that allows registration and querying for registered converters based on source- and target type.</p>
</blockquote>
<p>如果您编写<code>Converter</code>的源和目标类型是本机类型，则我们无法确定应将其视为读取转换器还是写入转换器。同时注册转换器实例可能会导致不良结果。例如， <code>Converter&lt;String, Long&gt;</code>是模棱两可的，尽管在编写时尝试将所有<code>String</code>实例转换为<code>Long</code>实例可能没有意义。为了让您强制基础结构仅以一种方式注册转换器，我们提供了转换器实现中使用的<code>@ReadingConverter</code>和<code>@WritingConverter</code>注解。</p>
<p>转换器必须进行显式注册，因为不会从类路径或容器扫描中获取实例，以避免使用转换服务进行不必要的注册以及此类注册所带来的副作用。转换器已注册<code>CustomConversions</code>为中央工具，可根据源和目标类型对已注册的转换器进行注册和查询。</p>
<p><code>CustomConversions</code> ships with a pre-defined set of converter registrations:</p>
<ul>
<li><p>JSR-310 Converters for conversion between <code>java.time</code>, <code>java.util.Date</code> and <code>String</code> types.</p>
</li>
<li><p>Deprecated: Joda Time Converters for conversion between <code>org.joda.time</code>, JSR-310, and <code>java.util.Date</code>.</p>
</li>
<li><p>Deprecated: ThreeTenBackport Converters for conversion between <code>org.joda.time</code>, JSR-310, and <code>java.util.Date</code>.</p>
<p><code>CustomConversions</code> 附带一组预定义的转换器注册：</p>
<ul>
<li>JSR-310转换器，用于二者之间的转换<code>java.time</code>，<code>java.util.Date</code>和<code>String</code>类型。</li>
<li>不建议使用：Joda时间转换器，可在<code>org.joda.time</code>，JSR-310和之间进行转换<code>java.util.Date</code>。</li>
<li>不推荐使用：ThreeTenBackport转换器，可在<code>org.joda.time</code>，JSR-310和之间进行转换<code>java.util.Date</code>。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Default converters for local temporal types (e.g. <code>LocalDateTime</code> to <code>java.util.Date</code>) rely on system-default timezone settings to convert between those types. You can override the default converter, by registering your own converter.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>本地时间类型的默认转换器（例如<code>LocalDateTime</code>到<code>java.util.Date</code>）依靠系统默认的时区设置，这些类型之间的转换。您可以通过注册自己的转换器来覆盖默认转换器。</td>
</tr>
</tbody></table>
<h6 id="Converter-Disambiguation"><a href="#Converter-Disambiguation" class="headerlink" title="Converter Disambiguation"></a>Converter Disambiguation</h6><p><code>转换器消除歧义</code></p>
<p>Generally, we inspect the <code>Converter</code> implementations for the source and target types they convert from and to. Depending on whether one of those is a type the underlying data access API can handle natively, we register the converter instance as a reading or a writing converter. The following examples show a writing- and a read converter (note the difference is in the order of the qualifiers on <code>Converter</code>):</p>
<p>通常，我们会检查“Converter”实现，以确定它们从源类型和目标类型之间的转换。根据其中一个类型是否是底层数据可以访问本机处理的类型的API，我们将转换器实例注册为读或写转换器。以下示例显示了一个写-读转换器（注意，区别在于“converter”上限定符的顺序）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write converter as only the target type is one that can be handled natively</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">Person</span>, <span class="title">String</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read converter as only the source type is one that can be handled natively</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Person</span>&gt; </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-12-Logging"><a href="#9-12-Logging" class="headerlink" title="9.12. Logging"></a>9.12. Logging</h3><p><code>日志</code></p>
<p>Spring Data JDBC does little to no logging on its own. Instead, the mechanics of <code>JdbcTemplate</code> to issue SQL statements provide logging. Thus, if you want to inspect what SQL statements are run, activate logging for Spring’s <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/data-access.html#jdbc-JdbcTemplate"><code>NamedParameterJdbcTemplate</code></a> or <a target="_blank" rel="noopener" href="https://www.mybatis.org/mybatis-3/logging.html">MyBatis</a>.</p>
<p>Spring Data JDBC本身很少执行日志记录甚至不执行日志记录。相反，<code>JdbcTemplate</code>发出SQL语句的机制提供了日志记录。因此，如果您想检查运行了哪些SQL语句，请激活Spring <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/data-access.html#jdbc-JdbcTemplate"><code>NamedParameterJdbcTemplate</code></a>或<a target="_blank" rel="noopener" href="https://www.mybatis.org/mybatis-3/logging.html">MyBatis的</a>日志记录。</p>
<h3 id="9-13-Transactionality"><a href="#9-13-Transactionality" class="headerlink" title="9.13. Transactionality"></a>9.13. Transactionality</h3><p>​    <code>事务</code></p>
<p>CRUD methods on repository instances are transactional by default. For reading operations, the transaction configuration <code>readOnly</code> flag is set to <code>true</code>. All others are configured with a plain <code>@Transactional</code> annotation so that default transaction configuration applies. For details, see the Javadoc of <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/jdbc/repository/support/SimpleJdbcRepository.html"><code>SimpleJdbcRepository</code></a>. If you need to tweak transaction configuration for one of the methods declared in a repository, redeclare the method in your repository interface, as follows:</p>
<p>默认情况下，存储库实例上的CRUD方法是事务性的。对于读取操作，事务配置<code>readOnly</code>标志设置为<code>true</code>。所有其他文件都配置有普通<code>@Transactional</code>注释，以便应用默认事务配置。有关详细信息，请参见的Javadoc <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/api/org/springframework/data/jdbc/repository/support/SimpleJdbcRepository.html"><code>SimpleJdbcRepository</code></a>。如果需要调整在存储库中声明的方法之一的事务配置，请在存储库接口中重新声明该方法，如下所示</p>
<p>Example 64. Custom transaction configuration for CRUD</p>
<p><strong>例子64. CRUD的自定义事务配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Transactional(timeout = 10)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Further query method declarations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The preceding causes the <code>findAll()</code> method to be run with a timeout of 10 seconds and without the <code>readOnly</code> flag.</p>
<p>Another way to alter transactional behavior is by using a facade or service implementation that typically covers more than one repository. Its purpose is to define transactional boundaries for non-CRUD operations. The following example shows how to create such a facade:</p>
<p>前面的内容导致该<code>findAll()</code>方法以10秒钟的超时时间运行并且没有该<code>readOnly</code>标志。</p>
<p>更改事务行为的另一种方法是使用通常覆盖多个存储库的外观或服务实现。其目的是为非CRUD操作定义事务边界。以下示例显示了如何创建这样的外观：</p>
<p>Example 65. Using a facade to define transactions for multiple repository calls</p>
<p><strong>例子65.使用外观定义多个存储库调用的事务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManagementImpl</span> <span class="keyword">implements</span> <span class="title">UserManagement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RoleRepository roleRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserManagementImpl</span><span class="params">(UserRepository userRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">    RoleRepository roleRepository)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">    <span class="keyword">this</span>.roleRepository = roleRepository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRoleToAllUsers</span><span class="params">(String roleName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Role role = roleRepository.findByName(roleName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : userRepository.findAll()) &#123;</span><br><span class="line">      user.addRole(role);</span><br><span class="line">      userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The preceding example causes calls to <code>addRoleToAllUsers(…)</code> to run inside a transaction (participating in an existing one or creating a new one if none are already running). The transaction configuration for the repositories is neglected, as the outer transaction configuration determines the actual repository to be used. Note that you have to explicitly activate <code>&lt;tx:annotation-driven /&gt;</code> or use <code>@EnableTransactionManagement</code> to get annotation-based configuration for facades working. Note that the preceding example assumes you use component scanning.</p>
<p>前面的示例使调用<code>addRoleToAllUsers(…)</code>在事务内运行（参与现有事务或在没有事务的情况下创建新事务）。由于外部事务配置确定要使用的实际存储库，因此忽略了存储库的事务配置。请注意，您必须显式激活<code>&lt;tx:annotation-driven /&gt;</code>或使用它<code>@EnableTransactionManagement</code>来获取外墙工作的基于注释的配置。请注意，以上示例假定您使用组件扫描。</p>
<h4 id="9-13-1-Transactional-Query-Methods"><a href="#9-13-1-Transactional-Query-Methods" class="headerlink" title="9.13.1. Transactional Query Methods"></a>9.13.1. Transactional Query Methods</h4><p><code>事务查询方法</code></p>
<p>To let your query methods be transactional, use <code>@Transactional</code> at the repository interface you define, as the following example shows:</p>
<p>为了使查询方法具有事务性，请在您定义的存储库接口上使用<code>@Transactional</code>，如以下示例所示：</p>
<p>Example 66. Using @Transactional at query methods</p>
<p><strong>例子66.在查询方法上使用@Transactional</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Modifying</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="meta">@Query(&quot;delete from User u where u.active = false&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteInactiveUsers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Typically, you want the <code>readOnly</code> flag to be set to true, because most of the query methods only read data. In contrast to that, <code>deleteInactiveUsers()</code> uses the <code>@Modifying</code> annotation and overrides the transaction configuration. Thus, the method is with the <code>readOnly</code> flag set to <code>false</code>.</p>
<p>通常，您希望将该<code>readOnly</code>标志设置为true，因为大多数查询方法仅读取数据。与此相反，<code>deleteInactiveUsers()</code>使用<code>@Modifying</code>注释并覆盖事务配置。因此，该方法的<code>readOnly</code>标志设置为<code>false</code>。</p>
<table>
<thead>
<tr>
<th></th>
<th>It is definitely reasonable to use transactions for read-only queries, and we can mark them as such by setting the <code>readOnly</code> flag. This does not, however, act as a check that you do not trigger a manipulating query (although some databases reject <code>INSERT</code> and <code>UPDATE</code> statements inside a read-only transaction). Instead, the <code>readOnly</code> flag is propagated as a hint to the underlying JDBC driver for performance optimizations.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>将事务用于只读查询绝对是合理的，我们可以通过设置<code>readOnly</code>标志将其标记为只读。但是，这并不表示您不会触发操作查询（尽管某些数据库拒绝<code>INSERT</code>和<code>UPDATE</code>只读事务中的语句）。而是将<code>readOnly</code>标志作为提示传播到底层JDBC驱动程序，以进行性能优化。</td>
</tr>
</tbody></table>
<h3 id="9-14-Auditing"><a href="#9-14-Auditing" class="headerlink" title="9.14. Auditing"></a>9.14. Auditing</h3><h4 id="9-14-1-Basics"><a href="#9-14-1-Basics" class="headerlink" title="9.14.1. Basics"></a>9.14.1. Basics</h4><p>Spring Data provides sophisticated support to transparently keep track of who created or changed an entity and when the change happened. To benefit from that functionality, you have to equip your entity classes with auditing metadata that can be defined either using annotations or by implementing an interface.</p>
<p>springdata提供了复杂的支持，可以透明地跟踪谁创建或更改了一个实体，以及更改发生的时间。要利用该功能，您必须为实体类配备审核元数据，该审核元数据可以使用批注或通过实现接口来定义。</p>
<h5 id="Annotation-based-Auditing-Metadata"><a href="#Annotation-based-Auditing-Metadata" class="headerlink" title="Annotation-based Auditing Metadata"></a>Annotation-based Auditing Metadata</h5><p><code>基于注释的审核元数据</code></p>
<p>We provide <code>@CreatedBy</code> and <code>@LastModifiedBy</code> to capture the user who created or modified the entity as well as <code>@CreatedDate</code> and <code>@LastModifiedDate</code> to capture when the change happened.</p>
<p>我们提供<code>@CreatedBy</code>和<code>@LastModifiedBy</code>捕捉谁创建或修改的实体以及用户<code>@CreatedDate</code>和<code>@LastModifiedDate</code>以捕获时的变化发生了。</p>
<p>Example 67. An audited entity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CreatedBy</span></span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CreatedDate</span></span><br><span class="line">  <span class="keyword">private</span> DateTime createdDate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// … further properties omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, the annotations can be applied selectively, depending on which information you want to capture. The annotations capturing when changes were made can be used on properties of type Joda-Time, <code>DateTime</code>, legacy Java <code>Date</code> and <code>Calendar</code>, JDK8 date and time types, and <code>long</code> or <code>Long</code>.</p>
<p>如您所见，可以选择性地应用注释，这取决于您想要捕获的信息。在进行更改时捕获的注释可以用于jodatime、<code>DateTime</code>、遗留Java<code>Date</code>和<code>Calendar</code>、JDK8日期和时间类型以及<code>long</code>或<code>long</code>类型的属性。</p>
<h5 id="Interface-based-Auditing-Metadata"><a href="#Interface-based-Auditing-Metadata" class="headerlink" title="Interface-based Auditing Metadata"></a>Interface-based Auditing Metadata</h5><p><code>基于接口的审核元数据</code></p>
<blockquote>
<p>In case you do not want to use annotations to define auditing metadata, you can let your domain class implement the <code>Auditable</code> interface. It exposes setter methods for all of the auditing properties.</p>
<p>There is also a convenience base class, <code>AbstractAuditable</code>, which you can extend to avoid the need to manually implement the interface methods. Doing so increases the coupling of your domain classes to Spring Data, which might be something you want to avoid. Usually, the annotation-based way of defining auditing metadata is preferred as it is less invasive and more flexible.</p>
<h5 id="AuditorAware"><a href="#AuditorAware" class="headerlink" title="AuditorAware"></a><code>AuditorAware</code></h5><p>In case you use either <code>@CreatedBy</code> or <code>@LastModifiedBy</code>, the auditing infrastructure somehow needs to become aware of the current principal. To do so, we provide an <code>AuditorAware&lt;T&gt;</code> SPI interface that you have to implement to tell the infrastructure who the current user or system interacting with the application is. The generic type <code>T</code> defines what type the properties annotated with <code>@CreatedBy</code> or <code>@LastModifiedBy</code> have to be.</p>
<p>The following example shows an implementation of the interface that uses Spring Security’s <code>Authentication</code> object:</p>
</blockquote>
<p>如果您不想使用注释来定义审核元数据，则可以让您的域类实现该<code>Auditable</code>接口。它公开了所有审核属性的设置器方法。</p>
<p>还有一个便捷的基类，<code>AbstractAuditable</code>您可以对其进行扩展，以避免需要手动实现接口方法。这样做会增加您的域类与Spring Data的耦合，这可能是您要避免的事情。通常，首选基于注释的方式来定义审计元数据，因为它侵入性较小且更灵活。</p>
<h5 id="AuditorAware-1"><a href="#AuditorAware-1" class="headerlink" title="AuditorAware"></a><code>AuditorAware</code></h5><p>如果您使用<code>@CreatedBy</code>或<code>@LastModifiedBy</code>，则审计基础结构需要以某种方式了解当前的主体。为此，我们提供了一个<code>AuditorAware&lt;T&gt;</code>SPI接口，您必须实现该接口以告诉基础结构与应用程序交互的当前用户或系统是谁。泛型类型<code>T</code>定义使用<code>@CreatedBy</code>或<code>@LastModifiedBy</code>必须注释的属性的类型。</p>
<p>以下示例显示了使用Spring Security <code>Authentication</code>对象的接口的实现：</p>
<p>Example 68. Implementation of AuditorAware based on Spring Security</p>
<p><strong>例子68.基于Spring Security的AuditorAware的实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringSecurityAuditorAware</span> <span class="keyword">implements</span> <span class="title">AuditorAware</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Optional&lt;User&gt; <span class="title">getCurrentAuditor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(SecurityContextHolder.getContext())</span><br><span class="line">              .map(SecurityContext::getAuthentication)</span><br><span class="line">              .filter(Authentication::isAuthenticated)</span><br><span class="line">              .map(Authentication::getPrincipal)</span><br><span class="line">              .map(User.class::cast);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The implementation accesses the <code>Authentication</code> object provided by Spring Security and looks up the custom <code>UserDetails</code> instance that you have created in your <code>UserDetailsService</code> implementation. We assume here that you are exposing the domain user through the <code>UserDetails</code> implementation but that, based on the <code>Authentication</code> found, you could also look it up from anywhere.</p>
<p>该实现访问<code>Authentication</code>Spring Security提供的对象，并查找<code>UserDetails</code>您在<code>UserDetailsService</code>实现中创建的自定义实例。我们在这里假设您正在通过<code>UserDetails</code>实现公开域用户，但是根据<code>Authentication</code>找到的内容，您还可以从任何地方查找它。</p>
<h3 id="9-15-JDBC-Auditing"><a href="#9-15-JDBC-Auditing" class="headerlink" title="9.15. JDBC Auditing"></a>9.15. JDBC Auditing</h3><p>In order to activate auditing, add <code>@EnableJdbcAuditing</code> to your configuration, as the following example shows:</p>
<p>为了激活审核，请添加<code>@EnableJdbcAuditing</code>到您的配置，如以下示例所示：</p>
<p>Example 69. Activating auditing with Java configuration</p>
<p><strong>例子69.用Java配置激活审计</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJdbcAuditing</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AuditorAware&lt;AuditableUser&gt; <span class="title">auditorProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AuditorAwareImpl();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you expose a bean of type <code>AuditorAware</code> to the <code>ApplicationContext</code>, the auditing infrastructure automatically picks it up and uses it to determine the current user to be set on domain types. If you have multiple implementations registered in the <code>ApplicationContext</code>, you can select the one to be used by explicitly setting the <code>auditorAwareRef</code> attribute of <code>@EnableJdbcAuditing</code>.</p>
<p>如果您将类型的Bean暴露<code>AuditorAware</code>给<code>ApplicationContext</code>，则审核基础结构会自动选择它并使用它来确定要在域类型上设置的当前用户。如果您在<code>ApplicationContext</code>其中注册了多个实现，则<code>ApplicationContext</code>可以通过显式设置的<code>auditorAwareRef</code>属性来选择要使用的实现<code>@EnableJdbcAuditing</code>。</p>
<h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="Appendix-A-Glossary"><a href="#Appendix-A-Glossary" class="headerlink" title="Appendix A: Glossary"></a>Appendix A: Glossary</h2><h2 id="附录A：词汇表"><a href="#附录A：词汇表" class="headerlink" title="附录A：词汇表"></a>附录A：词汇表</h2><ul>
<li><p>AOP</p>
<p>Aspect-Oriented Programming</p>
<p>面向方面的编程</p>
</li>
<li><p>CRUD</p>
<p>Create, Read, Update, Delete - Basic persistence operations</p>
<p>创建，读取，更新，删除-基本持久性操作</p>
</li>
<li><p>Dependency Injection</p>
<p><strong>依赖注入</strong></p>
<p>Pattern to hand a component’s dependency to the component from outside, freeing the component to lookup the dependent itself. For more information, see <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dependency_Injection">https://en.wikipedia.org/wiki/Dependency_Injection</a>.</p>
<p>从外部将组件的依赖关系传递给组件的模式，以释放组件本身以查找依赖项。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dependency_Injection">https://zh.wikipedia.org/wiki/Dependency_Injection</a>。</p>
</li>
<li><p>JPA</p>
<p>Java Persistence API</p>
<p>Java持久性API</p>
</li>
<li><p>Spring</p>
<p>Java application framework — <a target="_blank" rel="noopener" href="https://projects.spring.io/spring-framework">https://projects.spring.io/spring-framework</a></p>
<p>Java应用程序框架— <a target="_blank" rel="noopener" href="https://projects.spring.io/spring-framework">https://projects.spring.io/spring-framework</a></p>
</li>
</ul>
<h2 id="Appendix-B-Namespace-reference"><a href="#Appendix-B-Namespace-reference" class="headerlink" title="Appendix B: Namespace reference"></a>Appendix B: Namespace reference</h2><h2 id="命名空间参考"><a href="#命名空间参考" class="headerlink" title="命名空间参考"></a>命名空间参考</h2><h3 id="The-lt-repositories-gt-Element"><a href="#The-lt-repositories-gt-Element" class="headerlink" title="The &lt;repositories /&gt; Element"></a>The <code>&lt;repositories /&gt;</code> Element</h3><p>The <code>&lt;repositories /&gt;</code> element triggers the setup of the Spring Data repository infrastructure. The most important attribute is <code>base-package</code>, which defines the package to scan for Spring Data repository interfaces. See “<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.create-instances.spring">XML configuration</a>”. The following table describes the attributes of the <code>&lt;repositories /&gt;</code> element:</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>base-package</code></td>
<td align="left">Defines the package to be scanned for repository interfaces that extend <code>*Repository</code> (the actual interface is determined by the specific Spring Data module) in auto-detection mode. All packages below the configured package are scanned, too. Wildcards are allowed.</td>
</tr>
<tr>
<td align="left"><code>repository-impl-postfix</code></td>
<td align="left">Defines the postfix to autodetect custom repository implementations. Classes whose names end with the configured postfix are considered as candidates. Defaults to <code>Impl</code>.</td>
</tr>
<tr>
<td align="left"><code>query-lookup-strategy</code></td>
<td align="left">Determines the strategy to be used to create finder queries. See “<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.query-methods.query-lookup-strategies">Query Lookup Strategies</a>” for details. Defaults to <code>create-if-not-found</code>.</td>
</tr>
<tr>
<td align="left"><code>named-queries-location</code></td>
<td align="left">Defines the location to search for a Properties file containing externally defined queries.</td>
</tr>
<tr>
<td align="left"><code>consider-nested-repositories</code></td>
<td align="left">Whether nested repository interface definitions should be considered. Defaults to <code>false</code>.</td>
</tr>
</tbody></table>
<p>该<code>&lt;repositories /&gt;</code>元素触发Spring Data存储库基础结构的设置。最重要的属性是<code>base-package</code>，它定义用于扫描Spring Data存储库接口的包。请参阅“ <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.create-instances.spring">XML配置</a> ”。下表描述了<code>&lt;repositories /&gt;</code>元素的属性：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>base-package</code></td>
<td align="left">定义要扫描的软件包，以查找<code>*Repository</code>在自动检测模式下扩展的存储库接口（实际接口由特定的Spring Data模块确定）。配置包下面的所有包也将被扫描。允许使用通配符。</td>
</tr>
<tr>
<td align="left"><code>repository-impl-postfix</code></td>
<td align="left">定义后缀以自动检测自定义存储库实现。名称以配置的后缀结尾的类被视为候选。默认为<code>Impl</code>。</td>
</tr>
<tr>
<td align="left"><code>query-lookup-strategy</code></td>
<td align="left">确定用于创建查找器查询的策略。有关详细信息，请参见“ <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.query-methods.query-lookup-strategies">查询查找策略</a> ”。默认为<code>create-if-not-found</code>。</td>
</tr>
<tr>
<td align="left"><code>named-queries-location</code></td>
<td align="left">定义搜索包含外部定义查询的属性文件的位置。</td>
</tr>
<tr>
<td align="left"><code>consider-nested-repositories</code></td>
<td align="left">是否应考虑嵌套的存储库接口定义。默认为<code>false</code></td>
</tr>
</tbody></table>
<h2 id="Appendix-C-Populators-namespace-reference"><a href="#Appendix-C-Populators-namespace-reference" class="headerlink" title="Appendix C: Populators namespace reference"></a>Appendix C: Populators namespace reference</h2><h2 id="填充器名称空间参考"><a href="#填充器名称空间参考" class="headerlink" title="填充器名称空间参考"></a>填充器名称空间参考</h2><h3 id="The-element"><a href="#The-element" class="headerlink" title="The  element"></a>The <populator /> element</h3><p>The <code>&lt;populator /&gt;</code> element allows to populate the a data store via the Spring Data repository infrastructure.[<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#_footnotedef_1">1</a>]</p>
<p>该<code>&lt;populator /&gt;</code>元素允许通过Spring数据存储库基础结构填充数据存储。[ <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#_footnotedef_1">1</a> ]</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>locations</code></td>
<td align="left">Where to find the files to read the objects from the repository shall be populated with.</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>locations</code></td>
<td align="left">应该在哪里找到文件以从存储库中读取对象。</td>
</tr>
</tbody></table>
<h2 id="Appendix-D-Repository-query-keywords"><a href="#Appendix-D-Repository-query-keywords" class="headerlink" title="Appendix D: Repository query keywords"></a>Appendix D: Repository query keywords</h2><h2 id="储存库查询关键字"><a href="#储存库查询关键字" class="headerlink" title="储存库查询关键字"></a>储存库查询关键字</h2><h3 id="Supported-query-keywords"><a href="#Supported-query-keywords" class="headerlink" title="Supported query keywords"></a>Supported query keywords</h3><p>The following table lists the keywords generally supported by the Spring Data repository query derivation mechanism. However, consult the store-specific documentation for the exact list of supported keywords, because some keywords listed here might not be supported in a particular store.</p>
<h3 id="支持的查询关键字"><a href="#支持的查询关键字" class="headerlink" title="支持的查询关键字"></a>支持的查询关键字</h3><p>下表列出了Spring Data存储库查询派生机制通常支持的关键字。但是，请参阅存储库特定的文档以获取受支持关键字的确切列表，因为特定存储库可能不支持此处列出的某些关键字。</p>
<table>
<thead>
<tr>
<th align="left">Logical keyword</th>
<th align="left">Keyword expressions</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>AND</code></td>
<td align="left"><code>And</code></td>
</tr>
<tr>
<td align="left"><code>OR</code></td>
<td align="left"><code>Or</code></td>
</tr>
<tr>
<td align="left"><code>AFTER</code></td>
<td align="left"><code>After</code>, <code>IsAfter</code></td>
</tr>
<tr>
<td align="left"><code>BEFORE</code></td>
<td align="left"><code>Before</code>, <code>IsBefore</code></td>
</tr>
<tr>
<td align="left"><code>CONTAINING</code></td>
<td align="left"><code>Containing</code>, <code>IsContaining</code>, <code>Contains</code></td>
</tr>
<tr>
<td align="left"><code>BETWEEN</code></td>
<td align="left"><code>Between</code>, <code>IsBetween</code></td>
</tr>
<tr>
<td align="left"><code>ENDING_WITH</code></td>
<td align="left"><code>EndingWith</code>, <code>IsEndingWith</code>, <code>EndsWith</code></td>
</tr>
<tr>
<td align="left"><code>EXISTS</code></td>
<td align="left"><code>Exists</code></td>
</tr>
<tr>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>False</code>, <code>IsFalse</code></td>
</tr>
<tr>
<td align="left"><code>GREATER_THAN</code></td>
<td align="left"><code>GreaterThan</code>, <code>IsGreaterThan</code></td>
</tr>
<tr>
<td align="left"><code>GREATER_THAN_EQUALS</code></td>
<td align="left"><code>GreaterThanEqual</code>, <code>IsGreaterThanEqual</code></td>
</tr>
<tr>
<td align="left"><code>IN</code></td>
<td align="left"><code>In</code>, <code>IsIn</code></td>
</tr>
<tr>
<td align="left"><code>IS</code></td>
<td align="left"><code>Is</code>, <code>Equals</code>, (or no keyword)</td>
</tr>
<tr>
<td align="left"><code>IS_EMPTY</code></td>
<td align="left"><code>IsEmpty</code>, <code>Empty</code></td>
</tr>
<tr>
<td align="left"><code>IS_NOT_EMPTY</code></td>
<td align="left"><code>IsNotEmpty</code>, <code>NotEmpty</code></td>
</tr>
<tr>
<td align="left"><code>IS_NOT_NULL</code></td>
<td align="left"><code>NotNull</code>, <code>IsNotNull</code></td>
</tr>
<tr>
<td align="left"><code>IS_NULL</code></td>
<td align="left"><code>Null</code>, <code>IsNull</code></td>
</tr>
<tr>
<td align="left"><code>LESS_THAN</code></td>
<td align="left"><code>LessThan</code>, <code>IsLessThan</code></td>
</tr>
<tr>
<td align="left"><code>LESS_THAN_EQUAL</code></td>
<td align="left"><code>LessThanEqual</code>, <code>IsLessThanEqual</code></td>
</tr>
<tr>
<td align="left"><code>LIKE</code></td>
<td align="left"><code>Like</code>, <code>IsLike</code></td>
</tr>
<tr>
<td align="left"><code>NEAR</code></td>
<td align="left"><code>Near</code>, <code>IsNear</code></td>
</tr>
<tr>
<td align="left"><code>NOT</code></td>
<td align="left"><code>Not</code>, <code>IsNot</code></td>
</tr>
<tr>
<td align="left"><code>NOT_IN</code></td>
<td align="left"><code>NotIn</code>, <code>IsNotIn</code></td>
</tr>
<tr>
<td align="left"><code>NOT_LIKE</code></td>
<td align="left"><code>NotLike</code>, <code>IsNotLike</code></td>
</tr>
<tr>
<td align="left"><code>REGEX</code></td>
<td align="left"><code>Regex</code>, <code>MatchesRegex</code>, <code>Matches</code></td>
</tr>
<tr>
<td align="left"><code>STARTING_WITH</code></td>
<td align="left"><code>StartingWith</code>, <code>IsStartingWith</code>, <code>StartsWith</code></td>
</tr>
<tr>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>True</code>, <code>IsTrue</code></td>
</tr>
<tr>
<td align="left"><code>WITHIN</code></td>
<td align="left"><code>Within</code>, <code>IsWithin</code></td>
</tr>
</tbody></table>
<h2 id="Appendix-E-Repository-query-return-types"><a href="#Appendix-E-Repository-query-return-types" class="headerlink" title="Appendix E: Repository query return types"></a>Appendix E: Repository query return types</h2><h2 id="存储库查询返回类型"><a href="#存储库查询返回类型" class="headerlink" title="存储库查询返回类型"></a>存储库查询返回类型</h2><h3 id="Supported-Query-Return-Types"><a href="#Supported-Query-Return-Types" class="headerlink" title="Supported Query Return Types"></a>Supported Query Return Types</h3><h3 id="支持的查询返回类型"><a href="#支持的查询返回类型" class="headerlink" title="支持的查询返回类型"></a>支持的查询返回类型</h3><p>The following table lists the return types generally supported by Spring Data repositories. However, consult the store-specific documentation for the exact list of supported return types, because some types listed here might not be supported in a particular store.</p>
<p>下表列出了Spring Data存储库通常支持的返回类型。但是，请参阅存储库特定的文档以获取受支持的返回类型的确切列表，因为特定存储库可能不支持此处列出的某些类型。</p>
<table>
<thead>
<tr>
<th></th>
<th>Geospatial types (such as <code>GeoResult</code>, <code>GeoResults</code>, and <code>GeoPage</code>) are available only for data stores that support geospatial queries.</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>地理空间类型（如<code>GeoResult</code>，<code>GeoResults</code>，和<code>GeoPage</code>）是仅适用于支持地理空间查询的数据存储。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">Return type</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void</code></td>
<td align="left">Denotes no return value.</td>
</tr>
<tr>
<td align="left">Primitives</td>
<td align="left">Java primitives.</td>
</tr>
<tr>
<td align="left">Wrapper types</td>
<td align="left">Java wrapper types.</td>
</tr>
<tr>
<td align="left"><code>T</code></td>
<td align="left">A unique entity. Expects the query method to return one result at most. If no result is found, <code>null</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td align="left"><code>Iterator&lt;T&gt;</code></td>
<td align="left">An <code>Iterator</code>.</td>
</tr>
<tr>
<td align="left"><code>Collection&lt;T&gt;</code></td>
<td align="left">A <code>Collection</code>.</td>
</tr>
<tr>
<td align="left"><code>List&lt;T&gt;</code></td>
<td align="left">A <code>List</code>.</td>
</tr>
<tr>
<td align="left"><code>Optional&lt;T&gt;</code></td>
<td align="left">A Java 8 or Guava <code>Optional</code>. Expects the query method to return one result at most. If no result is found, <code>Optional.empty()</code> or <code>Optional.absent()</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td align="left"><code>Option&lt;T&gt;</code></td>
<td align="left">Either a Scala or Vavr <code>Option</code> type. Semantically the same behavior as Java 8’s <code>Optional</code>, described earlier.</td>
</tr>
<tr>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left">A Java 8 <code>Stream</code>.</td>
</tr>
<tr>
<td align="left"><code>Streamable&lt;T&gt;</code></td>
<td align="left">A convenience extension of <code>Iterable</code> that directy exposes methods to stream, map and filter results, concatenate them etc.</td>
</tr>
<tr>
<td align="left">Types that implement <code>Streamable</code> and take a <code>Streamable</code> constructor or factory method argument</td>
<td align="left">Types that expose a constructor or <code>….of(…)</code>/<code>….valueOf(…)</code> factory method taking a <code>Streamable</code> as argument. See <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.collections-and-iterables.streamable-wrapper">Returning Custom Streamable Wrapper Types</a> for details.</td>
</tr>
<tr>
<td align="left">Vavr <code>Seq</code>, <code>List</code>, <code>Map</code>, <code>Set</code></td>
<td align="left">Vavr collection types. See <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.collections-and-iterables.vavr">Support for Vavr Collections</a> for details.</td>
</tr>
<tr>
<td align="left"><code>Future&lt;T&gt;</code></td>
<td align="left">A <code>Future</code>. Expects a method to be annotated with <code>@Async</code> and requires Spring’s asynchronous method execution capability to be enabled.</td>
</tr>
<tr>
<td align="left"><code>CompletableFuture&lt;T&gt;</code></td>
<td align="left">A Java 8 <code>CompletableFuture</code>. Expects a method to be annotated with <code>@Async</code> and requires Spring’s asynchronous method execution capability to be enabled.</td>
</tr>
<tr>
<td align="left"><code>ListenableFuture</code></td>
<td align="left">A <code>org.springframework.util.concurrent.ListenableFuture</code>. Expects a method to be annotated with <code>@Async</code> and requires Spring’s asynchronous method execution capability to be enabled.</td>
</tr>
<tr>
<td align="left"><code>Slice</code></td>
<td align="left">A sized chunk of data with an indication of whether there is more data available. Requires a <code>Pageable</code> method parameter.</td>
</tr>
<tr>
<td align="left"><code>Page&lt;T&gt;</code></td>
<td align="left">A <code>Slice</code> with additional information, such as the total number of results. Requires a <code>Pageable</code> method parameter.</td>
</tr>
<tr>
<td align="left"><code>GeoResult&lt;T&gt;</code></td>
<td align="left">A result entry with additional information, such as the distance to a reference location.</td>
</tr>
<tr>
<td align="left"><code>GeoResults&lt;T&gt;</code></td>
<td align="left">A list of <code>GeoResult&lt;T&gt;</code> with additional information, such as the average distance to a reference location.</td>
</tr>
<tr>
<td align="left"><code>GeoPage&lt;T&gt;</code></td>
<td align="left">A <code>Page</code> with <code>GeoResult&lt;T&gt;</code>, such as the average distance to a reference location.</td>
</tr>
<tr>
<td align="left"><code>Mono&lt;T&gt;</code></td>
<td align="left">A Project Reactor <code>Mono</code> emitting zero or one element using reactive repositories. Expects the query method to return one result at most. If no result is found, <code>Mono.empty()</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td align="left"><code>Flux&lt;T&gt;</code></td>
<td align="left">A Project Reactor <code>Flux</code> emitting zero, one, or many elements using reactive repositories. Queries returning <code>Flux</code> can emit also an infinite number of elements.</td>
</tr>
<tr>
<td align="left"><code>Single&lt;T&gt;</code></td>
<td align="left">A RxJava <code>Single</code> emitting a single element using reactive repositories. Expects the query method to return one result at most. If no result is found, <code>Mono.empty()</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td align="left"><code>Maybe&lt;T&gt;</code></td>
<td align="left">A RxJava <code>Maybe</code> emitting zero or one element using reactive repositories. Expects the query method to return one result at most. If no result is found, <code>Mono.empty()</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td align="left"><code>Flowable&lt;T&gt;</code></td>
<td align="left">A RxJava <code>Flowable</code> emitting zero, one, or many elements using reactive repositories. Queries returning <code>Flowable</code> can emit also an infinite number of elements.</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th align="left">返回类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void</code></td>
<td align="left">表示没有返回值。</td>
</tr>
<tr>
<td align="left">Primitives</td>
<td align="left">Java基元。</td>
</tr>
<tr>
<td align="left">Wrapper types</td>
<td align="left">Java包装器类型。</td>
</tr>
<tr>
<td align="left"><code>T</code></td>
<td align="left">唯一实体。期望查询方法最多返回一个结果。如果未找到结果，<code>null</code>则返回。多个结果触发<code>IncorrectResultSizeDataAccessException</code>。</td>
</tr>
<tr>
<td align="left"><code>Iterator&lt;T&gt;</code></td>
<td align="left">的<code>Iterator</code>。</td>
</tr>
<tr>
<td align="left"><code>Collection&lt;T&gt;</code></td>
<td align="left">一<code>Collection</code>。</td>
</tr>
<tr>
<td align="left"><code>List&lt;T&gt;</code></td>
<td align="left">一<code>List</code>。</td>
</tr>
<tr>
<td align="left"><code>Optional&lt;T&gt;</code></td>
<td align="left">Java 8或Guava <code>Optional</code>。期望查询方法最多返回一个结果。如果没有找到结果，<code>Optional.empty()</code>或者<code>Optional.absent()</code>返回结果。多个结果触发<code>IncorrectResultSizeDataAccessException</code>。</td>
</tr>
<tr>
<td align="left"><code>Option&lt;T&gt;</code></td>
<td align="left">Scala或Vavr <code>Option</code>类型。语义上与<code>Optional</code>前面描述的Java 8相同。</td>
</tr>
<tr>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left">Java 8 <code>Stream</code>。</td>
</tr>
<tr>
<td align="left"><code>Streamable&lt;T&gt;</code></td>
<td align="left">该便利性的便捷扩展<code>Iterable</code>使方法可以流式处理，映射和过滤结果，将它们连接起来等。</td>
</tr>
<tr>
<td align="left">实现<code>Streamable</code>并接受<code>Streamable</code>构造函数或工厂方法参数的类型</td>
<td align="left">公开以a 作为参数的构造函数或<code>….of(…)</code>/ <code>….valueOf(…)</code>工厂方法的类型<code>Streamable</code>。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.collections-and-iterables.streamable-wrapper">返回自定义可流包装器类型</a>。</td>
</tr>
<tr>
<td align="left">Vavr <code>Seq</code>，<code>List</code>，<code>Map</code>，<code>Set</code></td>
<td align="left">Vavr集合类型。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.collections-and-iterables.vavr">支持Vavr集合</a>。</td>
</tr>
<tr>
<td align="left"><code>Future&lt;T&gt;</code></td>
<td align="left">一<code>Future</code>。期望使用方法进行注释，<code>@Async</code>并且需要启用Spring的异步方法执行功能。</td>
</tr>
<tr>
<td align="left"><code>CompletableFuture&lt;T&gt;</code></td>
<td align="left">Java 8 <code>CompletableFuture</code>。期望使用方法进行注释，<code>@Async</code>并且需要启用Spring的异步方法执行功能。</td>
</tr>
<tr>
<td align="left"><code>ListenableFuture</code></td>
<td align="left">一<code>org.springframework.util.concurrent.ListenableFuture</code>。期望使用方法进行注释，<code>@Async</code>并且需要启用Spring的异步方法执行功能。</td>
</tr>
<tr>
<td align="left"><code>Slice</code></td>
<td align="left">一定大小的数据块，用于指示是否有更多可用数据。需要一个<code>Pageable</code>方法参数。</td>
</tr>
<tr>
<td align="left"><code>Page&lt;T&gt;</code></td>
<td align="left">阿<code>Slice</code>与其他信息，例如结果的总数。需要一个<code>Pageable</code>方法参数。</td>
</tr>
<tr>
<td align="left"><code>GeoResult&lt;T&gt;</code></td>
<td align="left">具有附加信息（例如到参考位置的距离）的结果条目。</td>
</tr>
<tr>
<td align="left"><code>GeoResults&lt;T&gt;</code></td>
<td align="left"><code>GeoResult&lt;T&gt;</code>具有其他信息的列表，例如到参考位置的平均距离。</td>
</tr>
<tr>
<td align="left"><code>GeoPage&lt;T&gt;</code></td>
<td align="left">甲<code>Page</code>带<code>GeoResult&lt;T&gt;</code>，如到参考位置的平均距离。</td>
</tr>
<tr>
<td align="left"><code>Mono&lt;T&gt;</code></td>
<td align="left"><code>Mono</code>使用反应性储存库发射零或一个元素的项目反应堆。期望查询方法最多返回一个结果。如果未找到结果，<code>Mono.empty()</code>则返回。多个结果触发<code>IncorrectResultSizeDataAccessException</code>。</td>
</tr>
<tr>
<td align="left"><code>Flux&lt;T&gt;</code></td>
<td align="left"><code>Flux</code>使用反应性存储库发射零，一个或多个元素的项目反应堆。返回的查询<code>Flux</code>也可以发出无限数量的元素。</td>
</tr>
<tr>
<td align="left"><code>Single&lt;T&gt;</code></td>
<td align="left"><code>Single</code>使用反应性存储库发出单个元素的RxJava 。期望查询方法最多返回一个结果。如果未找到结果，<code>Mono.empty()</code>则返回。多个结果触发<code>IncorrectResultSizeDataAccessException</code>。</td>
</tr>
<tr>
<td align="left"><code>Maybe&lt;T&gt;</code></td>
<td align="left"><code>Maybe</code>使用反应性存储库发出零或一个元素的RxJava 。期望查询方法最多返回一个结果。如果未找到结果，<code>Mono.empty()</code>则返回。多个结果触发<code>IncorrectResultSizeDataAccessException</code>。</td>
</tr>
<tr>
<td align="left"><code>Flowable&lt;T&gt;</code></td>
<td align="left"><code>Flowable</code>使用反应性存储库发出零个，一个或多个元素的RxJava 。返回的查询<code>Flowable</code>也可以发出无限数量的元素。</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#_footnoteref_1">1</a>. see <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.0.3.RELEASE/reference/html/#repositories.create-instances.spring">XML configuration</a></p>
<p>Version 2.0.3.RELEASE<br>Last updated 2020-08-12 13:31:00 +0200</p>

      

      
        <div class="page-reward">
          <a href="javascript:;" class="page-reward-btn tooltip-top">
            <div class="tooltip tooltip-east">
            <span class="tooltip-item">
              赏
            </span>
            <span class="tooltip-content">
              <span class="tooltip-text">
                <span class="tooltip-inner">
                  <p class="reward-p"><i class="icon icon-quo-left"></i>谢谢你请我吃糖果<i class="icon icon-quo-right"></i></p>
                  <div class="reward-box">
                    
                    
                  </div>
                </span>
              </span>
            </span>
          </div>
          </a>
        </div>
      
    </div>
    <div class="article-info article-info-index">
      
      
      

      

      
        
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//pan.baidu.com/share/qrcode?url=http://yoursite.com/2020/08/21/Spring-Data-JDBC-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/" alt="微信分享二维码">
    </div>
</div>

<div class="mask js-mask"></div>
      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2020/08/21/Spring-Data%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C-002/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Spring Data-002开发手册</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>



  
  
  

  

  

  
  <div id="gitment-ctn"></div> 
<link rel="stylesheet" href="//imsun.github.io/gitment/style/default.css">
<script src="//imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: "http://yoursite.com/2020/08/21/Spring-Data-JDBC-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/",
  owner: '26849335',
  repo: 'http://github.com/cheriduk/cheriduk.github.io.git',
  oauth: {
    client_id: '26219aa5a535b9aa8cca',
    client_secret: '4cdfc1c25917dc11239fec3641819ad3f204d67b',
  },
})
gitment.render('gitment-ctn')
</script>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 John Doe
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>



    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接1</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接2</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接3</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接4</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接5</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接6</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>